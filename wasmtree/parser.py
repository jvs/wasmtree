# Generated by ../generate_parser.py
"""
# Grammar definition:
```
import struct
```

class Module {
    magic: b'\\x00\\x61\\x73\\x6D'
    version: b'\\x01\\x00\\x00\\x00'
    custom1: CustomSection*
    typesec: TypeSection?
    custom2: CustomSection*
}


# Sections.
class CustomSection {
    id: 0x00
    size: u32
    body: bytechar{size} |> `lambda x: b''.join(x)`
}

class TypeSection {
    id: 0x01
    size: u32
    func_types: vec(FuncType)
}


# Types.
class FuncType {
    params: 0x60 >> vec(ValueType)
    results: vec(ValueType)
}

ValueType = NumberType | ReferenceType

NumberType = (
    0x7F >> `'i32'`
    | 0x7E >> `'i64'`
    | 0x7D >> `'f32'`
    | 0x7C >> `'f64'`
)

ReferenceType = (
    0x70 >> `'funcref'`
    | 0x6F >> `'externref'`
)


# Vectors.
vec(element) =>
    let length = u32 in
    element{length}


# Names.
name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
bytechar = b/[\\x00-\\xFF]/


# Numbers.
byte = b/[\\x00-\\xFF]/ |> `ord`
u32 = UnsignedInt
i32 = SignedInt
i64 = SignedInt
f32 = b/[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
f64 = b/[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`

SignedInt = LEB128 |> `decode_signed_int`
UnsignedInt = LEB128 |> `decode_unsigned_int`
LEB128 = b/[\\x80-\\xFF]*[\\x00-\\x7F]/

```
continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result
```

"""

from collections import namedtuple as _nt
from re import compile as _compile_re, IGNORECASE as _IGNORECASE

class Node:
    _fields = ()

    def __init__(self):
        self._metadata = _Metadata()

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            if getattr(self, field) != getattr(other, field):
                return False
        return True

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        result = self.__class__(**kw)
        result._metadata.update(self._metadata)
        return result


class _Metadata:
    def __init__(self, **fields):
        object.__setattr__(self, '_fields', fields)

    def __getattr__(self, name):
        return self._fields.get(name)

    def __setattr__(self, name, value):
        self._fields[name] = value

    def __len__(self):
        return len(self._fields)

    def copy(self):
        return _Metadata(**self._fields)

    def update(self, other):
        self._fields.update(other._fields)


class Rule:
    def __init__(self, name, parse, definition):
        self.name = name
        self.parse = parse
        self.definition = definition

    def __repr__(self):
        return (f'Rule(name={self.name!r}, parse={self.parse.__name__},'
            f' definition={self.definition!r})')


import struct


continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result


class SourcerError(Exception):
    """Common superclass for ParseError and PartialParseError."""


class ParseError(SourcerError):
    def __init__(self, message, index, line, column):
        super().__init__(message)
        self.position = _Position(index, line, column)


class PartialParseError(SourcerError):
    def __init__(self, partial_result, last_position, excerpt):
        super().__init__('Incomplete parse. Unexpected input on line'
            f' {last_position.line}, column {last_position.column}:\n{excerpt}')
        self.partial_result = partial_result
        self.last_position = last_position


class Infix(Node):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        Node.__init__(self)
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(Node):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        Node.__init__(self)
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(Node):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        Node.__init__(self)
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Module, fullparse)


_PositionInfo = _nt('_PositionInfo', 'start, end')

_Position = _nt('_Position', 'index, line, column')


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _text, _pos):
        return self.func(_text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


class _ByteLiteral(int):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_byte_literal(byte_value, parse_function):
    result = _ByteLiteral(byte_value)
    result._parse_function = parse_function
    return result


def _run(text, pos, start, fullparse):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return _finalize_parse_info(text, result[1], result[2], fullparse)
    else:
        pos = result[2]
        message = result[1](text, pos)
        raise ParseError(message, pos)


def visit(node):
    visited = set()
    stack = [node]
    while stack:
        node = stack.pop()

        if isinstance(node, (list, tuple)):
            stack.extend(node)

        elif isinstance(node, dict):
            stack.extend(node.values())

        elif isinstance(node, Node):
            node_id = id(node)
            if node_id in visited:
                continue
            visited.add(node_id)

            yield node

            if hasattr(node, '_fields'):
                stack.extend(getattr(node, x) for x in node._fields)


_Traversing = _nt('_Traversing', 'parent, field, child, is_finished')


def traverse(node):
    visited = set()
    stack = [_Traversing(parent=None, field=None, child=node, is_finished=False)]
    while stack:
        traversing = stack.pop()

        if traversing.is_finished:
            yield traversing
            continue

        child = traversing.child
        child_id = id(child)

        if child_id in visited:
            continue

        visited.add(child_id)
        stack.append(traversing._replace(is_finished=True))
        yield traversing

        def extend(items):
            stack.extend(reversed(list(items)))

        if isinstance(child, (list, tuple)):
            extend(
                _Traversing(parent=child, field=i, child=x, is_finished=False)
                for i, x in enumerate(child)
            )

        elif isinstance(child, dict):
            extend(
                _Traversing(parent=child, field=k, child=v, is_finished=False)
                for k, v in child.items()
            )

        elif isinstance(child, Node) and hasattr(child, '_fields'):
            extend(
                _Traversing(
                    parent=child,
                    field=x,
                    child=getattr(child, x),
                    is_finished=False,
                )
                for x in child._fields
            )


def transform(node, *callbacks):
    if not callbacks:
        return node

    if len(callbacks) == 1:
        callback = callbacks[0]
    else:
        def callback(node):
            for f in callbacks:
                node = f(node)
            return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, Node):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if now is not was:
            updates[field] = now
            if isinstance(was, Node) and isinstance(now, Node) and not now._metadata:
                now._metadata.update(was._metadata)

    if updates:
        node = node._replace(**updates)

    return callback(node)


def _finalize_parse_info(text, nodes, pos, fullparse):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)

    for node in visit(nodes):
        pos_info = node._metadata.position_info
        if pos_info:
            start, end = pos_info
            end -= 1
            node._metadata.position_info = _PositionInfo(
                start=_Position(start, line_numbers[start], column_numbers[start]),
                end=_Position(end, line_numbers[end], column_numbers[end]),
            )

    if fullparse and pos < len(text):
        line, col = line_numbers[pos], column_numbers[pos]
        position = _Position(pos, line, col)
        excerpt = _extract_excerpt(text, pos, col)
        raise PartialParseError(nodes, position, excerpt)

    return nodes


def _extract_excerpt(text, pos, col):
    if isinstance(text, bytes):
        return repr(text[max(0, pos - 1) : pos + 2])

    start = pos - (col - 1)
    match = _compile_re('\n').search(text, pos + 1)
    end = len(text) if match is None else match.start()

    if end - start < 96:
        return text[start : end] + _caret_at(col - 1)

    if col < 60:
        # Chop the line off at the end.
        return text[start : start + 90] + ' ...' + _caret_at(col - 1)

    elif end - pos < 40:
        # Chop the line off at the start.
        return '... ' + text[end - 90 : end] + _caret_at(pos - (end - 90) + 4)

    else:
        # Chop the line off at both ends.
        return '... ' + text[pos - 42 : pos + 42] + ' ...' + _caret_at(42 + 4)


def _caret_at(index):
    return '\n' + (' ' * index) + '^'


def _get_line_and_column(text, pos):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)
    return line_numbers[pos], column_numbers[pos]


def _map_index_to_line_and_column(text):
    line_numbers = []
    column_numbers = []

    current_line = 1
    current_column = 0

    for c in text:
        if c == '\n':
            current_line += 1
            current_column = 0
        else:
            current_column += 1
        line_numbers.append(current_line)
        column_numbers.append(current_column)

    return line_numbers, column_numbers

matcher1 = _compile_re(b'[\\x00-\\xFF]', flags=0).match
matcher2 = _compile_re(b'[\\x00-\\xFF]{4}', flags=0).match
matcher3 = _compile_re(b'[\\x00-\\xFF]{8}', flags=0).match
matcher4 = _compile_re(b'[\\x80-\\xFF]*[\\x00-\\x7F]', flags=0).match

class Module(Node):
    """
    class Module {
        magic: b'\\x00asm'
        version: b'\\x01\\x00\\x00\\x00'
        custom1: CustomSection*
        typesec: Opt(TypeSection)
        custom2: CustomSection*
    }
    """
    _fields = ('magic', 'version', 'custom1', 'typesec', 'custom2')

    def __init__(self, magic, version, custom1, typesec, custom2):
        Node.__init__(self)
        self.magic = magic
        self.version = version
        self.custom1 = custom1
        self.typesec = typesec
        self.custom2 = custom2

    def __repr__(self):
        return f'Module(magic={self.magic!r}, version={self.version!r}, custom1={self.custom1!r}, typesec={self.typesec!r}, custom2={self.custom2!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Module, fullparse)


def _try_Module(_text, _pos):
    # Begin Seq
    start_pos1 = _pos
    while True:
        # Begin Str
        value1 = b'\x00asm'
        end1 = (_pos + 4)
        if (_text[slice(_pos, end1, None)] == value1):
            _result = value1
            _pos = end1
            _status = True
        else:
            _result = _raise_error4
            _status = False
        # End Str
        if not (_status):
            break
        magic = _result
        # Begin Str
        value2 = b'\x01\x00\x00\x00'
        end2 = (_pos + 4)
        if (_text[slice(_pos, end2, None)] == value2):
            _result = value2
            _pos = end2
            _status = True
        else:
            _result = _raise_error6
            _status = False
        # End Str
        if not (_status):
            break
        version = _result
        # Begin List
        # CustomSection*
        staging1 = []
        while True:
            checkpoint1 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint1
                break
            staging1.append(_result)
        _result = staging1
        _status = True
        # End List
        custom1 = _result
        # Begin Opt
        # Opt(TypeSection)
        backtrack1 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TypeSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack1
            _result = None
            _status = True
        # End Opt
        typesec = _result
        # Begin List
        # CustomSection*
        staging2 = []
        while True:
            checkpoint2 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint2
                break
            staging2.append(_result)
        _result = staging2
        _status = True
        # End List
        custom2 = _result
        _result = Module(magic, version, custom1, typesec, custom2)
        _result._metadata.position_info = (start_pos1, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error4(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x00asm'\n\n"
    "Expected to match the string b'\\x00asm'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error6(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x01\\x00\\x00\\x00'\n\n"
    "Expected to match the string b'\\x01\\x00\\x00\\x00'"
    )
    raise ParseError((title + details), _pos, line, col)

class CustomSection(Node):
    """
    class CustomSection {
        id: 0x0
        size: u32
        body: bytechar{size} |> `lambda x: b''.join(x)`
    }
    """
    _fields = ('id', 'size', 'body')

    def __init__(self, id, size, body):
        Node.__init__(self)
        self.id = id
        self.size = size
        self.body = body

    def __repr__(self):
        return f'CustomSection(id={self.id!r}, size={self.size!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CustomSection, fullparse)


def _try_CustomSection(_text, _pos):
    # Begin Seq
    start_pos2 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error19
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Apply
        # bytechar{size} |> `lambda x: b''.join(x)`
        # Begin List
        # bytechar{size}
        staging3 = []
        while True:
            checkpoint3 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_bytechar, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint3
                break
            staging3.append(_result)
            if (len(staging3) == size):
                break
        if (len(staging3) >= size):
            _result = staging3
            _status = True
        # End List
        if _status:
            arg1 = _result
            _result = lambda x: b''.join(x)
            _status = True
            _result = _result(arg1)
        # End Apply
        if not (_status):
            break
        body = _result
        _result = CustomSection(id, size, body)
        _result._metadata.position_info = (start_pos2, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error19(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CustomSection' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class TypeSection(Node):
    """
    class TypeSection {
        id: 0x1
        size: u32
        func_types: vec(FuncType)
    }
    """
    _fields = ('id', 'size', 'func_types')

    def __init__(self, id, size, func_types):
        Node.__init__(self)
        self.id = id
        self.size = size
        self.func_types = func_types

    def __repr__(self):
        return f'TypeSection(id={self.id!r}, size={self.size!r}, func_types={self.func_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TypeSection, fullparse)


def _try_TypeSection(_text, _pos):
    # Begin Seq
    start_pos3 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error30
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(FuncType)
        func1 = _ParseFunction(_try_vec, (_try_FuncType,), ())
        (_status, _result, _pos) = (yield (3, func1, _pos))
        # End Call
        if not (_status):
            break
        func_types = _result
        _result = TypeSection(id, size, func_types)
        _result._metadata.position_info = (start_pos3, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error30(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TypeSection' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class FuncType(Node):
    """
    class FuncType {
        params: 0x60 >> vec(ValueType)
        results: vec(ValueType)
    }
    """
    _fields = ('params', 'results')

    def __init__(self, params, results):
        Node.__init__(self)
        self.params = params
        self.results = results

    def __repr__(self):
        return f'FuncType(params={self.params!r}, results={self.results!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_FuncType, fullparse)


def _try_FuncType(_text, _pos):
    # Begin Seq
    start_pos4 = _pos
    while True:
        # Begin Discard
        # 0x60 >> vec(ValueType)
        while True:
            # Begin Byte
            # 0x60
            if (_pos < len(_text)) and (_text[_pos] == 96):
                _result = 96
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error41
                _status = False
            # End Byte
            if not (_status):
                break
            # Begin Call
            # vec(ValueType)
            func2 = _ParseFunction(_try_vec, (_try_ValueType,), ())
            (_status, _result, _pos) = (yield (3, func2, _pos))
            # End Call
            break
        # End Discard
        if not (_status):
            break
        params = _result
        # Begin Call
        # vec(ValueType)
        func3 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func3, _pos))
        # End Call
        if not (_status):
            break
        results = _result
        _result = FuncType(params, results)
        _result._metadata.position_info = (start_pos4, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error41(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FuncType' rule, at the expression:\n"
    '    0x60\n\n'
    'Expected to match the byte value 0x60'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ValueType(_text, _pos):
    # Rule 'ValueType'
    # Begin Choice
    farthest_err1 = _raise_error50
    backtrack2 = farthest_pos1 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_NumberType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = farthest_pos1
        _result = farthest_err1
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ValueType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ValueType, fullparse)

ValueType = Rule('ValueType', _parse_ValueType, """
    ValueType = NumberType | ReferenceType
""")
def _raise_error50(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueType' rule, at the expression:\n"
    '    NumberType | ReferenceType\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_NumberType(_text, _pos):
    # Rule 'NumberType'
    # Begin Choice
    farthest_err2 = _raise_error54
    backtrack3 = farthest_pos2 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x7f >> `'i32'`
        while True:
            # Begin Byte
            # 0x7f
            if (_pos < len(_text)) and (_text[_pos] == 127):
                _result = 127
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error56
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack3
        # Option 2:
        # Begin Discard
        # 0x7e >> `'i64'`
        while True:
            # Begin Byte
            # 0x7e
            if (_pos < len(_text)) and (_text[_pos] == 126):
                _result = 126
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error59
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack3
        # Option 3:
        # Begin Discard
        # 0x7d >> `'f32'`
        while True:
            # Begin Byte
            # 0x7d
            if (_pos < len(_text)) and (_text[_pos] == 125):
                _result = 125
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error62
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack3
        # Option 4:
        # Begin Discard
        # 0x7c >> `'f64'`
        while True:
            # Begin Byte
            # 0x7c
            if (_pos < len(_text)) and (_text[_pos] == 124):
                _result = 124
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error65
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = farthest_pos2
        _result = farthest_err2
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_NumberType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_NumberType, fullparse)

NumberType = Rule('NumberType', _parse_NumberType, """
    NumberType = 0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`
""")
def _raise_error54(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    "    0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error56(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7f\n\n'
    'Expected to match the byte value 0x7f'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error59(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7e\n\n'
    'Expected to match the byte value 0x7e'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error62(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7d\n\n'
    'Expected to match the byte value 0x7d'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error65(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7c\n\n'
    'Expected to match the byte value 0x7c'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ReferenceType(_text, _pos):
    # Rule 'ReferenceType'
    # Begin Choice
    farthest_err3 = _raise_error68
    backtrack4 = farthest_pos3 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x70 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x70
            if (_pos < len(_text)) and (_text[_pos] == 112):
                _result = 112
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error70
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack4
        # Option 2:
        # Begin Discard
        # 0x6f >> `'externref'`
        while True:
            # Begin Byte
            # 0x6f
            if (_pos < len(_text)) and (_text[_pos] == 111):
                _result = 111
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error73
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'externref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = farthest_pos3
        _result = farthest_err3
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ReferenceType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ReferenceType, fullparse)

ReferenceType = Rule('ReferenceType', _parse_ReferenceType, """
    ReferenceType = 0x70 >> `'funcref'` | 0x6f >> `'externref'`
""")
def _raise_error68(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    "    0x70 >> `'funcref'` | 0x6f >> `'externref'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error70(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x70\n\n'
    'Expected to match the byte value 0x70'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error73(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x6f\n\n'
    'Expected to match the byte value 0x6f'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_vec(_text, _pos, element):
    # Rule 'vec'
    # Begin Let
    # let length = u32 in
    # element{length}
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    if _status:
        length = _result
        # Begin List
        # element{length}
        staging4 = []
        while True:
            checkpoint4 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, element, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint4
                break
            staging4.append(_result)
            if (len(staging4) == length):
                break
        if (len(staging4) >= length):
            _result = staging4
            _status = True
        # End List
    # End Let
    yield (_status, _result, _pos)

def _parse_vec(text, pos=0, fullparse=True):
    return _run(text, pos, _try_vec, fullparse)

vec = Rule('vec', _parse_vec, """
    vec(element) = let length = u32 in
    element{length}
""")
def _try_name(_text, _pos):
    # Rule 'name'
    # Begin Apply
    # vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
    # Begin Call
    # vec(bytechar)
    func4 = _ParseFunction(_try_vec, (_try_bytechar,), ())
    (_status, _result, _pos) = (yield (3, func4, _pos))
    # End Call
    if _status:
        arg2 = _result
        _result = lambda x: b''.join(x).decode('utf8')
        _status = True
        _result = _result(arg2)
    # End Apply
    yield (_status, _result, _pos)

def _parse_name(text, pos=0, fullparse=True):
    return _run(text, pos, _try_name, fullparse)

name = Rule('name', _parse_name, """
    name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
""")
def _try_bytechar(_text, _pos):
    # Rule 'bytechar'
    # Begin Regex
    # /[\\x00-\\xFF]/
    match1 = matcher1(_text, _pos)
    if match1:
        _result = match1.group(0)
        _pos = match1.end()
        _status = True
    else:
        _result = _raise_error87
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_bytechar(text, pos=0, fullparse=True):
    return _run(text, pos, _try_bytechar, fullparse)

bytechar = Rule('bytechar', _parse_bytechar, """
    bytechar = /[\\x00-\\xFF]/
""")
def _raise_error87(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'bytechar' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_byte(_text, _pos):
    # Rule 'byte'
    # Begin Apply
    # /[\\x00-\\xFF]/ |> `ord`
    # Begin Regex
    # /[\\x00-\\xFF]/
    match2 = matcher1(_text, _pos)
    if match2:
        _result = match2.group(0)
        _pos = match2.end()
        _status = True
    else:
        _result = _raise_error90
        _status = False
    # End Regex
    if _status:
        arg3 = _result
        _result = ord
        _status = True
        _result = _result(arg3)
    # End Apply
    yield (_status, _result, _pos)

def _parse_byte(text, pos=0, fullparse=True):
    return _run(text, pos, _try_byte, fullparse)

byte = Rule('byte', _parse_byte, """
    byte = /[\\x00-\\xFF]/ |> `ord`
""")
def _raise_error90(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'byte' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_u32(_text, _pos):
    # Rule 'u32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_UnsignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_u32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_u32, fullparse)

u32 = Rule('u32', _parse_u32, """
    u32 = UnsignedInt
""")
def _try_i32(_text, _pos):
    # Rule 'i32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i32, fullparse)

i32 = Rule('i32', _parse_i32, """
    i32 = SignedInt
""")
def _try_i64(_text, _pos):
    # Rule 'i64'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i64, fullparse)

i64 = Rule('i64', _parse_i64, """
    i64 = SignedInt
""")
def _try_f32(_text, _pos):
    # Rule 'f32'
    # Begin Apply
    # /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{4}/
    match3 = matcher2(_text, _pos)
    if match3:
        _result = match3.group(0)
        _pos = match3.end()
        _status = True
    else:
        _result = _raise_error100
        _status = False
    # End Regex
    if _status:
        arg4 = _result
        _result = lambda x: struct.unpack('<f', x)[0]
        _status = True
        _result = _result(arg4)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f32, fullparse)

f32 = Rule('f32', _parse_f32, """
    f32 = /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
""")
def _raise_error100(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{4}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{4}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_f64(_text, _pos):
    # Rule 'f64'
    # Begin Apply
    # /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{8}/
    match4 = matcher3(_text, _pos)
    if match4:
        _result = match4.group(0)
        _pos = match4.end()
        _status = True
    else:
        _result = _raise_error104
        _status = False
    # End Regex
    if _status:
        arg5 = _result
        _result = lambda x: struct.unpack('<d', x)[0]
        _status = True
        _result = _result(arg5)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f64, fullparse)

f64 = Rule('f64', _parse_f64, """
    f64 = /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
""")
def _raise_error104(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{8}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{8}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_SignedInt(_text, _pos):
    # Rule 'SignedInt'
    # Begin Apply
    # LEB128 |> `decode_signed_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg6 = _result
        _result = decode_signed_int
        _status = True
        _result = _result(arg6)
    # End Apply
    yield (_status, _result, _pos)

def _parse_SignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_SignedInt, fullparse)

SignedInt = Rule('SignedInt', _parse_SignedInt, """
    SignedInt = LEB128 |> `decode_signed_int`
""")
def _try_UnsignedInt(_text, _pos):
    # Rule 'UnsignedInt'
    # Begin Apply
    # LEB128 |> `decode_unsigned_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg7 = _result
        _result = decode_unsigned_int
        _status = True
        _result = _result(arg7)
    # End Apply
    yield (_status, _result, _pos)

def _parse_UnsignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_UnsignedInt, fullparse)

UnsignedInt = Rule('UnsignedInt', _parse_UnsignedInt, """
    UnsignedInt = LEB128 |> `decode_unsigned_int`
""")
def _try_LEB128(_text, _pos):
    # Rule 'LEB128'
    # Begin Regex
    # /[\\x80-\\xFF]*[\\x00-\\x7F]/
    match5 = matcher4(_text, _pos)
    if match5:
        _result = match5.group(0)
        _pos = match5.end()
        _status = True
    else:
        _result = _raise_error115
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LEB128(text, pos=0, fullparse=True):
    return _run(text, pos, _try_LEB128, fullparse)

LEB128 = Rule('LEB128', _parse_LEB128, """
    LEB128 = /[\\x80-\\xFF]*[\\x00-\\x7F]/
""")
def _raise_error115(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LEB128' rule, at the expression:\n"
    '    /[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]/\n\n'
    "Expected to match the regular expression /b'[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]'/"
    )
    raise ParseError((title + details), _pos, line, col)

