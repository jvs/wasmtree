# Generated by ../generate_parser.py
"""
# Grammar definition:
```
import struct
```

class Module {
    let magic: b'\\x00\\x61\\x73\\x6D'
    let version: b'\\x01\\x00\\x00\\x00'

    custom1: CustomSection*

    type_section: TypeSection?
    custom2: CustomSection*

    import_section: ImportSection?
    custom3: CustomSection*

    function_section: FunctionSection?
    custom4: CustomSection*

    table_section: TableSection?
    custom5: CustomSection*

    memory_section: MemorySection?
    custom6: CustomSection*

    global_section: GlobalSection?
    custom7: CustomSection*

    export_section: ExportSection?
    custom8: CustomSection*

    start_section: StartSection?
    custom9: CustomSection*

    element_section: ElementSection?
    custom10: CustomSection*

    data_count_section: DataCountSection?
    custom11: CustomSection*

    code_section: CodeSection?
    custom12: CustomSection*

    data_section: DataSection?
    custom13: CustomSection*
}


# Sections.
class CustomSection {
    let id: 0x00
    let size: u32
    let loc: LocatedName
    let remaining = `size - (loc.end - loc.start)`

    name: `loc.name`
    body: ByteString(remaining)
}

class TypeSection {
    let id: 0x01
    let size: u32
    function_types: vec(FunctionType)
}

class ImportSection {
    let id: 0x02
    let size: u32
    imports: vec(Import)
}

class FunctionSection {
    let id: 0x03
    let size: u32
    type_indexes: vec(TypeIndex)
}

class TableSection {
    let id: 0x04
    let size: u32
    table_types: vec(TableType)
}

class MemorySection {
    let id: 0x05
    let size: u32
    memory_types: vec(MemoryType)
}

class GlobalSection {
    let id: 0x06
    let size: u32
    globals: vec(Global)
}

class ExportSection {
    let id: 0x07
    let size: u32
    exports: vec(Export)
}

class StartSection {
    let id: 0x08
    let size: u32
    index: FunctionIndex
}

class ElementSection {
    let id: 0x09
    let size: u32
    segments: vec(ElementSegment)
}

class DataCountSection {
    let id: 0x0C
    let size: u32
    count: Opt(u32 where `lambda _: size > 0`)
}

class CodeSection {
    let id: 0x0A
    let size: u32
    entries: vec(CodeEntry)
}

class DataSection {
    let id: 0x0B
    let size: u32
    segments: vec(ActiveDataSegment | PassiveDataSegment | ActiveIndexDataSegment)
}


# Globals.
class Global {
    type: GlobalType
    initializer: Expression
}


# Imports.
class Import {
    module: Name
    name: Name
    descriptor: ImportFunc | ImportTable | ImportMemory | ImportGlobal
}

class ImportFunc { let id: 0x00; type: TypeIndex }
class ImportTable { let id: 0x01; type: TableType }
class ImportMemory { let id: 0x02; type: MemoryType }
class ImportGlobal { let id: 0x03; type: GlobalType }


# Exports.
class Export {
    name: Name
    descriptor: ExportFunc | ExportTable | ExportMemory | ExportGlobal
}

class ExportFunc { let id: 0x00; index: FunctionIndex }
class ExportTable { let id: 0x01; index: TableIndex }
class ExportMemory { let id: 0x02; index: MemoryIndex }
class ExportGlobal { let id: 0x03; index: GlobalIndex }


# Element segments.
ElementSegment = (
    DefaultSegment
    | PassiveFuncRefSegment
    | ActiveFuncRefSegment
    | DeclarativeFuncRefSegment
    | DefaultExpressionSegment
    | PassiveExpressionSegment
    | ActiveExpressionSegment
    | DeclarativeExpressionSegment
)

class DefaultSegment {
    let id: 0x00
    offset: Expression
    function_indexes: vec(FunctionIndex)
}

class PassiveFuncRefSegment {
    let id: 0x01
    type: 0x00 >> `'funcref'`
    function_indexes: vec(FunctionIndex)
}

class ActiveFuncRefSegment {
    let id: 0x02
    table_index: TableIndex
    offset: Expression
    type: 0x00 >> `'funcref'`
    function_indexes: vec(FunctionIndex)
}

class DeclarativeFuncRefSegment {
    let id: 0x03
    type: 0x00 >> `'funcref'`
    function_indexes: vec(FunctionIndex)
}

class DefaultExpressionSegment {
    let id: 0x04
    offset: Expression
    initializers: vec(Expression)
}

class PassiveExpressionSegment {
    let id: 0x05
    type: ReferenceType
    initializers: vec(Expression)
}

class ActiveExpressionSegment {
    let id: 0x06
    table_index: TableIndex
    offset: Expression
    type: ReferenceType
    initializers: vec(Expression)
}

class DeclarativeExpressionSegment {
    let id: 0x07
    type: ReferenceType
    initializers: vec(Expression)
}


# Data segments.
class ActiveDataSegment {
    let id: 0x00
    offset: Expression
    contents: ByteVector
}

class PassiveDataSegment {
    let id: 0x01
    contents: ByteVector
}

class ActiveIndexDataSegment {
    let id: 0x02
    index: MemoryIndex
    offset: Expression
    contents: ByteVector
}


# Limits.
Limits = MinLimit | MinMaxLimits

class MinLimit {
    let id: 0x00
    min: u32
}

class MinMaxLimits {
    let id: 0x01
    min: u32
    max: u32
}


# Types.
DataIndex = u32
FunctionIndex = u32
ElementIndex = u32
GlobalIndex = u32
LabelIndex = u32
LocalIndex = u32
MemoryIndex = u32
TableIndex = u32
TypeIndex = u32

BlockType = 0x40 >> `'empty'` | ValueType | SignedInt

class FunctionType {
    let id: 0x60
    parameter_types: vec(ValueType)
    result_types: vec(ValueType)
}

class GlobalType {
    type: ValueType
    modifier: 0x00 >> `'const'` | 0x01 >> `'var'`
}

class MemoryType {
    limits: Limits
}

NumberType = (
    0x7F >> `'i32'`
    | 0x7E >> `'i64'`
    | 0x7D >> `'f32'`
    | 0x7C >> `'f64'`
)

class TableType {
    type: ReferenceType
    limits: Limits
}

ReferenceType = 0x70 >> `'funcref'` | 0x6F >> `'externref'`
ValueType = NumberType | ReferenceType


# Vectors.
vec(element) =>
    let length = u32 in
    element{length}


# Uninterpreted bytes.
ByteString(size) => bytechar{size} |> `lambda x: b''.join(x)`
ByteVector => vec(bytechar) |> `lambda x: b''.join(x)`
bytechar = b/[\\x00-\\xFF]/


# Names.
Name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`


class LocatedName {
    start: `_pos`
    name: Name
    end: `_pos`
}


# Numbers.
byte = b/[\\x00-\\xFF]/ |> `ord`
u32 = UnsignedInt
i32 = SignedInt
i64 = SignedInt
f32 = b/[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
f64 = b/[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`

SignedInt = LEB128 |> `decode_signed_int`
UnsignedInt = LEB128 |> `decode_unsigned_int`
LEB128 = b/[\\x80-\\xFF]*[\\x00-\\x7F]/

```
continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result
```


# Code.
class CodeEntry {
    let size: u32
    locals: vec(Locals)
    expression: Expression
}

class Locals {
    count: u32
    type: ValueType
}


# Instructions.
Expression => Instruction* << 0x0B

Instruction = (
    unreachable
    | nop
    | Block
    | Loop
    | If
    | br
    | br_if
    | br_table
    | ret
    | call
    | call_indirect
    | ref_null
    | ref_is_null
    | ref_func
    | drop
    | select
    | select_t
    | local_get
    | local_set
    | local_tee
    | global_get
    | global_set
    | table_get
    | table_set
    | i32_load
    | i64_load
    | f32_load
    | f64_load
    | i32_load8_s
    | i32_load8_u
    | i32_load16_s
    | i32_load16_u
    | i64_load8_s
    | i64_load8_u
    | i64_load16_s
    | i64_load16_u
    | i64_load32_s
    | i64_load32_u
    | i32_store
    | i64_store
    | f32_store
    | f64_store
    | i32_store8
    | i32_store16
    | i64_store8
    | i64_store16
    | i64_store32
    | memory_size
    | memory_grow
    | i32_const
    | i64_const
    | f32_const
    | f64_const
    | i32_eqz
    | i32_eq
    | i32_ne
    | i32_lt_s
    | i32_lt_u
    | i32_gt_s
    | i32_gt_u
    | i32_le_s
    | i32_le_u
    | i32_ge_s
    | i32_ge_u
    | i64_eqz
    | i64_eq
    | i64_ne
    | i64_lt_s
    | i64_lt_u
    | i64_gt_s
    | i64_gt_u
    | i64_le_s
    | i64_le_u
    | i64_ge_s
    | i64_ge_u
    | f32_eq
    | f32_ne
    | f32_lt
    | f32_gt
    | f32_le
    | f32_ge
    | f64_eq
    | f64_ne
    | f64_lt
    | f64_gt
    | f64_le
    | f64_ge
    | i32_clz
    | i32_ctz
    | i32_popcnt
    | i32_add
    | i32_sub
    | i32_mul
    | i32_div_s
    | i32_div_u
    | i32_rem_s
    | i32_rem_u
    | i32_and
    | i32_or
    | i32_xor
    | i32_shl
    | i32_shr_s
    | i32_shr_u
    | i32_rotl
    | i32_rotr
    | i64_clz
    | i64_ctz
    | i64_popcnt
    | i64_add
    | i64_sub
    | i64_mul
    | i64_div_s
    | i64_div_u
    | i64_rem_s
    | i64_rem_u
    | i64_and
    | i64_or
    | i64_xor
    | i64_shl
    | i64_shr_s
    | i64_shr_u
    | i64_rotl
    | i64_rotr
    | f32_abs
    | f32_neg
    | f32_ceil
    | f32_floor
    | f32_trunc
    | f32_nearest
    | f32_sqrt
    | f32_add
    | f32_sub
    | f32_mul
    | f32_div
    | f32_min
    | f32_max
    | f32_copysign
    | f64_abs
    | f64_neg
    | f64_ceil
    | f64_floor
    | f64_trunc
    | f64_nearest
    | f64_sqrt
    | f64_add
    | f64_sub
    | f64_mul
    | f64_div
    | f64_min
    | f64_max
    | f64_copysign
    | i32_wrap_i64
    | i32_trunc_f32_s
    | i32_trunc_f32_u
    | i32_trunc_f64_s
    | i32_trunc_f64_u
    | i64_extend_i32_s
    | i64_extend_i32_u
    | i64_trunc_f32_s
    | i64_trunc_f32_u
    | i64_trunc_f64_s
    | i64_trunc_f64_u
    | f32_convert_i32_s
    | f32_convert_i32_u
    | f32_convert_i64_s
    | f32_convert_i64_u
    | f32_demote_f64
    | f64_convert_i32_s
    | f64_convert_i32_u
    | f64_convert_i64_s
    | f64_convert_i64_u
    | f64_promote_f32
    | i32_reinterpret_f32
    | i64_reinterpret_f64
    | f32_reinterpret_i32
    | f64_reinterpret_i64
    | i32_extend8_s
    | i32_extend16_s
    | i64_extend8_s
    | i64_extend16_s
    | i64_extend32_s
    | i32_trunc_sat_f32_s
    | i32_trunc_sat_f32_u
    | i32_trunc_sat_f64_s
    | i32_trunc_sat_f64_u
    | i64_trunc_sat_f32_s
    | i64_trunc_sat_f32_u
    | i64_trunc_sat_f64_s
    | i64_trunc_sat_f64_u
    | memory_init
    | data_drop
    | memory_copy
    | memory_fill
    | table_init
    | elem_drop
    | table_copy
    | table_grow
    | table_size
    | table_fill
)

class unreachable { let id: 0x00 }
class nop { let id: 0x01 }

class Block {
    let id: 0x02
    type: BlockType
    body: Expression
}

class Loop {
    let id: 0x03
    type: BlockType
    body: Expression
}

class If {
    let id: 0x04
    type: BlockType
    true_case: Instruction* << Expect(0x05 | 0x0B)
    false_case: Opt(0x05 >> Instruction*) << 0x0B
}

class br {
    let id: 0x0C
    label: LabelIndex
}

class br_if {
    let id: 0x0D
    label: LabelIndex
}

class br_table {
    let id: 0x0E
    labels: vec(LabelIndex)
    default: LabelIndex
}

class ret {
    let id: 0x0F
}

class call {
    let id: 0x10
    function: FunctionIndex
}

class call_indirect {
    let id: 0x11
    type_index: TypeIndex
    table_index: TableIndex
}

class ref_null { let id: 0xD0; type: ReferenceType }
class ref_is_null { let id: 0xD1 }
class ref_func { let id: 0xD2; function: FunctionIndex }

class drop { let id: 0x1A }
class select { let id: 0x1B }
class select_t { let id: 0x1C; types: vec(ValueType) }

class local_get { let id: 0x20; index: LocalIndex }
class local_set { let id: 0x21; index: LocalIndex }
class local_tee { let id: 0x22; index: LocalIndex }
class global_get { let id: 0x23; index: GlobalIndex }
class global_set { let id: 0x24; index: GlobalIndex }

class table_get { let id: 0x25; index: TableIndex }
class table_set { let id: 0x26; index: TableIndex }

class i32_load { let id: 0x28; align: u32; offset: u32 }
class i64_load { let id: 0x29; align: u32; offset: u32 }
class f32_load { let id: 0x2A; align: u32; offset: u32 }
class f64_load { let id: 0x2B; align: u32; offset: u32 }
class i32_load8_s { let id: 0x2C; align: u32; offset: u32 }
class i32_load8_u { let id: 0x2D; align: u32; offset: u32 }
class i32_load16_s { let id: 0x2E; align: u32; offset: u32 }
class i32_load16_u { let id: 0x2F; align: u32; offset: u32 }
class i64_load8_s { let id: 0x30; align: u32; offset: u32 }
class i64_load8_u { let id: 0x31; align: u32; offset: u32 }
class i64_load16_s { let id: 0x32; align: u32; offset: u32 }
class i64_load16_u { let id: 0x33; align: u32; offset: u32 }
class i64_load32_s { let id: 0x34; align: u32; offset: u32 }
class i64_load32_u { let id: 0x35; align: u32; offset: u32 }
class i32_store { let id: 0x36; align: u32; offset: u32 }
class i64_store { let id: 0x37; align: u32; offset: u32 }
class f32_store { let id: 0x38; align: u32; offset: u32 }
class f64_store { let id: 0x39; align: u32; offset: u32 }
class i32_store8 { let id: 0x3A; align: u32; offset: u32 }
class i32_store16 { let id: 0x3B; align: u32; offset: u32 }
class i64_store8 { let id: 0x3C; align: u32; offset: u32 }
class i64_store16 { let id: 0x3D; align: u32; offset: u32 }
class i64_store32 { let id: 0x3E; align: u32; offset: u32 }

class memory_size { let id: 0x3F; let zero: 0x00 }
class memory_grow { let id: 0x40; let zero: 0x00 }

class i32_const { let id: 0x41; number: i32 }
class i64_const { let id: 0x42; number: i64 }
class f32_const { let id: 0x43; number: f32 }
class f64_const { let id: 0x44; number: f64 }

class i32_eqz { let id: 0x45 }
class i32_eq { let id: 0x46 }
class i32_ne { let id: 0x47 }
class i32_lt_s { let id: 0x48 }
class i32_lt_u { let id: 0x49 }
class i32_gt_s { let id: 0x4A }
class i32_gt_u { let id: 0x4B }
class i32_le_s { let id: 0x4C }
class i32_le_u { let id: 0x4D }
class i32_ge_s { let id: 0x4E }
class i32_ge_u { let id: 0x4F }

class i64_eqz { let id: 0x50 }
class i64_eq { let id: 0x51 }
class i64_ne { let id: 0x52 }
class i64_lt_s { let id: 0x53 }
class i64_lt_u { let id: 0x54 }
class i64_gt_s { let id: 0x55 }
class i64_gt_u { let id: 0x56 }
class i64_le_s { let id: 0x57 }
class i64_le_u { let id: 0x58 }
class i64_ge_s { let id: 0x59 }
class i64_ge_u { let id: 0x5A }

class f32_eq { let id: 0x5B }
class f32_ne { let id: 0x5C }
class f32_lt { let id: 0x5D }
class f32_gt { let id: 0x5E }
class f32_le { let id: 0x5F }
class f32_ge { let id: 0x60 }

class f64_eq { let id: 0x61 }
class f64_ne { let id: 0x62 }
class f64_lt { let id: 0x63 }
class f64_gt { let id: 0x64 }
class f64_le { let id: 0x65 }
class f64_ge { let id: 0x66 }

class i32_clz { let id: 0x67 }
class i32_ctz { let id: 0x68 }
class i32_popcnt { let id: 0x69 }
class i32_add { let id: 0x6A }
class i32_sub { let id: 0x6B }
class i32_mul { let id: 0x6C }
class i32_div_s { let id: 0x6D }
class i32_div_u { let id: 0x6E }
class i32_rem_s { let id: 0x6F }
class i32_rem_u { let id: 0x70 }
class i32_and { let id: 0x71 }
class i32_or { let id: 0x72 }
class i32_xor { let id: 0x73 }
class i32_shl { let id: 0x74 }
class i32_shr_s { let id: 0x75 }
class i32_shr_u { let id: 0x76 }
class i32_rotl { let id: 0x77 }
class i32_rotr { let id: 0x78 }

class i64_clz { let id: 0x79 }
class i64_ctz { let id: 0x7A }
class i64_popcnt { let id: 0x7B }
class i64_add { let id: 0x7C }
class i64_sub { let id: 0x7D }
class i64_mul { let id: 0x7E }
class i64_div_s { let id: 0x7F }
class i64_div_u { let id: 0x80 }
class i64_rem_s { let id: 0x81 }
class i64_rem_u { let id: 0x82 }
class i64_and { let id: 0x83 }
class i64_or { let id: 0x84 }
class i64_xor { let id: 0x85 }
class i64_shl { let id: 0x86 }
class i64_shr_s { let id: 0x87 }
class i64_shr_u { let id: 0x88 }
class i64_rotl { let id: 0x89 }
class i64_rotr { let id: 0x8A }

class f32_abs { let id: 0x8B }
class f32_neg { let id: 0x8C }
class f32_ceil { let id: 0x8D }
class f32_floor { let id: 0x8E }
class f32_trunc { let id: 0x8F }
class f32_nearest { let id: 0x90 }
class f32_sqrt { let id: 0x91 }
class f32_add { let id: 0x92 }
class f32_sub { let id: 0x93 }
class f32_mul { let id: 0x94 }
class f32_div { let id: 0x95 }
class f32_min { let id: 0x96 }
class f32_max { let id: 0x97 }
class f32_copysign { let id: 0x98 }

class f64_abs { let id: 0x99 }
class f64_neg { let id: 0x9A }
class f64_ceil { let id: 0x9B }
class f64_floor { let id: 0x9C }
class f64_trunc { let id: 0x9D }
class f64_nearest { let id: 0x9E }
class f64_sqrt { let id: 0x9F }
class f64_add { let id: 0xA0 }
class f64_sub { let id: 0xA1 }
class f64_mul { let id: 0xA2 }
class f64_div { let id: 0xA3 }
class f64_min { let id: 0xA4 }
class f64_max { let id: 0xA5 }
class f64_copysign { let id: 0xA6 }

class i32_wrap_i64 { let id: 0xA7 }
class i32_trunc_f32_s { let id: 0xA8 }
class i32_trunc_f32_u { let id: 0xA9 }
class i32_trunc_f64_s { let id: 0xAA }
class i32_trunc_f64_u { let id: 0xAB }
class i64_extend_i32_s { let id: 0xAC }
class i64_extend_i32_u { let id: 0xAD }
class i64_trunc_f32_s { let id: 0xAE }
class i64_trunc_f32_u { let id: 0xAF }
class i64_trunc_f64_s { let id: 0xB0 }
class i64_trunc_f64_u { let id: 0xB1 }
class f32_convert_i32_s { let id: 0xB2 }
class f32_convert_i32_u { let id: 0xB3 }
class f32_convert_i64_s { let id: 0xB4 }
class f32_convert_i64_u { let id: 0xB5 }
class f32_demote_f64 { let id: 0xB6 }
class f64_convert_i32_s { let id: 0xB7 }
class f64_convert_i32_u { let id: 0xB8 }
class f64_convert_i64_s { let id: 0xB9 }
class f64_convert_i64_u { let id: 0xBA }
class f64_promote_f32 { let id: 0xBB }
class i32_reinterpret_f32 { let id: 0xBC }
class i64_reinterpret_f64 { let id: 0xBD }
class f32_reinterpret_i32 { let id: 0xBE }
class f64_reinterpret_i64 { let id: 0xBF }

class i32_extend8_s { let id: 0xC0 }
class i32_extend16_s { let id: 0xC1 }
class i64_extend8_s { let id: 0xC2 }
class i64_extend16_s { let id: 0xC3 }
class i64_extend32_s { let id: 0xC4 }

class i32_trunc_sat_f32_s { let id: 0xFC; let code: 0x00 }
class i32_trunc_sat_f32_u { let id: 0xFC; let code: 0x01 }
class i32_trunc_sat_f64_s { let id: 0xFC; let code: 0x02 }
class i32_trunc_sat_f64_u { let id: 0xFC; let code: 0x03 }
class i64_trunc_sat_f32_s { let id: 0xFC; let code: 0x04 }
class i64_trunc_sat_f32_u { let id: 0xFC; let code: 0x05 }
class i64_trunc_sat_f64_s { let id: 0xFC; let code: 0x06 }
class i64_trunc_sat_f64_u { let id: 0xFC; let code: 0x07 }

class memory_init {
    let id: 0xFC
    let code: 0x08
    data_index: DataIndex
    let zero: 0x00
}

class data_drop {
    let id: 0xFC
    let code: 0x09
    data_index: DataIndex
}

class memory_copy {
    let id: 0xFC
    let code: 0x0A
    let zeros: b'\\x00\\x00'
}

class memory_fill {
    let id: 0xFC
    let code: 0x0B
    let zero: 0x00
}

class table_init {
    let id: 0xFC
    let code: 0x0C
    element: ElementIndex
    table: TableIndex
}

class elem_drop {
    let id: 0xFC
    let code: 0x0D
    element: ElementIndex
}

class table_copy {
    let id: 0xFC
    let code: 0x0E
    destination: TableIndex
    source: TableIndex
}

class table_grow { let id: 0xFC; let code: 0x0F; table: TableIndex }
class table_size { let id: 0xFC; let code: 0x10; table: TableIndex }
class table_fill { let id: 0xFC; let code: 0x11; table: TableIndex }

"""

from collections import namedtuple as _nt
from re import compile as _compile_re, IGNORECASE as _IGNORECASE

class Node:
    _fields = ()

    def __init__(self):
        self._metadata = _Metadata()

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            if getattr(self, field) != getattr(other, field):
                return False
        return True

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        result = self.__class__(**kw)
        result._metadata.update(self._metadata)
        return result


class _Metadata:
    def __init__(self, **fields):
        object.__setattr__(self, '_fields', fields)

    def __getattr__(self, name):
        return self._fields.get(name)

    def __setattr__(self, name, value):
        self._fields[name] = value

    def __len__(self):
        return len(self._fields)

    def copy(self):
        return _Metadata(**self._fields)

    def update(self, other):
        self._fields.update(other._fields)


class Rule:
    def __init__(self, name, parse, definition):
        self.name = name
        self.parse = parse
        self.definition = definition

    def __repr__(self):
        return (f'Rule(name={self.name!r}, parse={self.parse.__name__},'
            f' definition={self.definition!r})')


import struct


continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result


class SourcerError(Exception):
    """Common superclass for ParseError and PartialParseError."""


class ParseError(SourcerError):
    def __init__(self, message, index, line, column):
        super().__init__(message)
        self.position = _Position(index, line, column)


class PartialParseError(SourcerError):
    def __init__(self, partial_result, last_position, excerpt):
        super().__init__('Incomplete parse. Unexpected input on line'
            f' {last_position.line}, column {last_position.column}:\n{excerpt}')
        self.partial_result = partial_result
        self.last_position = last_position


class Infix(Node):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        Node.__init__(self)
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(Node):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        Node.__init__(self)
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(Node):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        Node.__init__(self)
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Module, fullparse)


_PositionInfo = _nt('_PositionInfo', 'start, end')

_Position = _nt('_Position', 'index, line, column')


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _text, _pos):
        return self.func(_text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


class _ByteLiteral(int):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_byte_literal(byte_value, parse_function):
    result = _ByteLiteral(byte_value)
    result._parse_function = parse_function
    return result


def _run(text, pos, start, fullparse):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return _finalize_parse_info(text, result[1], result[2], fullparse)
    else:
        pos = result[2]
        message = result[1](text, pos)
        raise ParseError(message, pos)


def visit(node):
    visited = set()
    stack = [node]
    while stack:
        node = stack.pop()

        if isinstance(node, (list, tuple)):
            stack.extend(reversed(node))

        elif isinstance(node, dict):
            stack.extend(reversed(node.values()))

        elif isinstance(node, Node):
            node_id = id(node)
            if node_id in visited:
                continue
            visited.add(node_id)

            yield node

            if hasattr(node, '_fields'):
                stack.extend(getattr(node, x) for x in reversed(node._fields))


_Traversing = _nt('_Traversing', 'parent, field, child, is_finished')


def traverse(node):
    visited = set()
    stack = [_Traversing(parent=None, field=None, child=node, is_finished=False)]
    while stack:
        traversing = stack.pop()

        if traversing.is_finished:
            yield traversing
            continue

        child = traversing.child
        child_id = id(child)

        if child_id in visited:
            continue

        visited.add(child_id)
        stack.append(traversing._replace(is_finished=True))
        yield traversing

        def extend(items):
            stack.extend(reversed(list(items)))

        if isinstance(child, (list, tuple)):
            extend(
                _Traversing(parent=child, field=i, child=x, is_finished=False)
                for i, x in enumerate(child)
            )

        elif isinstance(child, dict):
            extend(
                _Traversing(parent=child, field=k, child=v, is_finished=False)
                for k, v in child.items()
            )

        elif isinstance(child, Node) and hasattr(child, '_fields'):
            extend(
                _Traversing(
                    parent=child,
                    field=x,
                    child=getattr(child, x),
                    is_finished=False,
                )
                for x in child._fields
            )


def transform(node, *callbacks):
    if not callbacks:
        return node

    def callback(node):
        for f in callbacks:
            prev = node
            node = f(prev)

            if node is not prev:
                if (
                    isinstance(prev, Node)
                    and isinstance(node, Node)
                    and not node._metadata
                ):
                    node._metadata.update(prev._metadata)

        return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, Node):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if now is not was:
            updates[field] = now

    if updates:
        node = node._replace(**updates)

    return callback(node)


def _finalize_parse_info(text, nodes, pos, fullparse):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)

    for node in visit(nodes):
        pos_info = node._metadata.position_info
        if pos_info:
            start, end = pos_info
            end -= 1
            node._metadata.position_info = _PositionInfo(
                start=_Position(start, line_numbers[start], column_numbers[start]),
                end=_Position(end, line_numbers[end], column_numbers[end]),
            )

    if fullparse and pos < len(text):
        line, col = line_numbers[pos], column_numbers[pos]
        position = _Position(pos, line, col)
        excerpt = _extract_excerpt(text, pos, col)
        raise PartialParseError(nodes, position, excerpt)

    return nodes


def _extract_excerpt(text, pos, col):
    if isinstance(text, bytes):
        return repr(text[max(0, pos - 1) : pos + 2])

    start = pos - (col - 1)
    match = _compile_re('\n').search(text, pos + 1)
    end = len(text) if match is None else match.start()

    if end - start < 96:
        return text[start : end] + _caret_at(col - 1)

    if col < 60:
        # Chop the line off at the end.
        return text[start : start + 90] + ' ...' + _caret_at(col - 1)

    elif end - pos < 40:
        # Chop the line off at the start.
        return '... ' + text[end - 90 : end] + _caret_at(pos - (end - 90) + 4)

    else:
        # Chop the line off at both ends.
        return '... ' + text[pos - 42 : pos + 42] + ' ...' + _caret_at(42 + 4)


def _caret_at(index):
    return '\n' + (' ' * index) + '^'


def _get_line_and_column(text, pos):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)
    return line_numbers[pos], column_numbers[pos]


def _map_index_to_line_and_column(text):
    line_numbers = []
    column_numbers = []

    current_line = 1
    current_column = 0

    for c in text:
        if c == '\n':
            current_line += 1
            current_column = 0
        else:
            current_column += 1
        line_numbers.append(current_line)
        column_numbers.append(current_column)

    return line_numbers, column_numbers

matcher1 = _compile_re(b'[\\x00-\\xFF]', flags=0).match
matcher2 = _compile_re(b'[\\x00-\\xFF]{4}', flags=0).match
matcher3 = _compile_re(b'[\\x00-\\xFF]{8}', flags=0).match
matcher4 = _compile_re(b'[\\x80-\\xFF]*[\\x00-\\x7F]', flags=0).match

class Module(Node):
    """
    class Module {
        let magic: b'\\x00asm'
        let version: b'\\x01\\x00\\x00\\x00'
        custom1: CustomSection*
        type_section: Opt(TypeSection)
        custom2: CustomSection*
        import_section: Opt(ImportSection)
        custom3: CustomSection*
        function_section: Opt(FunctionSection)
        custom4: CustomSection*
        table_section: Opt(TableSection)
        custom5: CustomSection*
        memory_section: Opt(MemorySection)
        custom6: CustomSection*
        global_section: Opt(GlobalSection)
        custom7: CustomSection*
        export_section: Opt(ExportSection)
        custom8: CustomSection*
        start_section: Opt(StartSection)
        custom9: CustomSection*
        element_section: Opt(ElementSection)
        custom10: CustomSection*
        data_count_section: Opt(DataCountSection)
        custom11: CustomSection*
        code_section: Opt(CodeSection)
        custom12: CustomSection*
        data_section: Opt(DataSection)
        custom13: CustomSection*
    }
    """
    _fields = ('custom1', 'type_section', 'custom2', 'import_section', 'custom3', 'function_section', 'custom4', 'table_section', 'custom5', 'memory_section', 'custom6', 'global_section', 'custom7', 'export_section', 'custom8', 'start_section', 'custom9', 'element_section', 'custom10', 'data_count_section', 'custom11', 'code_section', 'custom12', 'data_section', 'custom13')

    magic = b'\x00asm'
    version = b'\x01\x00\x00\x00'

    def __init__(self, custom1, type_section, custom2, import_section, custom3, function_section, custom4, table_section, custom5, memory_section, custom6, global_section, custom7, export_section, custom8, start_section, custom9, element_section, custom10, data_count_section, custom11, code_section, custom12, data_section, custom13):
        Node.__init__(self)
        self.custom1 = custom1
        self.type_section = type_section
        self.custom2 = custom2
        self.import_section = import_section
        self.custom3 = custom3
        self.function_section = function_section
        self.custom4 = custom4
        self.table_section = table_section
        self.custom5 = custom5
        self.memory_section = memory_section
        self.custom6 = custom6
        self.global_section = global_section
        self.custom7 = custom7
        self.export_section = export_section
        self.custom8 = custom8
        self.start_section = start_section
        self.custom9 = custom9
        self.element_section = element_section
        self.custom10 = custom10
        self.data_count_section = data_count_section
        self.custom11 = custom11
        self.code_section = code_section
        self.custom12 = custom12
        self.data_section = data_section
        self.custom13 = custom13

    def __repr__(self):
        return f'Module(custom1={self.custom1!r}, type_section={self.type_section!r}, custom2={self.custom2!r}, import_section={self.import_section!r}, custom3={self.custom3!r}, function_section={self.function_section!r}, custom4={self.custom4!r}, table_section={self.table_section!r}, custom5={self.custom5!r}, memory_section={self.memory_section!r}, custom6={self.custom6!r}, global_section={self.global_section!r}, custom7={self.custom7!r}, export_section={self.export_section!r}, custom8={self.custom8!r}, start_section={self.start_section!r}, custom9={self.custom9!r}, element_section={self.element_section!r}, custom10={self.custom10!r}, data_count_section={self.data_count_section!r}, custom11={self.custom11!r}, code_section={self.code_section!r}, custom12={self.custom12!r}, data_section={self.data_section!r}, custom13={self.custom13!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Module, fullparse)


def _try_Module(_text, _pos):
    # Begin Seq
    start_pos1 = _pos
    while True:
        # Begin Str
        value1 = b'\x00asm'
        end1 = (_pos + 4)
        if (_text[slice(_pos, end1, None)] == value1):
            _result = value1
            _pos = end1
            _status = True
        else:
            _result = _raise_error4
            _status = False
        # End Str
        if not (_status):
            break
        magic = _result
        # Begin Str
        value2 = b'\x01\x00\x00\x00'
        end2 = (_pos + 4)
        if (_text[slice(_pos, end2, None)] == value2):
            _result = value2
            _pos = end2
            _status = True
        else:
            _result = _raise_error6
            _status = False
        # End Str
        if not (_status):
            break
        version = _result
        # Begin List
        # CustomSection*
        staging1 = []
        while True:
            checkpoint1 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint1
                break
            staging1.append(_result)
        _result = staging1
        _status = True
        # End List
        custom1 = _result
        # Begin Opt
        # Opt(TypeSection)
        backtrack1 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TypeSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack1
            _result = None
            _status = True
        # End Opt
        type_section = _result
        # Begin List
        # CustomSection*
        staging2 = []
        while True:
            checkpoint2 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint2
                break
            staging2.append(_result)
        _result = staging2
        _status = True
        # End List
        custom2 = _result
        # Begin Opt
        # Opt(ImportSection)
        backtrack2 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ImportSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack2
            _result = None
            _status = True
        # End Opt
        import_section = _result
        # Begin List
        # CustomSection*
        staging3 = []
        while True:
            checkpoint3 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint3
                break
            staging3.append(_result)
        _result = staging3
        _status = True
        # End List
        custom3 = _result
        # Begin Opt
        # Opt(FunctionSection)
        backtrack3 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack3
            _result = None
            _status = True
        # End Opt
        function_section = _result
        # Begin List
        # CustomSection*
        staging4 = []
        while True:
            checkpoint4 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint4
                break
            staging4.append(_result)
        _result = staging4
        _status = True
        # End List
        custom4 = _result
        # Begin Opt
        # Opt(TableSection)
        backtrack4 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack4
            _result = None
            _status = True
        # End Opt
        table_section = _result
        # Begin List
        # CustomSection*
        staging5 = []
        while True:
            checkpoint5 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint5
                break
            staging5.append(_result)
        _result = staging5
        _status = True
        # End List
        custom5 = _result
        # Begin Opt
        # Opt(MemorySection)
        backtrack5 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemorySection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack5
            _result = None
            _status = True
        # End Opt
        memory_section = _result
        # Begin List
        # CustomSection*
        staging6 = []
        while True:
            checkpoint6 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint6
                break
            staging6.append(_result)
        _result = staging6
        _status = True
        # End List
        custom6 = _result
        # Begin Opt
        # Opt(GlobalSection)
        backtrack6 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack6
            _result = None
            _status = True
        # End Opt
        global_section = _result
        # Begin List
        # CustomSection*
        staging7 = []
        while True:
            checkpoint7 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint7
                break
            staging7.append(_result)
        _result = staging7
        _status = True
        # End List
        custom7 = _result
        # Begin Opt
        # Opt(ExportSection)
        backtrack7 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ExportSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack7
            _result = None
            _status = True
        # End Opt
        export_section = _result
        # Begin List
        # CustomSection*
        staging8 = []
        while True:
            checkpoint8 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint8
                break
            staging8.append(_result)
        _result = staging8
        _status = True
        # End List
        custom8 = _result
        # Begin Opt
        # Opt(StartSection)
        backtrack8 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_StartSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack8
            _result = None
            _status = True
        # End Opt
        start_section = _result
        # Begin List
        # CustomSection*
        staging9 = []
        while True:
            checkpoint9 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint9
                break
            staging9.append(_result)
        _result = staging9
        _status = True
        # End List
        custom9 = _result
        # Begin Opt
        # Opt(ElementSection)
        backtrack9 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ElementSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack9
            _result = None
            _status = True
        # End Opt
        element_section = _result
        # Begin List
        # CustomSection*
        staging10 = []
        while True:
            checkpoint10 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint10
                break
            staging10.append(_result)
        _result = staging10
        _status = True
        # End List
        custom10 = _result
        # Begin Opt
        # Opt(DataCountSection)
        backtrack10 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataCountSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack10
            _result = None
            _status = True
        # End Opt
        data_count_section = _result
        # Begin List
        # CustomSection*
        staging11 = []
        while True:
            checkpoint11 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint11
                break
            staging11.append(_result)
        _result = staging11
        _status = True
        # End List
        custom11 = _result
        # Begin Opt
        # Opt(CodeSection)
        backtrack11 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_CodeSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack11
            _result = None
            _status = True
        # End Opt
        code_section = _result
        # Begin List
        # CustomSection*
        staging12 = []
        while True:
            checkpoint12 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint12
                break
            staging12.append(_result)
        _result = staging12
        _status = True
        # End List
        custom12 = _result
        # Begin Opt
        # Opt(DataSection)
        backtrack12 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack12
            _result = None
            _status = True
        # End Opt
        data_section = _result
        # Begin List
        # CustomSection*
        staging13 = []
        while True:
            checkpoint13 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint13
                break
            staging13.append(_result)
        _result = staging13
        _status = True
        # End List
        custom13 = _result
        _result = Module(custom1, type_section, custom2, import_section, custom3, function_section, custom4, table_section, custom5, memory_section, custom6, global_section, custom7, export_section, custom8, start_section, custom9, element_section, custom10, data_count_section, custom11, code_section, custom12, data_section, custom13)
        _result._metadata.position_info = (start_pos1, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error4(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x00asm'\n\n"
    "Expected to match the string b'\\x00asm'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error6(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x01\\x00\\x00\\x00'\n\n"
    "Expected to match the string b'\\x01\\x00\\x00\\x00'"
    )
    raise ParseError((title + details), _pos, line, col)

class CustomSection(Node):
    """
    class CustomSection {
        let id: 0x0
        let size: u32
        let loc: LocatedName
        let remaining: `size - (loc.end - loc.start)`
        name: `loc.name`
        body: ByteString(remaining)
    }
    """
    _fields = ('name', 'body')

    id = 0x0

    def __init__(self, name, body):
        Node.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'CustomSection(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CustomSection, fullparse)


def _try_CustomSection(_text, _pos):
    # Begin Seq
    start_pos2 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error85
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LocatedName, _pos))
        # End Ref
        if not (_status):
            break
        loc = _result
        _result = size - (loc.end - loc.start)
        _status = True
        remaining = _result
        _result = loc.name
        _status = True
        name = _result
        # Begin Call
        # ByteString(remaining)
        func1 = _ParseFunction(_try_ByteString, (remaining,), ())
        (_status, _result, _pos) = (yield (3, func1, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = CustomSection(name, body)
        _result._metadata.position_info = (start_pos2, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error85(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CustomSection' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class TypeSection(Node):
    """
    class TypeSection {
        let id: 0x1
        let size: u32
        function_types: vec(FunctionType)
    }
    """
    _fields = ('function_types',)

    id = 0x1

    def __init__(self, function_types):
        Node.__init__(self)
        self.function_types = function_types

    def __repr__(self):
        return f'TypeSection(function_types={self.function_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TypeSection, fullparse)


def _try_TypeSection(_text, _pos):
    # Begin Seq
    start_pos3 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error101
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(FunctionType)
        func2 = _ParseFunction(_try_vec, (_try_FunctionType,), ())
        (_status, _result, _pos) = (yield (3, func2, _pos))
        # End Call
        if not (_status):
            break
        function_types = _result
        _result = TypeSection(function_types)
        _result._metadata.position_info = (start_pos3, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error101(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TypeSection' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportSection(Node):
    """
    class ImportSection {
        let id: 0x2
        let size: u32
        imports: vec(Import)
    }
    """
    _fields = ('imports',)

    id = 0x2

    def __init__(self, imports):
        Node.__init__(self)
        self.imports = imports

    def __repr__(self):
        return f'ImportSection(imports={self.imports!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportSection, fullparse)


def _try_ImportSection(_text, _pos):
    # Begin Seq
    start_pos4 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error111
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Import)
        func3 = _ParseFunction(_try_vec, (_try_Import,), ())
        (_status, _result, _pos) = (yield (3, func3, _pos))
        # End Call
        if not (_status):
            break
        imports = _result
        _result = ImportSection(imports)
        _result._metadata.position_info = (start_pos4, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error111(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportSection' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class FunctionSection(Node):
    """
    class FunctionSection {
        let id: 0x3
        let size: u32
        type_indexes: vec(TypeIndex)
    }
    """
    _fields = ('type_indexes',)

    id = 0x3

    def __init__(self, type_indexes):
        Node.__init__(self)
        self.type_indexes = type_indexes

    def __repr__(self):
        return f'FunctionSection(type_indexes={self.type_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_FunctionSection, fullparse)


def _try_FunctionSection(_text, _pos):
    # Begin Seq
    start_pos5 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error121
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(TypeIndex)
        func4 = _ParseFunction(_try_vec, (_try_TypeIndex,), ())
        (_status, _result, _pos) = (yield (3, func4, _pos))
        # End Call
        if not (_status):
            break
        type_indexes = _result
        _result = FunctionSection(type_indexes)
        _result._metadata.position_info = (start_pos5, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error121(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FunctionSection' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class TableSection(Node):
    """
    class TableSection {
        let id: 0x4
        let size: u32
        table_types: vec(TableType)
    }
    """
    _fields = ('table_types',)

    id = 0x4

    def __init__(self, table_types):
        Node.__init__(self)
        self.table_types = table_types

    def __repr__(self):
        return f'TableSection(table_types={self.table_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TableSection, fullparse)


def _try_TableSection(_text, _pos):
    # Begin Seq
    start_pos6 = _pos
    while True:
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error131
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(TableType)
        func5 = _ParseFunction(_try_vec, (_try_TableType,), ())
        (_status, _result, _pos) = (yield (3, func5, _pos))
        # End Call
        if not (_status):
            break
        table_types = _result
        _result = TableSection(table_types)
        _result._metadata.position_info = (start_pos6, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error131(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TableSection' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

class MemorySection(Node):
    """
    class MemorySection {
        let id: 0x5
        let size: u32
        memory_types: vec(MemoryType)
    }
    """
    _fields = ('memory_types',)

    id = 0x5

    def __init__(self, memory_types):
        Node.__init__(self)
        self.memory_types = memory_types

    def __repr__(self):
        return f'MemorySection(memory_types={self.memory_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MemorySection, fullparse)


def _try_MemorySection(_text, _pos):
    # Begin Seq
    start_pos7 = _pos
    while True:
        # Begin Byte
        # 0x5
        if (_pos < len(_text)) and (_text[_pos] == 5):
            _result = 5
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error141
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(MemoryType)
        func6 = _ParseFunction(_try_vec, (_try_MemoryType,), ())
        (_status, _result, _pos) = (yield (3, func6, _pos))
        # End Call
        if not (_status):
            break
        memory_types = _result
        _result = MemorySection(memory_types)
        _result._metadata.position_info = (start_pos7, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error141(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MemorySection' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

class GlobalSection(Node):
    """
    class GlobalSection {
        let id: 0x6
        let size: u32
        globals: vec(Global)
    }
    """
    _fields = ('globals',)

    id = 0x6

    def __init__(self, globals):
        Node.__init__(self)
        self.globals = globals

    def __repr__(self):
        return f'GlobalSection(globals={self.globals!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_GlobalSection, fullparse)


def _try_GlobalSection(_text, _pos):
    # Begin Seq
    start_pos8 = _pos
    while True:
        # Begin Byte
        # 0x6
        if (_pos < len(_text)) and (_text[_pos] == 6):
            _result = 6
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error151
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Global)
        func7 = _ParseFunction(_try_vec, (_try_Global,), ())
        (_status, _result, _pos) = (yield (3, func7, _pos))
        # End Call
        if not (_status):
            break
        globals = _result
        _result = GlobalSection(globals)
        _result._metadata.position_info = (start_pos8, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error151(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalSection' rule, at the expression:\n"
    '    0x6\n\n'
    'Expected to match the byte value 0x6'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportSection(Node):
    """
    class ExportSection {
        let id: 0x7
        let size: u32
        exports: vec(Export)
    }
    """
    _fields = ('exports',)

    id = 0x7

    def __init__(self, exports):
        Node.__init__(self)
        self.exports = exports

    def __repr__(self):
        return f'ExportSection(exports={self.exports!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportSection, fullparse)


def _try_ExportSection(_text, _pos):
    # Begin Seq
    start_pos9 = _pos
    while True:
        # Begin Byte
        # 0x7
        if (_pos < len(_text)) and (_text[_pos] == 7):
            _result = 7
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error161
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Export)
        func8 = _ParseFunction(_try_vec, (_try_Export,), ())
        (_status, _result, _pos) = (yield (3, func8, _pos))
        # End Call
        if not (_status):
            break
        exports = _result
        _result = ExportSection(exports)
        _result._metadata.position_info = (start_pos9, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error161(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportSection' rule, at the expression:\n"
    '    0x7\n\n'
    'Expected to match the byte value 0x7'
    )
    raise ParseError((title + details), _pos, line, col)

class StartSection(Node):
    """
    class StartSection {
        let id: 0x8
        let size: u32
        index: FunctionIndex
    }
    """
    _fields = ('index',)

    id = 0x8

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'StartSection(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_StartSection, fullparse)


def _try_StartSection(_text, _pos):
    # Begin Seq
    start_pos10 = _pos
    while True:
        # Begin Byte
        # 0x8
        if (_pos < len(_text)) and (_text[_pos] == 8):
            _result = 8
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error171
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = StartSection(index)
        _result._metadata.position_info = (start_pos10, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error171(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'StartSection' rule, at the expression:\n"
    '    0x8\n\n'
    'Expected to match the byte value 0x8'
    )
    raise ParseError((title + details), _pos, line, col)

class ElementSection(Node):
    """
    class ElementSection {
        let id: 0x9
        let size: u32
        segments: vec(ElementSegment)
    }
    """
    _fields = ('segments',)

    id = 0x9

    def __init__(self, segments):
        Node.__init__(self)
        self.segments = segments

    def __repr__(self):
        return f'ElementSection(segments={self.segments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ElementSection, fullparse)


def _try_ElementSection(_text, _pos):
    # Begin Seq
    start_pos11 = _pos
    while True:
        # Begin Byte
        # 0x9
        if (_pos < len(_text)) and (_text[_pos] == 9):
            _result = 9
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error179
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(ElementSegment)
        func9 = _ParseFunction(_try_vec, (_try_ElementSegment,), ())
        (_status, _result, _pos) = (yield (3, func9, _pos))
        # End Call
        if not (_status):
            break
        segments = _result
        _result = ElementSection(segments)
        _result._metadata.position_info = (start_pos11, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error179(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementSection' rule, at the expression:\n"
    '    0x9\n\n'
    'Expected to match the byte value 0x9'
    )
    raise ParseError((title + details), _pos, line, col)

class DataCountSection(Node):
    """
    class DataCountSection {
        let id: 0xc
        let size: u32
        count: Opt(u32 where `lambda _: size > 0`)
    }
    """
    _fields = ('count',)

    id = 0xc

    def __init__(self, count):
        Node.__init__(self)
        self.count = count

    def __repr__(self):
        return f'DataCountSection(count={self.count!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DataCountSection, fullparse)


def _try_DataCountSection(_text, _pos):
    # Begin Seq
    start_pos12 = _pos
    while True:
        # Begin Byte
        # 0xc
        if (_pos < len(_text)) and (_text[_pos] == 12):
            _result = 12
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error189
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Opt
        # Opt(u32 where `lambda _: size > 0`)
        backtrack13 = _pos
        # Begin Where
        # u32 where `lambda _: size > 0`
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if _status:
            arg1 = _result
            _result = lambda _: size > 0
            _status = True
            if _result(arg1):
                _result = arg1
            else:
                _result = _raise_error194
                _status = False
        # End Where
        if not (_status):
            _pos = backtrack13
            _result = None
            _status = True
        # End Opt
        count = _result
        _result = DataCountSection(count)
        _result._metadata.position_info = (start_pos12, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error189(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataCountSection' rule, at the expression:\n"
    '    0xc\n\n'
    'Expected to match the byte value 0xc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error194(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataCountSection' rule, at the expression:\n"
    '    u32 where `lambda _: size > 0`\n\n'
    'Expected to satisfy the predicate: `lambda _: size > 0`'
    )
    raise ParseError((title + details), _pos, line, col)

class CodeSection(Node):
    """
    class CodeSection {
        let id: 0xa
        let size: u32
        entries: vec(CodeEntry)
    }
    """
    _fields = ('entries',)

    id = 0xa

    def __init__(self, entries):
        Node.__init__(self)
        self.entries = entries

    def __repr__(self):
        return f'CodeSection(entries={self.entries!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CodeSection, fullparse)


def _try_CodeSection(_text, _pos):
    # Begin Seq
    start_pos13 = _pos
    while True:
        # Begin Byte
        # 0xa
        if (_pos < len(_text)) and (_text[_pos] == 10):
            _result = 10
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error200
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(CodeEntry)
        func10 = _ParseFunction(_try_vec, (_try_CodeEntry,), ())
        (_status, _result, _pos) = (yield (3, func10, _pos))
        # End Call
        if not (_status):
            break
        entries = _result
        _result = CodeSection(entries)
        _result._metadata.position_info = (start_pos13, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error200(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CodeSection' rule, at the expression:\n"
    '    0xa\n\n'
    'Expected to match the byte value 0xa'
    )
    raise ParseError((title + details), _pos, line, col)

class DataSection(Node):
    """
    class DataSection {
        let id: 0xb
        let size: u32
        segments: vec(ActiveDataSegment | PassiveDataSegment | ActiveIndexDataSegment)
    }
    """
    _fields = ('segments',)

    id = 0xb

    def __init__(self, segments):
        Node.__init__(self)
        self.segments = segments

    def __repr__(self):
        return f'DataSection(segments={self.segments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DataSection, fullparse)


def _parse_function_216(_text, _pos):
    # Begin Choice
    farthest_err1 = _raise_error216
    backtrack14 = farthest_pos1 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack14
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack14
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveIndexDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = farthest_pos1
        _result = farthest_err1
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_DataSection(_text, _pos):
    # Begin Seq
    start_pos14 = _pos
    while True:
        # Begin Byte
        # 0xb
        if (_pos < len(_text)) and (_text[_pos] == 11):
            _result = 11
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error210
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(ActiveDataSegment | PassiveDataSegment | ActiveIndexDataSegment)
        func11 = _ParseFunction(_try_vec, (_parse_function_216,), ())
        (_status, _result, _pos) = (yield (3, func11, _pos))
        # End Call
        if not (_status):
            break
        segments = _result
        _result = DataSection(segments)
        _result._metadata.position_info = (start_pos14, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error210(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataSection' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error216(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataSection' rule, at the expression:\n"
    '    ActiveDataSegment | PassiveDataSegment | ActiveIndexDataSegment\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Global(Node):
    """
    class Global {
        type: GlobalType
        initializer: Expression
    }
    """
    _fields = ('type', 'initializer')

    def __init__(self, type, initializer):
        Node.__init__(self)
        self.type = type
        self.initializer = initializer

    def __repr__(self):
        return f'Global(type={self.type!r}, initializer={self.initializer!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Global, fullparse)


def _try_Global(_text, _pos):
    # Begin Seq
    start_pos15 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        initializer = _result
        _result = Global(type, initializer)
        _result._metadata.position_info = (start_pos15, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Import(Node):
    """
    class Import {
        module: Name
        name: Name
        descriptor: ImportFunc | ImportTable | ImportMemory | ImportGlobal
    }
    """
    _fields = ('module', 'name', 'descriptor')

    def __init__(self, module, name, descriptor):
        Node.__init__(self)
        self.module = module
        self.name = name
        self.descriptor = descriptor

    def __repr__(self):
        return f'Import(module={self.module!r}, name={self.name!r}, descriptor={self.descriptor!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Import, fullparse)


def _try_Import(_text, _pos):
    # Begin Seq
    start_pos16 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        module = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Choice
        farthest_err2 = _raise_error233
        backtrack15 = farthest_pos2 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportFunc, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportTable, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 3:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportMemory, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 4:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportGlobal, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = farthest_pos2
            _result = farthest_err2
            break
        # End Choice
        if not (_status):
            break
        descriptor = _result
        _result = Import(module, name, descriptor)
        _result._metadata.position_info = (start_pos16, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error233(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Import' rule, at the expression:\n"
    '    ImportFunc | ImportTable | ImportMemory | ImportGlobal\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportFunc(Node):
    """
    class ImportFunc {
        let id: 0x0
        type: TypeIndex
    }
    """
    _fields = ('type',)

    id = 0x0

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportFunc(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportFunc, fullparse)


def _try_ImportFunc(_text, _pos):
    # Begin Seq
    start_pos17 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error241
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TypeIndex, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportFunc(type)
        _result._metadata.position_info = (start_pos17, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error241(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportFunc' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportTable(Node):
    """
    class ImportTable {
        let id: 0x1
        type: TableType
    }
    """
    _fields = ('type',)

    id = 0x1

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportTable(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportTable, fullparse)


def _try_ImportTable(_text, _pos):
    # Begin Seq
    start_pos18 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error247
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportTable(type)
        _result._metadata.position_info = (start_pos18, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error247(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportTable' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportMemory(Node):
    """
    class ImportMemory {
        let id: 0x2
        type: MemoryType
    }
    """
    _fields = ('type',)

    id = 0x2

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportMemory(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportMemory, fullparse)


def _try_ImportMemory(_text, _pos):
    # Begin Seq
    start_pos19 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error253
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemoryType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportMemory(type)
        _result._metadata.position_info = (start_pos19, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error253(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportMemory' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportGlobal(Node):
    """
    class ImportGlobal {
        let id: 0x3
        type: GlobalType
    }
    """
    _fields = ('type',)

    id = 0x3

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportGlobal(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportGlobal, fullparse)


def _try_ImportGlobal(_text, _pos):
    # Begin Seq
    start_pos20 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error259
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportGlobal(type)
        _result._metadata.position_info = (start_pos20, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error259(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportGlobal' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class Export(Node):
    """
    class Export {
        name: Name
        descriptor: ExportFunc | ExportTable | ExportMemory | ExportGlobal
    }
    """
    _fields = ('name', 'descriptor')

    def __init__(self, name, descriptor):
        Node.__init__(self)
        self.name = name
        self.descriptor = descriptor

    def __repr__(self):
        return f'Export(name={self.name!r}, descriptor={self.descriptor!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Export, fullparse)


def _try_Export(_text, _pos):
    # Begin Seq
    start_pos21 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Choice
        farthest_err3 = _raise_error267
        backtrack16 = farthest_pos3 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportFunc, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportTable, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 3:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportMemory, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 4:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportGlobal, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = farthest_pos3
            _result = farthest_err3
            break
        # End Choice
        if not (_status):
            break
        descriptor = _result
        _result = Export(name, descriptor)
        _result._metadata.position_info = (start_pos21, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error267(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Export' rule, at the expression:\n"
    '    ExportFunc | ExportTable | ExportMemory | ExportGlobal\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportFunc(Node):
    """
    class ExportFunc {
        let id: 0x0
        index: FunctionIndex
    }
    """
    _fields = ('index',)

    id = 0x0

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportFunc(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportFunc, fullparse)


def _try_ExportFunc(_text, _pos):
    # Begin Seq
    start_pos22 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error275
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportFunc(index)
        _result._metadata.position_info = (start_pos22, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error275(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportFunc' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportTable(Node):
    """
    class ExportTable {
        let id: 0x1
        index: TableIndex
    }
    """
    _fields = ('index',)

    id = 0x1

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportTable(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportTable, fullparse)


def _try_ExportTable(_text, _pos):
    # Begin Seq
    start_pos23 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error281
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportTable(index)
        _result._metadata.position_info = (start_pos23, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error281(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportTable' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportMemory(Node):
    """
    class ExportMemory {
        let id: 0x2
        index: MemoryIndex
    }
    """
    _fields = ('index',)

    id = 0x2

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportMemory(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportMemory, fullparse)


def _try_ExportMemory(_text, _pos):
    # Begin Seq
    start_pos24 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error287
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemoryIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportMemory(index)
        _result._metadata.position_info = (start_pos24, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error287(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportMemory' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportGlobal(Node):
    """
    class ExportGlobal {
        let id: 0x3
        index: GlobalIndex
    }
    """
    _fields = ('index',)

    id = 0x3

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportGlobal(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportGlobal, fullparse)


def _try_ExportGlobal(_text, _pos):
    # Begin Seq
    start_pos25 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error293
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportGlobal(index)
        _result._metadata.position_info = (start_pos25, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error293(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportGlobal' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ElementSegment(_text, _pos):
    # Rule 'ElementSegment'
    # Begin Choice
    farthest_err4 = _raise_error297
    backtrack17 = farthest_pos4 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DefaultSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DeclarativeFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DefaultExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 7:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 8:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DeclarativeExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = farthest_pos4
        _result = farthest_err4
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ElementSegment(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ElementSegment, fullparse)

ElementSegment = Rule('ElementSegment', _parse_ElementSegment, """
    ElementSegment = DefaultSegment | PassiveFuncRefSegment | ActiveFuncRefSegment | DeclarativeFuncRefSegment | DefaultExpressionSegment | PassiveExpressionSegment | ActiveExpressionSegment | DeclarativeExpressionSegment
""")
def _raise_error297(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementSegment' rule, at the expression:\n"
    '    DefaultSegment | PassiveFuncRefSegment | ActiveFuncRefSegment | DeclarativeFuncRefSegment | DefaultExpressionSegment | PassiveExpressionSegment | ActiveExpressionSegment | DeclarativeExpressionSegment\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class DefaultSegment(Node):
    """
    class DefaultSegment {
        let id: 0x0
        offset: Expression
        function_indexes: vec(FunctionIndex)
    }
    """
    _fields = ('offset', 'function_indexes')

    id = 0x0

    def __init__(self, offset, function_indexes):
        Node.__init__(self)
        self.offset = offset
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'DefaultSegment(offset={self.offset!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DefaultSegment, fullparse)


def _try_DefaultSegment(_text, _pos):
    # Begin Seq
    start_pos26 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error309
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Call
        # vec(FunctionIndex)
        func12 = _ParseFunction(_try_vec, (_try_FunctionIndex,), ())
        (_status, _result, _pos) = (yield (3, func12, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = DefaultSegment(offset, function_indexes)
        _result._metadata.position_info = (start_pos26, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error309(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DefaultSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveFuncRefSegment(Node):
    """
    class PassiveFuncRefSegment {
        let id: 0x1
        type: 0x0 >> `'funcref'`
        function_indexes: vec(FunctionIndex)
    }
    """
    _fields = ('type', 'function_indexes')

    id = 0x1

    def __init__(self, type, function_indexes):
        Node.__init__(self)
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'PassiveFuncRefSegment(type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveFuncRefSegment, fullparse)


def _try_PassiveFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos27 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error319
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error322
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(FunctionIndex)
        func13 = _ParseFunction(_try_vec, (_try_FunctionIndex,), ())
        (_status, _result, _pos) = (yield (3, func13, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = PassiveFuncRefSegment(type, function_indexes)
        _result._metadata.position_info = (start_pos27, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error319(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveFuncRefSegment' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error322(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveFuncRefSegment(Node):
    """
    class ActiveFuncRefSegment {
        let id: 0x2
        table_index: TableIndex
        offset: Expression
        type: 0x0 >> `'funcref'`
        function_indexes: vec(FunctionIndex)
    }
    """
    _fields = ('table_index', 'offset', 'type', 'function_indexes')

    id = 0x2

    def __init__(self, table_index, offset, type, function_indexes):
        Node.__init__(self)
        self.table_index = table_index
        self.offset = offset
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'ActiveFuncRefSegment(table_index={self.table_index!r}, offset={self.offset!r}, type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveFuncRefSegment, fullparse)


def _try_ActiveFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos28 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error331
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table_index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error338
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(FunctionIndex)
        func14 = _ParseFunction(_try_vec, (_try_FunctionIndex,), ())
        (_status, _result, _pos) = (yield (3, func14, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = ActiveFuncRefSegment(table_index, offset, type, function_indexes)
        _result._metadata.position_info = (start_pos28, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error331(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveFuncRefSegment' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error338(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class DeclarativeFuncRefSegment(Node):
    """
    class DeclarativeFuncRefSegment {
        let id: 0x3
        type: 0x0 >> `'funcref'`
        function_indexes: vec(FunctionIndex)
    }
    """
    _fields = ('type', 'function_indexes')

    id = 0x3

    def __init__(self, type, function_indexes):
        Node.__init__(self)
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'DeclarativeFuncRefSegment(type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DeclarativeFuncRefSegment, fullparse)


def _try_DeclarativeFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos29 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error347
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error350
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(FunctionIndex)
        func15 = _ParseFunction(_try_vec, (_try_FunctionIndex,), ())
        (_status, _result, _pos) = (yield (3, func15, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = DeclarativeFuncRefSegment(type, function_indexes)
        _result._metadata.position_info = (start_pos29, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error347(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeFuncRefSegment' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error350(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class DefaultExpressionSegment(Node):
    """
    class DefaultExpressionSegment {
        let id: 0x4
        offset: Expression
        initializers: vec(Expression)
    }
    """
    _fields = ('offset', 'initializers')

    id = 0x4

    def __init__(self, offset, initializers):
        Node.__init__(self)
        self.offset = offset
        self.initializers = initializers

    def __repr__(self):
        return f'DefaultExpressionSegment(offset={self.offset!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DefaultExpressionSegment, fullparse)


def _try_DefaultExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos30 = _pos
    while True:
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error359
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Call
        # vec(Expression)
        func16 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func16, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = DefaultExpressionSegment(offset, initializers)
        _result._metadata.position_info = (start_pos30, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error359(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DefaultExpressionSegment' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveExpressionSegment(Node):
    """
    class PassiveExpressionSegment {
        let id: 0x5
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('type', 'initializers')

    id = 0x5

    def __init__(self, type, initializers):
        Node.__init__(self)
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'PassiveExpressionSegment(type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveExpressionSegment, fullparse)


def _try_PassiveExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos31 = _pos
    while True:
        # Begin Byte
        # 0x5
        if (_pos < len(_text)) and (_text[_pos] == 5):
            _result = 5
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error369
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func17 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func17, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = PassiveExpressionSegment(type, initializers)
        _result._metadata.position_info = (start_pos31, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error369(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveExpressionSegment' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveExpressionSegment(Node):
    """
    class ActiveExpressionSegment {
        let id: 0x6
        table_index: TableIndex
        offset: Expression
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('table_index', 'offset', 'type', 'initializers')

    id = 0x6

    def __init__(self, table_index, offset, type, initializers):
        Node.__init__(self)
        self.table_index = table_index
        self.offset = offset
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'ActiveExpressionSegment(table_index={self.table_index!r}, offset={self.offset!r}, type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveExpressionSegment, fullparse)


def _try_ActiveExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos32 = _pos
    while True:
        # Begin Byte
        # 0x6
        if (_pos < len(_text)) and (_text[_pos] == 6):
            _result = 6
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error379
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table_index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func18 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func18, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = ActiveExpressionSegment(table_index, offset, type, initializers)
        _result._metadata.position_info = (start_pos32, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error379(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveExpressionSegment' rule, at the expression:\n"
    '    0x6\n\n'
    'Expected to match the byte value 0x6'
    )
    raise ParseError((title + details), _pos, line, col)

class DeclarativeExpressionSegment(Node):
    """
    class DeclarativeExpressionSegment {
        let id: 0x7
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('type', 'initializers')

    id = 0x7

    def __init__(self, type, initializers):
        Node.__init__(self)
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'DeclarativeExpressionSegment(type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DeclarativeExpressionSegment, fullparse)


def _try_DeclarativeExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos33 = _pos
    while True:
        # Begin Byte
        # 0x7
        if (_pos < len(_text)) and (_text[_pos] == 7):
            _result = 7
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error393
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func19 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func19, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = DeclarativeExpressionSegment(type, initializers)
        _result._metadata.position_info = (start_pos33, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error393(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeExpressionSegment' rule, at the expression:\n"
    '    0x7\n\n'
    'Expected to match the byte value 0x7'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveDataSegment(Node):
    """
    class ActiveDataSegment {
        let id: 0x0
        offset: Expression
        contents: ByteVector
    }
    """
    _fields = ('offset', 'contents')

    id = 0x0

    def __init__(self, offset, contents):
        Node.__init__(self)
        self.offset = offset
        self.contents = contents

    def __repr__(self):
        return f'ActiveDataSegment(offset={self.offset!r}, contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveDataSegment, fullparse)


def _try_ActiveDataSegment(_text, _pos):
    # Begin Seq
    start_pos34 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error403
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = ActiveDataSegment(offset, contents)
        _result._metadata.position_info = (start_pos34, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error403(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveDataSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveDataSegment(Node):
    """
    class PassiveDataSegment {
        let id: 0x1
        contents: ByteVector
    }
    """
    _fields = ('contents',)

    id = 0x1

    def __init__(self, contents):
        Node.__init__(self)
        self.contents = contents

    def __repr__(self):
        return f'PassiveDataSegment(contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveDataSegment, fullparse)


def _try_PassiveDataSegment(_text, _pos):
    # Begin Seq
    start_pos35 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error411
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = PassiveDataSegment(contents)
        _result._metadata.position_info = (start_pos35, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error411(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveDataSegment' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveIndexDataSegment(Node):
    """
    class ActiveIndexDataSegment {
        let id: 0x2
        index: MemoryIndex
        offset: Expression
        contents: ByteVector
    }
    """
    _fields = ('index', 'offset', 'contents')

    id = 0x2

    def __init__(self, index, offset, contents):
        Node.__init__(self)
        self.index = index
        self.offset = offset
        self.contents = contents

    def __repr__(self):
        return f'ActiveIndexDataSegment(index={self.index!r}, offset={self.offset!r}, contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveIndexDataSegment, fullparse)


def _try_ActiveIndexDataSegment(_text, _pos):
    # Begin Seq
    start_pos36 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error417
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemoryIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = ActiveIndexDataSegment(index, offset, contents)
        _result._metadata.position_info = (start_pos36, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error417(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveIndexDataSegment' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Limits(_text, _pos):
    # Rule 'Limits'
    # Begin Choice
    farthest_err5 = _raise_error425
    backtrack18 = farthest_pos5 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MinLimit, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack18
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MinMaxLimits, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = farthest_pos5
        _result = farthest_err5
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Limits(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Limits, fullparse)

Limits = Rule('Limits', _parse_Limits, """
    Limits = MinLimit | MinMaxLimits
""")
def _raise_error425(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Limits' rule, at the expression:\n"
    '    MinLimit | MinMaxLimits\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class MinLimit(Node):
    """
    class MinLimit {
        let id: 0x0
        min: u32
    }
    """
    _fields = ('min',)

    id = 0x0

    def __init__(self, min):
        Node.__init__(self)
        self.min = min

    def __repr__(self):
        return f'MinLimit(min={self.min!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MinLimit, fullparse)


def _try_MinLimit(_text, _pos):
    # Begin Seq
    start_pos37 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error431
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        min = _result
        _result = MinLimit(min)
        _result._metadata.position_info = (start_pos37, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error431(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MinLimit' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class MinMaxLimits(Node):
    """
    class MinMaxLimits {
        let id: 0x1
        min: u32
        max: u32
    }
    """
    _fields = ('min', 'max')

    id = 0x1

    def __init__(self, min, max):
        Node.__init__(self)
        self.min = min
        self.max = max

    def __repr__(self):
        return f'MinMaxLimits(min={self.min!r}, max={self.max!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MinMaxLimits, fullparse)


def _try_MinMaxLimits(_text, _pos):
    # Begin Seq
    start_pos38 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error437
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        min = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        max = _result
        _result = MinMaxLimits(min, max)
        _result._metadata.position_info = (start_pos38, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error437(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MinMaxLimits' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_DataIndex(_text, _pos):
    # Rule 'DataIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_DataIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_DataIndex, fullparse)

DataIndex = Rule('DataIndex', _parse_DataIndex, """
    DataIndex = u32
""")
def _try_FunctionIndex(_text, _pos):
    # Rule 'FunctionIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_FunctionIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_FunctionIndex, fullparse)

FunctionIndex = Rule('FunctionIndex', _parse_FunctionIndex, """
    FunctionIndex = u32
""")
def _try_ElementIndex(_text, _pos):
    # Rule 'ElementIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_ElementIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ElementIndex, fullparse)

ElementIndex = Rule('ElementIndex', _parse_ElementIndex, """
    ElementIndex = u32
""")
def _try_GlobalIndex(_text, _pos):
    # Rule 'GlobalIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_GlobalIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_GlobalIndex, fullparse)

GlobalIndex = Rule('GlobalIndex', _parse_GlobalIndex, """
    GlobalIndex = u32
""")
def _try_LabelIndex(_text, _pos):
    # Rule 'LabelIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_LabelIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_LabelIndex, fullparse)

LabelIndex = Rule('LabelIndex', _parse_LabelIndex, """
    LabelIndex = u32
""")
def _try_LocalIndex(_text, _pos):
    # Rule 'LocalIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_LocalIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_LocalIndex, fullparse)

LocalIndex = Rule('LocalIndex', _parse_LocalIndex, """
    LocalIndex = u32
""")
def _try_MemoryIndex(_text, _pos):
    # Rule 'MemoryIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_MemoryIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_MemoryIndex, fullparse)

MemoryIndex = Rule('MemoryIndex', _parse_MemoryIndex, """
    MemoryIndex = u32
""")
def _try_TableIndex(_text, _pos):
    # Rule 'TableIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_TableIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_TableIndex, fullparse)

TableIndex = Rule('TableIndex', _parse_TableIndex, """
    TableIndex = u32
""")
def _try_TypeIndex(_text, _pos):
    # Rule 'TypeIndex'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_TypeIndex(text, pos=0, fullparse=True):
    return _run(text, pos, _try_TypeIndex, fullparse)

TypeIndex = Rule('TypeIndex', _parse_TypeIndex, """
    TypeIndex = u32
""")
def _try_BlockType(_text, _pos):
    # Rule 'BlockType'
    # Begin Choice
    farthest_err6 = _raise_error461
    backtrack19 = farthest_pos6 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x40 >> `'empty'`
        while True:
            # Begin Byte
            # 0x40
            if (_pos < len(_text)) and (_text[_pos] == 64):
                _result = 64
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error463
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'empty'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos6 < _pos):
            farthest_pos6 = _pos
            farthest_err6 = _result
        _pos = backtrack19
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ValueType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos6 < _pos):
            farthest_pos6 = _pos
            farthest_err6 = _result
        _pos = backtrack19
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos6 < _pos):
            farthest_pos6 = _pos
            farthest_err6 = _result
        _pos = farthest_pos6
        _result = farthest_err6
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_BlockType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_BlockType, fullparse)

BlockType = Rule('BlockType', _parse_BlockType, """
    BlockType = 0x40 >> `'empty'` | ValueType | SignedInt
""")
def _raise_error461(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'BlockType' rule, at the expression:\n"
    "    0x40 >> `'empty'` | ValueType | SignedInt\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error463(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'BlockType' rule, at the expression:\n"
    '    0x40\n\n'
    'Expected to match the byte value 0x40'
    )
    raise ParseError((title + details), _pos, line, col)

class FunctionType(Node):
    """
    class FunctionType {
        let id: 0x60
        parameter_types: vec(ValueType)
        result_types: vec(ValueType)
    }
    """
    _fields = ('parameter_types', 'result_types')

    id = 0x60

    def __init__(self, parameter_types, result_types):
        Node.__init__(self)
        self.parameter_types = parameter_types
        self.result_types = result_types

    def __repr__(self):
        return f'FunctionType(parameter_types={self.parameter_types!r}, result_types={self.result_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_FunctionType, fullparse)


def _try_FunctionType(_text, _pos):
    # Begin Seq
    start_pos39 = _pos
    while True:
        # Begin Byte
        # 0x60
        if (_pos < len(_text)) and (_text[_pos] == 96):
            _result = 96
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error470
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Call
        # vec(ValueType)
        func20 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func20, _pos))
        # End Call
        if not (_status):
            break
        parameter_types = _result
        # Begin Call
        # vec(ValueType)
        func21 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func21, _pos))
        # End Call
        if not (_status):
            break
        result_types = _result
        _result = FunctionType(parameter_types, result_types)
        _result._metadata.position_info = (start_pos39, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error470(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FunctionType' rule, at the expression:\n"
    '    0x60\n\n'
    'Expected to match the byte value 0x60'
    )
    raise ParseError((title + details), _pos, line, col)

class GlobalType(Node):
    """
    class GlobalType {
        type: ValueType
        modifier: 0x0 >> `'const'` | 0x1 >> `'var'`
    }
    """
    _fields = ('type', 'modifier')

    def __init__(self, type, modifier):
        Node.__init__(self)
        self.type = type
        self.modifier = modifier

    def __repr__(self):
        return f'GlobalType(type={self.type!r}, modifier={self.modifier!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_GlobalType, fullparse)


def _try_GlobalType(_text, _pos):
    # Begin Seq
    start_pos40 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ValueType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Choice
        farthest_err7 = _raise_error484
        backtrack20 = farthest_pos7 = _pos
        while True:
            # Option 1:
            # Begin Discard
            # 0x0 >> `'const'`
            while True:
                # Begin Byte
                # 0x0
                if (_pos < len(_text)) and (_text[_pos] == 0):
                    _result = 0
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error486
                    _status = False
                # End Byte
                if not (_status):
                    break
                _result = 'const'
                _status = True
                break
            # End Discard
            if _status:
                break
            if (farthest_pos7 < _pos):
                farthest_pos7 = _pos
                farthest_err7 = _result
            _pos = backtrack20
            # Option 2:
            # Begin Discard
            # 0x1 >> `'var'`
            while True:
                # Begin Byte
                # 0x1
                if (_pos < len(_text)) and (_text[_pos] == 1):
                    _result = 1
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error489
                    _status = False
                # End Byte
                if not (_status):
                    break
                _result = 'var'
                _status = True
                break
            # End Discard
            if _status:
                break
            if (farthest_pos7 < _pos):
                farthest_pos7 = _pos
                farthest_err7 = _result
            _pos = farthest_pos7
            _result = farthest_err7
            break
        # End Choice
        if not (_status):
            break
        modifier = _result
        _result = GlobalType(type, modifier)
        _result._metadata.position_info = (start_pos40, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error484(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    "    0x0 >> `'const'` | 0x1 >> `'var'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error486(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error489(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class MemoryType(Node):
    """
    class MemoryType {
        limits: Limits
    }
    """
    _fields = ('limits',)

    def __init__(self, limits):
        Node.__init__(self)
        self.limits = limits

    def __repr__(self):
        return f'MemoryType(limits={self.limits!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MemoryType, fullparse)


def _try_MemoryType(_text, _pos):
    # Begin Seq
    start_pos41 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Limits, _pos))
        # End Ref
        if not (_status):
            break
        limits = _result
        _result = MemoryType(limits)
        _result._metadata.position_info = (start_pos41, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_NumberType(_text, _pos):
    # Rule 'NumberType'
    # Begin Choice
    farthest_err8 = _raise_error496
    backtrack21 = farthest_pos8 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x7f >> `'i32'`
        while True:
            # Begin Byte
            # 0x7f
            if (_pos < len(_text)) and (_text[_pos] == 127):
                _result = 127
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error498
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = backtrack21
        # Option 2:
        # Begin Discard
        # 0x7e >> `'i64'`
        while True:
            # Begin Byte
            # 0x7e
            if (_pos < len(_text)) and (_text[_pos] == 126):
                _result = 126
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error501
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = backtrack21
        # Option 3:
        # Begin Discard
        # 0x7d >> `'f32'`
        while True:
            # Begin Byte
            # 0x7d
            if (_pos < len(_text)) and (_text[_pos] == 125):
                _result = 125
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error504
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = backtrack21
        # Option 4:
        # Begin Discard
        # 0x7c >> `'f64'`
        while True:
            # Begin Byte
            # 0x7c
            if (_pos < len(_text)) and (_text[_pos] == 124):
                _result = 124
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error507
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = farthest_pos8
        _result = farthest_err8
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_NumberType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_NumberType, fullparse)

NumberType = Rule('NumberType', _parse_NumberType, """
    NumberType = 0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`
""")
def _raise_error496(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    "    0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error498(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7f\n\n'
    'Expected to match the byte value 0x7f'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error501(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7e\n\n'
    'Expected to match the byte value 0x7e'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error504(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7d\n\n'
    'Expected to match the byte value 0x7d'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error507(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7c\n\n'
    'Expected to match the byte value 0x7c'
    )
    raise ParseError((title + details), _pos, line, col)

class TableType(Node):
    """
    class TableType {
        type: ReferenceType
        limits: Limits
    }
    """
    _fields = ('type', 'limits')

    def __init__(self, type, limits):
        Node.__init__(self)
        self.type = type
        self.limits = limits

    def __repr__(self):
        return f'TableType(type={self.type!r}, limits={self.limits!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TableType, fullparse)


def _try_TableType(_text, _pos):
    # Begin Seq
    start_pos42 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Limits, _pos))
        # End Ref
        if not (_status):
            break
        limits = _result
        _result = TableType(type, limits)
        _result._metadata.position_info = (start_pos42, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_ReferenceType(_text, _pos):
    # Rule 'ReferenceType'
    # Begin Choice
    farthest_err9 = _raise_error516
    backtrack22 = farthest_pos9 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x70 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x70
            if (_pos < len(_text)) and (_text[_pos] == 112):
                _result = 112
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error518
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos9 < _pos):
            farthest_pos9 = _pos
            farthest_err9 = _result
        _pos = backtrack22
        # Option 2:
        # Begin Discard
        # 0x6f >> `'externref'`
        while True:
            # Begin Byte
            # 0x6f
            if (_pos < len(_text)) and (_text[_pos] == 111):
                _result = 111
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error521
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'externref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos9 < _pos):
            farthest_pos9 = _pos
            farthest_err9 = _result
        _pos = farthest_pos9
        _result = farthest_err9
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ReferenceType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ReferenceType, fullparse)

ReferenceType = Rule('ReferenceType', _parse_ReferenceType, """
    ReferenceType = 0x70 >> `'funcref'` | 0x6f >> `'externref'`
""")
def _raise_error516(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    "    0x70 >> `'funcref'` | 0x6f >> `'externref'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error518(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x70\n\n'
    'Expected to match the byte value 0x70'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error521(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x6f\n\n'
    'Expected to match the byte value 0x6f'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ValueType(_text, _pos):
    # Rule 'ValueType'
    # Begin Choice
    farthest_err10 = _raise_error524
    backtrack23 = farthest_pos10 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_NumberType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = backtrack23
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = farthest_pos10
        _result = farthest_err10
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ValueType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ValueType, fullparse)

ValueType = Rule('ValueType', _parse_ValueType, """
    ValueType = NumberType | ReferenceType
""")
def _raise_error524(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueType' rule, at the expression:\n"
    '    NumberType | ReferenceType\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_vec(_text, _pos, element):
    # Rule 'vec'
    # Begin Let
    # let length = u32 in
    # element{length}
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    if _status:
        length = _result
        # Begin List
        # element{length}
        staging14 = []
        while True:
            checkpoint14 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, element, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint14
                break
            staging14.append(_result)
            if (len(staging14) == length):
                break
        if (len(staging14) >= length):
            _result = staging14
            _status = True
        # End List
    # End Let
    yield (_status, _result, _pos)

def _parse_vec(text, pos=0, fullparse=True):
    return _run(text, pos, _try_vec, fullparse)

vec = Rule('vec', _parse_vec, """
    vec(element) = let length = u32 in
    element{length}
""")
def _try_ByteString(_text, _pos, size):
    # Rule 'ByteString'
    # Begin Apply
    # bytechar{size} |> `lambda x: b''.join(x)`
    # Begin List
    # bytechar{size}
    staging15 = []
    while True:
        checkpoint15 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_bytechar, _pos))
        # End Ref
        if not (_status):
            _pos = checkpoint15
            break
        staging15.append(_result)
        if (len(staging15) == size):
            break
    if (len(staging15) >= size):
        _result = staging15
        _status = True
    # End List
    if _status:
        arg2 = _result
        _result = lambda x: b''.join(x)
        _status = True
        _result = _result(arg2)
    # End Apply
    yield (_status, _result, _pos)

def _parse_ByteString(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ByteString, fullparse)

ByteString = Rule('ByteString', _parse_ByteString, """
    ByteString(size) = bytechar{size} |> `lambda x: b''.join(x)`
""")
def _try_ByteVector(_text, _pos):
    # Rule 'ByteVector'
    # Begin Apply
    # vec(bytechar) |> `lambda x: b''.join(x)`
    # Begin Call
    # vec(bytechar)
    func22 = _ParseFunction(_try_vec, (_try_bytechar,), ())
    (_status, _result, _pos) = (yield (3, func22, _pos))
    # End Call
    if _status:
        arg3 = _result
        _result = lambda x: b''.join(x)
        _status = True
        _result = _result(arg3)
    # End Apply
    yield (_status, _result, _pos)

def _parse_ByteVector(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ByteVector, fullparse)

ByteVector = Rule('ByteVector', _parse_ByteVector, """
    ByteVector = vec(bytechar) |> `lambda x: b''.join(x)`
""")
def _try_bytechar(_text, _pos):
    # Rule 'bytechar'
    # Begin Regex
    # /[\\x00-\\xFF]/
    match1 = matcher1(_text, _pos)
    if match1:
        _result = match1.group(0)
        _pos = match1.end()
        _status = True
    else:
        _result = _raise_error544
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_bytechar(text, pos=0, fullparse=True):
    return _run(text, pos, _try_bytechar, fullparse)

bytechar = Rule('bytechar', _parse_bytechar, """
    bytechar = /[\\x00-\\xFF]/
""")
def _raise_error544(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'bytechar' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Name(_text, _pos):
    # Rule 'Name'
    # Begin Apply
    # vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
    # Begin Call
    # vec(bytechar)
    func23 = _ParseFunction(_try_vec, (_try_bytechar,), ())
    (_status, _result, _pos) = (yield (3, func23, _pos))
    # End Call
    if _status:
        arg4 = _result
        _result = lambda x: b''.join(x).decode('utf8')
        _status = True
        _result = _result(arg4)
    # End Apply
    yield (_status, _result, _pos)

def _parse_Name(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Name, fullparse)

Name = Rule('Name', _parse_Name, """
    Name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
""")
class LocatedName(Node):
    """
    class LocatedName {
        start: `_pos`
        name: Name
        end: `_pos`
    }
    """
    _fields = ('start', 'name', 'end')

    def __init__(self, start, name, end):
        Node.__init__(self)
        self.start = start
        self.name = name
        self.end = end

    def __repr__(self):
        return f'LocatedName(start={self.start!r}, name={self.name!r}, end={self.end!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_LocatedName, fullparse)


def _try_LocatedName(_text, _pos):
    # Begin Seq
    start_pos43 = _pos
    while True:
        _result = _pos
        _status = True
        start = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        _result = _pos
        _status = True
        end = _result
        _result = LocatedName(start, name, end)
        _result._metadata.position_info = (start_pos43, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_byte(_text, _pos):
    # Rule 'byte'
    # Begin Apply
    # /[\\x00-\\xFF]/ |> `ord`
    # Begin Regex
    # /[\\x00-\\xFF]/
    match2 = matcher1(_text, _pos)
    if match2:
        _result = match2.group(0)
        _pos = match2.end()
        _status = True
    else:
        _result = _raise_error561
        _status = False
    # End Regex
    if _status:
        arg5 = _result
        _result = ord
        _status = True
        _result = _result(arg5)
    # End Apply
    yield (_status, _result, _pos)

def _parse_byte(text, pos=0, fullparse=True):
    return _run(text, pos, _try_byte, fullparse)

byte = Rule('byte', _parse_byte, """
    byte = /[\\x00-\\xFF]/ |> `ord`
""")
def _raise_error561(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'byte' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_u32(_text, _pos):
    # Rule 'u32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_UnsignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_u32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_u32, fullparse)

u32 = Rule('u32', _parse_u32, """
    u32 = UnsignedInt
""")
def _try_i32(_text, _pos):
    # Rule 'i32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i32, fullparse)

i32 = Rule('i32', _parse_i32, """
    i32 = SignedInt
""")
def _try_i64(_text, _pos):
    # Rule 'i64'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i64, fullparse)

i64 = Rule('i64', _parse_i64, """
    i64 = SignedInt
""")
def _try_f32(_text, _pos):
    # Rule 'f32'
    # Begin Apply
    # /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{4}/
    match3 = matcher2(_text, _pos)
    if match3:
        _result = match3.group(0)
        _pos = match3.end()
        _status = True
    else:
        _result = _raise_error571
        _status = False
    # End Regex
    if _status:
        arg6 = _result
        _result = lambda x: struct.unpack('<f', x)[0]
        _status = True
        _result = _result(arg6)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f32, fullparse)

f32 = Rule('f32', _parse_f32, """
    f32 = /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
""")
def _raise_error571(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{4}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{4}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_f64(_text, _pos):
    # Rule 'f64'
    # Begin Apply
    # /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{8}/
    match4 = matcher3(_text, _pos)
    if match4:
        _result = match4.group(0)
        _pos = match4.end()
        _status = True
    else:
        _result = _raise_error575
        _status = False
    # End Regex
    if _status:
        arg7 = _result
        _result = lambda x: struct.unpack('<d', x)[0]
        _status = True
        _result = _result(arg7)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f64, fullparse)

f64 = Rule('f64', _parse_f64, """
    f64 = /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
""")
def _raise_error575(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{8}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{8}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_SignedInt(_text, _pos):
    # Rule 'SignedInt'
    # Begin Apply
    # LEB128 |> `decode_signed_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg8 = _result
        _result = decode_signed_int
        _status = True
        _result = _result(arg8)
    # End Apply
    yield (_status, _result, _pos)

def _parse_SignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_SignedInt, fullparse)

SignedInt = Rule('SignedInt', _parse_SignedInt, """
    SignedInt = LEB128 |> `decode_signed_int`
""")
def _try_UnsignedInt(_text, _pos):
    # Rule 'UnsignedInt'
    # Begin Apply
    # LEB128 |> `decode_unsigned_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg9 = _result
        _result = decode_unsigned_int
        _status = True
        _result = _result(arg9)
    # End Apply
    yield (_status, _result, _pos)

def _parse_UnsignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_UnsignedInt, fullparse)

UnsignedInt = Rule('UnsignedInt', _parse_UnsignedInt, """
    UnsignedInt = LEB128 |> `decode_unsigned_int`
""")
def _try_LEB128(_text, _pos):
    # Rule 'LEB128'
    # Begin Regex
    # /[\\x80-\\xFF]*[\\x00-\\x7F]/
    match5 = matcher4(_text, _pos)
    if match5:
        _result = match5.group(0)
        _pos = match5.end()
        _status = True
    else:
        _result = _raise_error586
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LEB128(text, pos=0, fullparse=True):
    return _run(text, pos, _try_LEB128, fullparse)

LEB128 = Rule('LEB128', _parse_LEB128, """
    LEB128 = /[\\x80-\\xFF]*[\\x00-\\x7F]/
""")
def _raise_error586(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LEB128' rule, at the expression:\n"
    '    /[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]/\n\n'
    "Expected to match the regular expression /b'[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]'/"
    )
    raise ParseError((title + details), _pos, line, col)

class CodeEntry(Node):
    """
    class CodeEntry {
        let size: u32
        locals: vec(Locals)
        expression: Expression
    }
    """
    _fields = ('locals', 'expression')

    def __init__(self, locals, expression):
        Node.__init__(self)
        self.locals = locals
        self.expression = expression

    def __repr__(self):
        return f'CodeEntry(locals={self.locals!r}, expression={self.expression!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CodeEntry, fullparse)


def _try_CodeEntry(_text, _pos):
    # Begin Seq
    start_pos44 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Locals)
        func24 = _ParseFunction(_try_vec, (_try_Locals,), ())
        (_status, _result, _pos) = (yield (3, func24, _pos))
        # End Call
        if not (_status):
            break
        locals = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        expression = _result
        _result = CodeEntry(locals, expression)
        _result._metadata.position_info = (start_pos44, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Locals(Node):
    """
    class Locals {
        count: u32
        type: ValueType
    }
    """
    _fields = ('count', 'type')

    def __init__(self, count, type):
        Node.__init__(self)
        self.count = count
        self.type = type

    def __repr__(self):
        return f'Locals(count={self.count!r}, type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Locals, fullparse)


def _try_Locals(_text, _pos):
    # Begin Seq
    start_pos45 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        count = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ValueType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = Locals(count, type)
        _result._metadata.position_info = (start_pos45, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_Expression(_text, _pos):
    # Rule 'Expression'
    # Begin Discard
    # Instruction* << 0xb
    while True:
        # Begin List
        # Instruction*
        staging16 = []
        while True:
            checkpoint16 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_Instruction, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint16
                break
            staging16.append(_result)
        _result = staging16
        _status = True
        # End List
        staging17 = _result
        # Begin Byte
        # 0xb
        if (_pos < len(_text)) and (_text[_pos] == 11):
            _result = 11
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error607
            _status = False
        # End Byte
        if _status:
            _result = staging17
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_Expression(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Expression, fullparse)

Expression = Rule('Expression', _parse_Expression, """
    Expression = Instruction* << 0xb
""")
def _raise_error607(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Expression' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Instruction(_text, _pos):
    # Rule 'Instruction'
    # Begin Choice
    farthest_err11 = _raise_error609
    backtrack24 = farthest_pos11 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_unreachable, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_nop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Block, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Loop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_If, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_br, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 7:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_br_if, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 8:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_br_table, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 9:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ret, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 10:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_call, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 11:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_call_indirect, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 12:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ref_null, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 13:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ref_is_null, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 14:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ref_func, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 15:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_drop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 16:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_select, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 17:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_select_t, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 18:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_local_get, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 19:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_local_set, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 20:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_local_tee, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 21:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_global_get, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 22:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_global_set, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 23:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_get, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 24:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_set, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 25:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_load, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 26:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 27:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_load, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 28:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_load, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 29:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_load8_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 30:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_load8_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 31:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_load16_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 32:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_load16_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 33:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load8_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 34:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load8_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 35:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load16_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 36:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load16_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 37:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 38:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_load32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 39:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_store, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 40:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_store, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 41:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_store, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 42:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_store, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 43:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_store8, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 44:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_store16, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 45:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_store8, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 46:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_store16, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 47:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_store32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 48:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_memory_size, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 49:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_memory_grow, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 50:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_const, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 51:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_const, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 52:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_const, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 53:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_const, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 54:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_eqz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 55:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_eq, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 56:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_ne, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 57:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_lt_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 58:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_lt_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 59:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_gt_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 60:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_gt_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 61:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_le_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 62:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_le_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 63:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_ge_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 64:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_ge_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 65:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_eqz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 66:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_eq, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 67:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_ne, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 68:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_lt_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 69:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_lt_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 70:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_gt_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 71:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_gt_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 72:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_le_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 73:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_le_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 74:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_ge_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 75:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_ge_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 76:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_eq, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 77:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_ne, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 78:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_lt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 79:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_gt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 80:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_le, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 81:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_ge, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 82:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_eq, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 83:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_ne, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 84:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_lt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 85:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_gt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 86:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_le, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 87:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_ge, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 88:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_clz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 89:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_ctz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 90:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_popcnt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 91:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_add, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 92:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_sub, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 93:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_mul, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 94:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_div_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 95:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_div_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 96:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_rem_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 97:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_rem_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 98:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_and, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 99:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_or, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 100:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_xor, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 101:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_shl, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 102:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_shr_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 103:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_shr_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 104:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_rotl, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 105:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_rotr, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 106:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_clz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 107:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_ctz, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 108:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_popcnt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 109:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_add, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 110:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_sub, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 111:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_mul, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 112:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_div_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 113:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_div_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 114:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_rem_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 115:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_rem_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 116:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_and, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 117:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_or, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 118:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_xor, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 119:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_shl, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 120:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_shr_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 121:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_shr_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 122:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_rotl, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 123:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_rotr, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 124:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_abs, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 125:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_neg, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 126:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_ceil, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 127:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_floor, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 128:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_trunc, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 129:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_nearest, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 130:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_sqrt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 131:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_add, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 132:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_sub, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 133:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_mul, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 134:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_div, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 135:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_min, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 136:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_max, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 137:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_copysign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 138:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_abs, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 139:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_neg, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 140:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_ceil, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 141:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_floor, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 142:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_trunc, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 143:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_nearest, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 144:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_sqrt, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 145:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_add, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 146:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_sub, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 147:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_mul, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 148:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_div, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 149:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_min, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 150:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_max, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 151:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_copysign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 152:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_wrap_i64, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 153:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_f32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 154:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_f32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 155:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_f64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 156:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_f64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 157:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_extend_i32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 158:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_extend_i32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 159:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_f32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 160:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_f32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 161:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_f64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 162:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_f64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 163:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_convert_i32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 164:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_convert_i32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 165:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_convert_i64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 166:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_convert_i64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 167:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_demote_f64, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 168:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_convert_i32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 169:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_convert_i32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 170:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_convert_i64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 171:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_convert_i64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 172:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_promote_f32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 173:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_reinterpret_f32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 174:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_reinterpret_f64, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 175:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32_reinterpret_i32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 176:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64_reinterpret_i64, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 177:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_extend8_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 178:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_extend16_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 179:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_extend8_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 180:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_extend16_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 181:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_extend32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 182:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_sat_f32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 183:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_sat_f32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 184:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_sat_f64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 185:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32_trunc_sat_f64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 186:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_sat_f32_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 187:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_sat_f32_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 188:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_sat_f64_s, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 189:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64_trunc_sat_f64_u, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 190:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_memory_init, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 191:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_data_drop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 192:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_memory_copy, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 193:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_memory_fill, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 194:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_init, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 195:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_elem_drop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 196:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_copy, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 197:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_grow, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 198:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_size, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = backtrack24
        # Option 199:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_table_fill, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos11 < _pos):
            farthest_pos11 = _pos
            farthest_err11 = _result
        _pos = farthest_pos11
        _result = farthest_err11
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Instruction(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Instruction, fullparse)

Instruction = Rule('Instruction', _parse_Instruction, """
    Instruction = unreachable | nop | Block | Loop | If | br | br_if | br_table | ret | call | call_indirect | ref_null | ref_is_null | ref_func | drop | select | select_t | local_get | local_set | local_tee | global_get | global_set | table_get | table_set | i32_load | i64_load | f32_load | f64_load | i32_load8_s | i32_load8_u | i32_load16_s | i32_load16_u | i64_load8_s | i64_load8_u | i64_load16_s | i64_load16_u | i64_load32_s | i64_load32_u | i32_store | i64_store | f32_store | f64_store | i32_store8 | i32_store16 | i64_store8 | i64_store16 | i64_store32 | memory_size | memory_grow | i32_const | i64_const | f32_const | f64_const | i32_eqz | i32_eq | i32_ne | i32_lt_s | i32_lt_u | i32_gt_s | i32_gt_u | i32_le_s | i32_le_u | i32_ge_s | i32_ge_u | i64_eqz | i64_eq | i64_ne | i64_lt_s | i64_lt_u | i64_gt_s | i64_gt_u | i64_le_s | i64_le_u | i64_ge_s | i64_ge_u | f32_eq | f32_ne | f32_lt | f32_gt | f32_le | f32_ge | f64_eq | f64_ne | f64_lt | f64_gt | f64_le | f64_ge | i32_clz | i32_ctz | i32_popcnt | i32_add | i32_sub | i32_mul | i32_div_s | i32_div_u | i32_rem_s | i32_rem_u | i32_and | i32_or | i32_xor | i32_shl | i32_shr_s | i32_shr_u | i32_rotl | i32_rotr | i64_clz | i64_ctz | i64_popcnt | i64_add | i64_sub | i64_mul | i64_div_s | i64_div_u | i64_rem_s | i64_rem_u | i64_and | i64_or | i64_xor | i64_shl | i64_shr_s | i64_shr_u | i64_rotl | i64_rotr | f32_abs | f32_neg | f32_ceil | f32_floor | f32_trunc | f32_nearest | f32_sqrt | f32_add | f32_sub | f32_mul | f32_div | f32_min | f32_max | f32_copysign | f64_abs | f64_neg | f64_ceil | f64_floor | f64_trunc | f64_nearest | f64_sqrt | f64_add | f64_sub | f64_mul | f64_div | f64_min | f64_max | f64_copysign | i32_wrap_i64 | i32_trunc_f32_s | i32_trunc_f32_u | i32_trunc_f64_s | i32_trunc_f64_u | i64_extend_i32_s | i64_extend_i32_u | i64_trunc_f32_s | i64_trunc_f32_u | i64_trunc_f64_s | i64_trunc_f64_u | f32_convert_i32_s | f32_convert_i32_u | f32_convert_i64_s | f32_convert_i64_u | f32_demote_f64 | f64_convert_i32_s | f64_convert_i32_u | f64_convert_i64_s | f64_convert_i64_u | f64_promote_f32 | i32_reinterpret_f32 | i64_reinterpret_f64 | f32_reinterpret_i32 | f64_reinterpret_i64 | i32_extend8_s | i32_extend16_s | i64_extend8_s | i64_extend16_s | i64_extend32_s | i32_trunc_sat_f32_s | i32_trunc_sat_f32_u | i32_trunc_sat_f64_s | i32_trunc_sat_f64_u | i64_trunc_sat_f32_s | i64_trunc_sat_f32_u | i64_trunc_sat_f64_s | i64_trunc_sat_f64_u | memory_init | data_drop | memory_copy | memory_fill | table_init | elem_drop | table_copy | table_grow | table_size | table_fill
""")
def _raise_error609(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Instruction' rule, at the expression:\n"
    '    unreachable | nop | Block | Loop | If | br | br_if | br_table | ret | call | call_indirect | ref_null | ref_is_null | ref_func | drop | select | select_t | local_get | local_set | local_tee | global_get | global_set | table_get | table_set | i32_load | i64_load | f32_load | f64_load | i32_load8_s | i32_load8_u | i32_load16_s | i32_load16_u | i64_load8_s | i64_load8_u | i64_load16_s | i64_load16_u | i64_load32_s | i64_load32_u | i32_store | i64_store | f32_store | f64_store | i32_store8 | i32_store16 | i64_store8 | i64_store16 | i64_store32 | memory_size | memory_grow | i32_const | i64_const | f32_const | f64_const | i32_eqz | i32_eq | i32_ne | i32_lt_s | i32_lt_u | i32_gt_s | i32_gt_u | i32_le_s | i32_le_u | i32_ge_s | i32_ge_u | i64_eqz | i64_eq | i64_ne | i64_lt_s | i64_lt_u | i64_gt_s | i64_gt_u | i64_le_s | i64_le_u | i64_ge_s | i64_ge_u | f32_eq | f32_ne | f32_lt | f32_gt | f32_le | f32_ge | f64_eq | f64_ne | f64_lt | f64_gt | f64_le | f64_ge | i32_clz | i32_ctz | i32_popcnt | i32_add | i32_sub | i32_mul | i32_div_s | i32_div_u | i32_rem_s | i32_rem_u | i32_and | i32_or | i32_xor | i32_shl | i32_shr_s | i32_shr_u | i32_rotl | i32_rotr | i64_clz | i64_ctz | i64_popcnt | i64_add | i64_sub | i64_mul | i64_div_s | i64_div_u | i64_rem_s | i64_rem_u | i64_and | i64_or | i64_xor | i64_shl | i64_shr_s | i64_shr_u | i64_rotl | i64_rotr | f32_abs | f32_neg | f32_ceil | f32_floor | f32_trunc | f32_nearest | f32_sqrt | f32_add | f32_sub | f32_mul | f32_div | f32_min | f32_max | f32_copysign | f64_abs | f64_neg | f64_ceil | f64_floor | f64_trunc | f64_nearest | f64_sqrt | f64_add | f64_sub | f64_mul | f64_div | f64_min | f64_max | f64_copysign | i32_wrap_i64 | i32_trunc_f32_s | i32_trunc_f32_u | i32_trunc_f64_s | i32_trunc_f64_u | i64_extend_i32_s | i64_extend_i32_u | i64_trunc_f32_s | i64_trunc_f32_u | i64_trunc_f64_s | i64_trunc_f64_u | f32_convert_i32_s | f32_convert_i32_u | f32_convert_i64_s | f32_convert_i64_u | f32_demote_f64 | f64_convert_i32_s | f64_convert_i32_u | f64_convert_i64_s | f64_convert_i64_u | f64_promote_f32 | i32_reinterpret_f32 | i64_reinterpret_f64 | f32_reinterpret_i32 | f64_reinterpret_i64 | i32_extend8_s | i32_extend16_s | i64_extend8_s | i64_extend16_s | i64_extend32_s | i32_trunc_sat_f32_s | i32_trunc_sat_f32_u | i32_trunc_sat_f64_s | i32_trunc_sat_f64_u | i64_trunc_sat_f32_s | i64_trunc_sat_f32_u | i64_trunc_sat_f64_s | i64_trunc_sat_f64_u | memory_init | data_drop | memory_copy | memory_fill | table_init | elem_drop | table_copy | table_grow | table_size | table_fill\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class unreachable(Node):
    """
    class unreachable {
        let id: 0x0
    }
    """
    _fields = ()

    id = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'unreachable()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_unreachable, fullparse)


def _try_unreachable(_text, _pos):
    # Begin Seq
    start_pos46 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error812
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = unreachable()
        _result._metadata.position_info = (start_pos46, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error812(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'unreachable' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class nop(Node):
    """
    class nop {
        let id: 0x1
    }
    """
    _fields = ()

    id = 0x1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'nop()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_nop, fullparse)


def _try_nop(_text, _pos):
    # Begin Seq
    start_pos47 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error816
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = nop()
        _result._metadata.position_info = (start_pos47, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error816(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'nop' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class Block(Node):
    """
    class Block {
        let id: 0x2
        type: BlockType
        body: Expression
    }
    """
    _fields = ('type', 'body')

    id = 0x2

    def __init__(self, type, body):
        Node.__init__(self)
        self.type = type
        self.body = body

    def __repr__(self):
        return f'Block(type={self.type!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Block, fullparse)


def _try_Block(_text, _pos):
    # Begin Seq
    start_pos48 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error820
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_BlockType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        body = _result
        _result = Block(type, body)
        _result._metadata.position_info = (start_pos48, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error820(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Block' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class Loop(Node):
    """
    class Loop {
        let id: 0x3
        type: BlockType
        body: Expression
    }
    """
    _fields = ('type', 'body')

    id = 0x3

    def __init__(self, type, body):
        Node.__init__(self)
        self.type = type
        self.body = body

    def __repr__(self):
        return f'Loop(type={self.type!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Loop, fullparse)


def _try_Loop(_text, _pos):
    # Begin Seq
    start_pos49 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error828
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_BlockType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        body = _result
        _result = Loop(type, body)
        _result._metadata.position_info = (start_pos49, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error828(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Loop' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class If(Node):
    """
    class If {
        let id: 0x4
        type: BlockType
        true_case: Instruction* << Expect(0x5 | 0xb)
        false_case: Opt(0x5 >> Instruction*) << 0xb
    }
    """
    _fields = ('type', 'true_case', 'false_case')

    id = 0x4

    def __init__(self, type, true_case, false_case):
        Node.__init__(self)
        self.type = type
        self.true_case = true_case
        self.false_case = false_case

    def __repr__(self):
        return f'If(type={self.type!r}, true_case={self.true_case!r}, false_case={self.false_case!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_If, fullparse)


def _try_If(_text, _pos):
    # Begin Seq
    start_pos50 = _pos
    while True:
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error836
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_BlockType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Discard
        # Instruction* << Expect(0x5 | 0xb)
        while True:
            # Begin List
            # Instruction*
            staging18 = []
            while True:
                checkpoint17 = _pos
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _try_Instruction, _pos))
                # End Ref
                if not (_status):
                    _pos = checkpoint17
                    break
                staging18.append(_result)
            _result = staging18
            _status = True
            # End List
            staging19 = _result
            # Begin Expect
            # Expect(0x5 | 0xb)
            backtrack25 = _pos
            # Begin Choice
            farthest_err12 = _raise_error844
            farthest_pos12 = _pos
            while True:
                # Option 1:
                # Begin Byte
                # 0x5
                if (_pos < len(_text)) and (_text[_pos] == 5):
                    _result = 5
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error845
                    _status = False
                # End Byte
                if _status:
                    break
                # Option 2:
                # Begin Byte
                # 0xb
                if (_pos < len(_text)) and (_text[_pos] == 11):
                    _result = 11
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error846
                    _status = False
                # End Byte
                if _status:
                    break
                _pos = farthest_pos12
                _result = farthest_err12
                break
            # End Choice
            if _status:
                _pos = backtrack25
            # End Expect
            if _status:
                _result = staging19
            break
        # End Discard
        if not (_status):
            break
        true_case = _result
        # Begin Discard
        # Opt(0x5 >> Instruction*) << 0xb
        while True:
            # Begin Opt
            # Opt(0x5 >> Instruction*)
            backtrack26 = _pos
            # Begin Discard
            # 0x5 >> Instruction*
            while True:
                # Begin Byte
                # 0x5
                if (_pos < len(_text)) and (_text[_pos] == 5):
                    _result = 5
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error851
                    _status = False
                # End Byte
                if not (_status):
                    break
                # Begin List
                # Instruction*
                staging20 = []
                while True:
                    checkpoint18 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _try_Instruction, _pos))
                    # End Ref
                    if not (_status):
                        _pos = checkpoint18
                        break
                    staging20.append(_result)
                _result = staging20
                _status = True
                # End List
                break
            # End Discard
            if not (_status):
                _pos = backtrack26
                _result = None
                _status = True
            # End Opt
            staging21 = _result
            # Begin Byte
            # 0xb
            if (_pos < len(_text)) and (_text[_pos] == 11):
                _result = 11
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error854
                _status = False
            # End Byte
            if _status:
                _result = staging21
            break
        # End Discard
        if not (_status):
            break
        false_case = _result
        _result = If(type, true_case, false_case)
        _result._metadata.position_info = (start_pos50, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error836(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error844(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0x5 | 0xb\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error845(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error846(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error851(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error854(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

class br(Node):
    """
    class br {
        let id: 0xc
        label: LabelIndex
    }
    """
    _fields = ('label',)

    id = 0xc

    def __init__(self, label):
        Node.__init__(self)
        self.label = label

    def __repr__(self):
        return f'br(label={self.label!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_br, fullparse)


def _try_br(_text, _pos):
    # Begin Seq
    start_pos51 = _pos
    while True:
        # Begin Byte
        # 0xc
        if (_pos < len(_text)) and (_text[_pos] == 12):
            _result = 12
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error858
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LabelIndex, _pos))
        # End Ref
        if not (_status):
            break
        label = _result
        _result = br(label)
        _result._metadata.position_info = (start_pos51, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error858(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'br' rule, at the expression:\n"
    '    0xc\n\n'
    'Expected to match the byte value 0xc'
    )
    raise ParseError((title + details), _pos, line, col)

class br_if(Node):
    """
    class br_if {
        let id: 0xd
        label: LabelIndex
    }
    """
    _fields = ('label',)

    id = 0xd

    def __init__(self, label):
        Node.__init__(self)
        self.label = label

    def __repr__(self):
        return f'br_if(label={self.label!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_br_if, fullparse)


def _try_br_if(_text, _pos):
    # Begin Seq
    start_pos52 = _pos
    while True:
        # Begin Byte
        # 0xd
        if (_pos < len(_text)) and (_text[_pos] == 13):
            _result = 13
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error864
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LabelIndex, _pos))
        # End Ref
        if not (_status):
            break
        label = _result
        _result = br_if(label)
        _result._metadata.position_info = (start_pos52, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error864(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'br_if' rule, at the expression:\n"
    '    0xd\n\n'
    'Expected to match the byte value 0xd'
    )
    raise ParseError((title + details), _pos, line, col)

class br_table(Node):
    """
    class br_table {
        let id: 0xe
        labels: vec(LabelIndex)
        default: LabelIndex
    }
    """
    _fields = ('labels', 'default')

    id = 0xe

    def __init__(self, labels, default):
        Node.__init__(self)
        self.labels = labels
        self.default = default

    def __repr__(self):
        return f'br_table(labels={self.labels!r}, default={self.default!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_br_table, fullparse)


def _try_br_table(_text, _pos):
    # Begin Seq
    start_pos53 = _pos
    while True:
        # Begin Byte
        # 0xe
        if (_pos < len(_text)) and (_text[_pos] == 14):
            _result = 14
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error870
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Call
        # vec(LabelIndex)
        func25 = _ParseFunction(_try_vec, (_try_LabelIndex,), ())
        (_status, _result, _pos) = (yield (3, func25, _pos))
        # End Call
        if not (_status):
            break
        labels = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LabelIndex, _pos))
        # End Ref
        if not (_status):
            break
        default = _result
        _result = br_table(labels, default)
        _result._metadata.position_info = (start_pos53, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error870(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'br_table' rule, at the expression:\n"
    '    0xe\n\n'
    'Expected to match the byte value 0xe'
    )
    raise ParseError((title + details), _pos, line, col)

class ret(Node):
    """
    class ret {
        let id: 0xf
    }
    """
    _fields = ()

    id = 0xf

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'ret()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ret, fullparse)


def _try_ret(_text, _pos):
    # Begin Seq
    start_pos54 = _pos
    while True:
        # Begin Byte
        # 0xf
        if (_pos < len(_text)) and (_text[_pos] == 15):
            _result = 15
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error880
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = ret()
        _result._metadata.position_info = (start_pos54, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error880(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ret' rule, at the expression:\n"
    '    0xf\n\n'
    'Expected to match the byte value 0xf'
    )
    raise ParseError((title + details), _pos, line, col)

class call(Node):
    """
    class call {
        let id: 0x10
        function: FunctionIndex
    }
    """
    _fields = ('function',)

    id = 0x10

    def __init__(self, function):
        Node.__init__(self)
        self.function = function

    def __repr__(self):
        return f'call(function={self.function!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_call, fullparse)


def _try_call(_text, _pos):
    # Begin Seq
    start_pos55 = _pos
    while True:
        # Begin Byte
        # 0x10
        if (_pos < len(_text)) and (_text[_pos] == 16):
            _result = 16
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error884
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionIndex, _pos))
        # End Ref
        if not (_status):
            break
        function = _result
        _result = call(function)
        _result._metadata.position_info = (start_pos55, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error884(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'call' rule, at the expression:\n"
    '    0x10\n\n'
    'Expected to match the byte value 0x10'
    )
    raise ParseError((title + details), _pos, line, col)

class call_indirect(Node):
    """
    class call_indirect {
        let id: 0x11
        type_index: TypeIndex
        table_index: TableIndex
    }
    """
    _fields = ('type_index', 'table_index')

    id = 0x11

    def __init__(self, type_index, table_index):
        Node.__init__(self)
        self.type_index = type_index
        self.table_index = table_index

    def __repr__(self):
        return f'call_indirect(type_index={self.type_index!r}, table_index={self.table_index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_call_indirect, fullparse)


def _try_call_indirect(_text, _pos):
    # Begin Seq
    start_pos56 = _pos
    while True:
        # Begin Byte
        # 0x11
        if (_pos < len(_text)) and (_text[_pos] == 17):
            _result = 17
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error890
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TypeIndex, _pos))
        # End Ref
        if not (_status):
            break
        type_index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table_index = _result
        _result = call_indirect(type_index, table_index)
        _result._metadata.position_info = (start_pos56, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error890(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'call_indirect' rule, at the expression:\n"
    '    0x11\n\n'
    'Expected to match the byte value 0x11'
    )
    raise ParseError((title + details), _pos, line, col)

class ref_null(Node):
    """
    class ref_null {
        let id: 0xd0
        type: ReferenceType
    }
    """
    _fields = ('type',)

    id = 0xd0

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ref_null(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ref_null, fullparse)


def _try_ref_null(_text, _pos):
    # Begin Seq
    start_pos57 = _pos
    while True:
        # Begin Byte
        # 0xd0
        if (_pos < len(_text)) and (_text[_pos] == 208):
            _result = 208
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error898
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ref_null(type)
        _result._metadata.position_info = (start_pos57, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error898(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ref_null' rule, at the expression:\n"
    '    0xd0\n\n'
    'Expected to match the byte value 0xd0'
    )
    raise ParseError((title + details), _pos, line, col)

class ref_is_null(Node):
    """
    class ref_is_null {
        let id: 0xd1
    }
    """
    _fields = ()

    id = 0xd1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'ref_is_null()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ref_is_null, fullparse)


def _try_ref_is_null(_text, _pos):
    # Begin Seq
    start_pos58 = _pos
    while True:
        # Begin Byte
        # 0xd1
        if (_pos < len(_text)) and (_text[_pos] == 209):
            _result = 209
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error904
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = ref_is_null()
        _result._metadata.position_info = (start_pos58, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error904(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ref_is_null' rule, at the expression:\n"
    '    0xd1\n\n'
    'Expected to match the byte value 0xd1'
    )
    raise ParseError((title + details), _pos, line, col)

class ref_func(Node):
    """
    class ref_func {
        let id: 0xd2
        function: FunctionIndex
    }
    """
    _fields = ('function',)

    id = 0xd2

    def __init__(self, function):
        Node.__init__(self)
        self.function = function

    def __repr__(self):
        return f'ref_func(function={self.function!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ref_func, fullparse)


def _try_ref_func(_text, _pos):
    # Begin Seq
    start_pos59 = _pos
    while True:
        # Begin Byte
        # 0xd2
        if (_pos < len(_text)) and (_text[_pos] == 210):
            _result = 210
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error908
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionIndex, _pos))
        # End Ref
        if not (_status):
            break
        function = _result
        _result = ref_func(function)
        _result._metadata.position_info = (start_pos59, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error908(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ref_func' rule, at the expression:\n"
    '    0xd2\n\n'
    'Expected to match the byte value 0xd2'
    )
    raise ParseError((title + details), _pos, line, col)

class drop(Node):
    """
    class drop {
        let id: 0x1a
    }
    """
    _fields = ()

    id = 0x1a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'drop()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_drop, fullparse)


def _try_drop(_text, _pos):
    # Begin Seq
    start_pos60 = _pos
    while True:
        # Begin Byte
        # 0x1a
        if (_pos < len(_text)) and (_text[_pos] == 26):
            _result = 26
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error914
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = drop()
        _result._metadata.position_info = (start_pos60, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error914(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'drop' rule, at the expression:\n"
    '    0x1a\n\n'
    'Expected to match the byte value 0x1a'
    )
    raise ParseError((title + details), _pos, line, col)

class select(Node):
    """
    class select {
        let id: 0x1b
    }
    """
    _fields = ()

    id = 0x1b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'select()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_select, fullparse)


def _try_select(_text, _pos):
    # Begin Seq
    start_pos61 = _pos
    while True:
        # Begin Byte
        # 0x1b
        if (_pos < len(_text)) and (_text[_pos] == 27):
            _result = 27
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error918
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = select()
        _result._metadata.position_info = (start_pos61, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error918(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'select' rule, at the expression:\n"
    '    0x1b\n\n'
    'Expected to match the byte value 0x1b'
    )
    raise ParseError((title + details), _pos, line, col)

class select_t(Node):
    """
    class select_t {
        let id: 0x1c
        types: vec(ValueType)
    }
    """
    _fields = ('types',)

    id = 0x1c

    def __init__(self, types):
        Node.__init__(self)
        self.types = types

    def __repr__(self):
        return f'select_t(types={self.types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_select_t, fullparse)


def _try_select_t(_text, _pos):
    # Begin Seq
    start_pos62 = _pos
    while True:
        # Begin Byte
        # 0x1c
        if (_pos < len(_text)) and (_text[_pos] == 28):
            _result = 28
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error922
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Call
        # vec(ValueType)
        func26 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func26, _pos))
        # End Call
        if not (_status):
            break
        types = _result
        _result = select_t(types)
        _result._metadata.position_info = (start_pos62, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error922(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'select_t' rule, at the expression:\n"
    '    0x1c\n\n'
    'Expected to match the byte value 0x1c'
    )
    raise ParseError((title + details), _pos, line, col)

class local_get(Node):
    """
    class local_get {
        let id: 0x20
        index: LocalIndex
    }
    """
    _fields = ('index',)

    id = 0x20

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'local_get(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_local_get, fullparse)


def _try_local_get(_text, _pos):
    # Begin Seq
    start_pos63 = _pos
    while True:
        # Begin Byte
        # 0x20
        if (_pos < len(_text)) and (_text[_pos] == 32):
            _result = 32
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error930
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LocalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = local_get(index)
        _result._metadata.position_info = (start_pos63, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error930(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'local_get' rule, at the expression:\n"
    '    0x20\n\n'
    'Expected to match the byte value 0x20'
    )
    raise ParseError((title + details), _pos, line, col)

class local_set(Node):
    """
    class local_set {
        let id: 0x21
        index: LocalIndex
    }
    """
    _fields = ('index',)

    id = 0x21

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'local_set(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_local_set, fullparse)


def _try_local_set(_text, _pos):
    # Begin Seq
    start_pos64 = _pos
    while True:
        # Begin Byte
        # 0x21
        if (_pos < len(_text)) and (_text[_pos] == 33):
            _result = 33
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error936
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LocalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = local_set(index)
        _result._metadata.position_info = (start_pos64, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error936(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'local_set' rule, at the expression:\n"
    '    0x21\n\n'
    'Expected to match the byte value 0x21'
    )
    raise ParseError((title + details), _pos, line, col)

class local_tee(Node):
    """
    class local_tee {
        let id: 0x22
        index: LocalIndex
    }
    """
    _fields = ('index',)

    id = 0x22

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'local_tee(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_local_tee, fullparse)


def _try_local_tee(_text, _pos):
    # Begin Seq
    start_pos65 = _pos
    while True:
        # Begin Byte
        # 0x22
        if (_pos < len(_text)) and (_text[_pos] == 34):
            _result = 34
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error942
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LocalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = local_tee(index)
        _result._metadata.position_info = (start_pos65, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error942(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'local_tee' rule, at the expression:\n"
    '    0x22\n\n'
    'Expected to match the byte value 0x22'
    )
    raise ParseError((title + details), _pos, line, col)

class global_get(Node):
    """
    class global_get {
        let id: 0x23
        index: GlobalIndex
    }
    """
    _fields = ('index',)

    id = 0x23

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'global_get(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_global_get, fullparse)


def _try_global_get(_text, _pos):
    # Begin Seq
    start_pos66 = _pos
    while True:
        # Begin Byte
        # 0x23
        if (_pos < len(_text)) and (_text[_pos] == 35):
            _result = 35
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error948
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = global_get(index)
        _result._metadata.position_info = (start_pos66, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error948(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'global_get' rule, at the expression:\n"
    '    0x23\n\n'
    'Expected to match the byte value 0x23'
    )
    raise ParseError((title + details), _pos, line, col)

class global_set(Node):
    """
    class global_set {
        let id: 0x24
        index: GlobalIndex
    }
    """
    _fields = ('index',)

    id = 0x24

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'global_set(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_global_set, fullparse)


def _try_global_set(_text, _pos):
    # Begin Seq
    start_pos67 = _pos
    while True:
        # Begin Byte
        # 0x24
        if (_pos < len(_text)) and (_text[_pos] == 36):
            _result = 36
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error954
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = global_set(index)
        _result._metadata.position_info = (start_pos67, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error954(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'global_set' rule, at the expression:\n"
    '    0x24\n\n'
    'Expected to match the byte value 0x24'
    )
    raise ParseError((title + details), _pos, line, col)

class table_get(Node):
    """
    class table_get {
        let id: 0x25
        index: TableIndex
    }
    """
    _fields = ('index',)

    id = 0x25

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'table_get(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_get, fullparse)


def _try_table_get(_text, _pos):
    # Begin Seq
    start_pos68 = _pos
    while True:
        # Begin Byte
        # 0x25
        if (_pos < len(_text)) and (_text[_pos] == 37):
            _result = 37
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error960
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = table_get(index)
        _result._metadata.position_info = (start_pos68, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error960(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_get' rule, at the expression:\n"
    '    0x25\n\n'
    'Expected to match the byte value 0x25'
    )
    raise ParseError((title + details), _pos, line, col)

class table_set(Node):
    """
    class table_set {
        let id: 0x26
        index: TableIndex
    }
    """
    _fields = ('index',)

    id = 0x26

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'table_set(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_set, fullparse)


def _try_table_set(_text, _pos):
    # Begin Seq
    start_pos69 = _pos
    while True:
        # Begin Byte
        # 0x26
        if (_pos < len(_text)) and (_text[_pos] == 38):
            _result = 38
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error966
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = table_set(index)
        _result._metadata.position_info = (start_pos69, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error966(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_set' rule, at the expression:\n"
    '    0x26\n\n'
    'Expected to match the byte value 0x26'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_load(Node):
    """
    class i32_load {
        let id: 0x28
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x28

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_load(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_load, fullparse)


def _try_i32_load(_text, _pos):
    # Begin Seq
    start_pos70 = _pos
    while True:
        # Begin Byte
        # 0x28
        if (_pos < len(_text)) and (_text[_pos] == 40):
            _result = 40
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error972
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_load(align, offset)
        _result._metadata.position_info = (start_pos70, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error972(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_load' rule, at the expression:\n"
    '    0x28\n\n'
    'Expected to match the byte value 0x28'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load(Node):
    """
    class i64_load {
        let id: 0x29
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x29

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load, fullparse)


def _try_i64_load(_text, _pos):
    # Begin Seq
    start_pos71 = _pos
    while True:
        # Begin Byte
        # 0x29
        if (_pos < len(_text)) and (_text[_pos] == 41):
            _result = 41
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error980
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load(align, offset)
        _result._metadata.position_info = (start_pos71, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error980(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load' rule, at the expression:\n"
    '    0x29\n\n'
    'Expected to match the byte value 0x29'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_load(Node):
    """
    class f32_load {
        let id: 0x2a
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2a

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'f32_load(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_load, fullparse)


def _try_f32_load(_text, _pos):
    # Begin Seq
    start_pos72 = _pos
    while True:
        # Begin Byte
        # 0x2a
        if (_pos < len(_text)) and (_text[_pos] == 42):
            _result = 42
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error988
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = f32_load(align, offset)
        _result._metadata.position_info = (start_pos72, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error988(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_load' rule, at the expression:\n"
    '    0x2a\n\n'
    'Expected to match the byte value 0x2a'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_load(Node):
    """
    class f64_load {
        let id: 0x2b
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2b

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'f64_load(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_load, fullparse)


def _try_f64_load(_text, _pos):
    # Begin Seq
    start_pos73 = _pos
    while True:
        # Begin Byte
        # 0x2b
        if (_pos < len(_text)) and (_text[_pos] == 43):
            _result = 43
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error996
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = f64_load(align, offset)
        _result._metadata.position_info = (start_pos73, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error996(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_load' rule, at the expression:\n"
    '    0x2b\n\n'
    'Expected to match the byte value 0x2b'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_load8_s(Node):
    """
    class i32_load8_s {
        let id: 0x2c
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2c

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_load8_s(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_load8_s, fullparse)


def _try_i32_load8_s(_text, _pos):
    # Begin Seq
    start_pos74 = _pos
    while True:
        # Begin Byte
        # 0x2c
        if (_pos < len(_text)) and (_text[_pos] == 44):
            _result = 44
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1004
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_load8_s(align, offset)
        _result._metadata.position_info = (start_pos74, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1004(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_load8_s' rule, at the expression:\n"
    '    0x2c\n\n'
    'Expected to match the byte value 0x2c'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_load8_u(Node):
    """
    class i32_load8_u {
        let id: 0x2d
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2d

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_load8_u(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_load8_u, fullparse)


def _try_i32_load8_u(_text, _pos):
    # Begin Seq
    start_pos75 = _pos
    while True:
        # Begin Byte
        # 0x2d
        if (_pos < len(_text)) and (_text[_pos] == 45):
            _result = 45
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1012
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_load8_u(align, offset)
        _result._metadata.position_info = (start_pos75, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1012(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_load8_u' rule, at the expression:\n"
    '    0x2d\n\n'
    'Expected to match the byte value 0x2d'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_load16_s(Node):
    """
    class i32_load16_s {
        let id: 0x2e
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2e

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_load16_s(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_load16_s, fullparse)


def _try_i32_load16_s(_text, _pos):
    # Begin Seq
    start_pos76 = _pos
    while True:
        # Begin Byte
        # 0x2e
        if (_pos < len(_text)) and (_text[_pos] == 46):
            _result = 46
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1020
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_load16_s(align, offset)
        _result._metadata.position_info = (start_pos76, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1020(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_load16_s' rule, at the expression:\n"
    '    0x2e\n\n'
    'Expected to match the byte value 0x2e'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_load16_u(Node):
    """
    class i32_load16_u {
        let id: 0x2f
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x2f

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_load16_u(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_load16_u, fullparse)


def _try_i32_load16_u(_text, _pos):
    # Begin Seq
    start_pos77 = _pos
    while True:
        # Begin Byte
        # 0x2f
        if (_pos < len(_text)) and (_text[_pos] == 47):
            _result = 47
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1028
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_load16_u(align, offset)
        _result._metadata.position_info = (start_pos77, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1028(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_load16_u' rule, at the expression:\n"
    '    0x2f\n\n'
    'Expected to match the byte value 0x2f'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load8_s(Node):
    """
    class i64_load8_s {
        let id: 0x30
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x30

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load8_s(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load8_s, fullparse)


def _try_i64_load8_s(_text, _pos):
    # Begin Seq
    start_pos78 = _pos
    while True:
        # Begin Byte
        # 0x30
        if (_pos < len(_text)) and (_text[_pos] == 48):
            _result = 48
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1036
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load8_s(align, offset)
        _result._metadata.position_info = (start_pos78, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1036(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load8_s' rule, at the expression:\n"
    '    0x30\n\n'
    'Expected to match the byte value 0x30'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load8_u(Node):
    """
    class i64_load8_u {
        let id: 0x31
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x31

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load8_u(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load8_u, fullparse)


def _try_i64_load8_u(_text, _pos):
    # Begin Seq
    start_pos79 = _pos
    while True:
        # Begin Byte
        # 0x31
        if (_pos < len(_text)) and (_text[_pos] == 49):
            _result = 49
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1044
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load8_u(align, offset)
        _result._metadata.position_info = (start_pos79, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1044(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load8_u' rule, at the expression:\n"
    '    0x31\n\n'
    'Expected to match the byte value 0x31'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load16_s(Node):
    """
    class i64_load16_s {
        let id: 0x32
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x32

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load16_s(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load16_s, fullparse)


def _try_i64_load16_s(_text, _pos):
    # Begin Seq
    start_pos80 = _pos
    while True:
        # Begin Byte
        # 0x32
        if (_pos < len(_text)) and (_text[_pos] == 50):
            _result = 50
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1052
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load16_s(align, offset)
        _result._metadata.position_info = (start_pos80, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1052(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load16_s' rule, at the expression:\n"
    '    0x32\n\n'
    'Expected to match the byte value 0x32'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load16_u(Node):
    """
    class i64_load16_u {
        let id: 0x33
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x33

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load16_u(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load16_u, fullparse)


def _try_i64_load16_u(_text, _pos):
    # Begin Seq
    start_pos81 = _pos
    while True:
        # Begin Byte
        # 0x33
        if (_pos < len(_text)) and (_text[_pos] == 51):
            _result = 51
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1060
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load16_u(align, offset)
        _result._metadata.position_info = (start_pos81, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1060(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load16_u' rule, at the expression:\n"
    '    0x33\n\n'
    'Expected to match the byte value 0x33'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load32_s(Node):
    """
    class i64_load32_s {
        let id: 0x34
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x34

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load32_s(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load32_s, fullparse)


def _try_i64_load32_s(_text, _pos):
    # Begin Seq
    start_pos82 = _pos
    while True:
        # Begin Byte
        # 0x34
        if (_pos < len(_text)) and (_text[_pos] == 52):
            _result = 52
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1068
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load32_s(align, offset)
        _result._metadata.position_info = (start_pos82, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1068(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load32_s' rule, at the expression:\n"
    '    0x34\n\n'
    'Expected to match the byte value 0x34'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_load32_u(Node):
    """
    class i64_load32_u {
        let id: 0x35
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x35

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_load32_u(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_load32_u, fullparse)


def _try_i64_load32_u(_text, _pos):
    # Begin Seq
    start_pos83 = _pos
    while True:
        # Begin Byte
        # 0x35
        if (_pos < len(_text)) and (_text[_pos] == 53):
            _result = 53
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1076
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_load32_u(align, offset)
        _result._metadata.position_info = (start_pos83, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1076(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_load32_u' rule, at the expression:\n"
    '    0x35\n\n'
    'Expected to match the byte value 0x35'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_store(Node):
    """
    class i32_store {
        let id: 0x36
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x36

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_store(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_store, fullparse)


def _try_i32_store(_text, _pos):
    # Begin Seq
    start_pos84 = _pos
    while True:
        # Begin Byte
        # 0x36
        if (_pos < len(_text)) and (_text[_pos] == 54):
            _result = 54
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1084
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_store(align, offset)
        _result._metadata.position_info = (start_pos84, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1084(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_store' rule, at the expression:\n"
    '    0x36\n\n'
    'Expected to match the byte value 0x36'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_store(Node):
    """
    class i64_store {
        let id: 0x37
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x37

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_store(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_store, fullparse)


def _try_i64_store(_text, _pos):
    # Begin Seq
    start_pos85 = _pos
    while True:
        # Begin Byte
        # 0x37
        if (_pos < len(_text)) and (_text[_pos] == 55):
            _result = 55
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1092
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_store(align, offset)
        _result._metadata.position_info = (start_pos85, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1092(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_store' rule, at the expression:\n"
    '    0x37\n\n'
    'Expected to match the byte value 0x37'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_store(Node):
    """
    class f32_store {
        let id: 0x38
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x38

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'f32_store(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_store, fullparse)


def _try_f32_store(_text, _pos):
    # Begin Seq
    start_pos86 = _pos
    while True:
        # Begin Byte
        # 0x38
        if (_pos < len(_text)) and (_text[_pos] == 56):
            _result = 56
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1100
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = f32_store(align, offset)
        _result._metadata.position_info = (start_pos86, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1100(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_store' rule, at the expression:\n"
    '    0x38\n\n'
    'Expected to match the byte value 0x38'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_store(Node):
    """
    class f64_store {
        let id: 0x39
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x39

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'f64_store(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_store, fullparse)


def _try_f64_store(_text, _pos):
    # Begin Seq
    start_pos87 = _pos
    while True:
        # Begin Byte
        # 0x39
        if (_pos < len(_text)) and (_text[_pos] == 57):
            _result = 57
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1108
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = f64_store(align, offset)
        _result._metadata.position_info = (start_pos87, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1108(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_store' rule, at the expression:\n"
    '    0x39\n\n'
    'Expected to match the byte value 0x39'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_store8(Node):
    """
    class i32_store8 {
        let id: 0x3a
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x3a

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_store8(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_store8, fullparse)


def _try_i32_store8(_text, _pos):
    # Begin Seq
    start_pos88 = _pos
    while True:
        # Begin Byte
        # 0x3a
        if (_pos < len(_text)) and (_text[_pos] == 58):
            _result = 58
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1116
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_store8(align, offset)
        _result._metadata.position_info = (start_pos88, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1116(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_store8' rule, at the expression:\n"
    '    0x3a\n\n'
    'Expected to match the byte value 0x3a'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_store16(Node):
    """
    class i32_store16 {
        let id: 0x3b
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x3b

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i32_store16(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_store16, fullparse)


def _try_i32_store16(_text, _pos):
    # Begin Seq
    start_pos89 = _pos
    while True:
        # Begin Byte
        # 0x3b
        if (_pos < len(_text)) and (_text[_pos] == 59):
            _result = 59
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1124
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i32_store16(align, offset)
        _result._metadata.position_info = (start_pos89, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1124(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_store16' rule, at the expression:\n"
    '    0x3b\n\n'
    'Expected to match the byte value 0x3b'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_store8(Node):
    """
    class i64_store8 {
        let id: 0x3c
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x3c

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_store8(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_store8, fullparse)


def _try_i64_store8(_text, _pos):
    # Begin Seq
    start_pos90 = _pos
    while True:
        # Begin Byte
        # 0x3c
        if (_pos < len(_text)) and (_text[_pos] == 60):
            _result = 60
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1132
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_store8(align, offset)
        _result._metadata.position_info = (start_pos90, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1132(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_store8' rule, at the expression:\n"
    '    0x3c\n\n'
    'Expected to match the byte value 0x3c'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_store16(Node):
    """
    class i64_store16 {
        let id: 0x3d
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x3d

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_store16(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_store16, fullparse)


def _try_i64_store16(_text, _pos):
    # Begin Seq
    start_pos91 = _pos
    while True:
        # Begin Byte
        # 0x3d
        if (_pos < len(_text)) and (_text[_pos] == 61):
            _result = 61
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1140
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_store16(align, offset)
        _result._metadata.position_info = (start_pos91, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1140(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_store16' rule, at the expression:\n"
    '    0x3d\n\n'
    'Expected to match the byte value 0x3d'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_store32(Node):
    """
    class i64_store32 {
        let id: 0x3e
        align: u32
        offset: u32
    }
    """
    _fields = ('align', 'offset')

    id = 0x3e

    def __init__(self, align, offset):
        Node.__init__(self)
        self.align = align
        self.offset = offset

    def __repr__(self):
        return f'i64_store32(align={self.align!r}, offset={self.offset!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_store32, fullparse)


def _try_i64_store32(_text, _pos):
    # Begin Seq
    start_pos92 = _pos
    while True:
        # Begin Byte
        # 0x3e
        if (_pos < len(_text)) and (_text[_pos] == 62):
            _result = 62
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1148
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        align = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        _result = i64_store32(align, offset)
        _result._metadata.position_info = (start_pos92, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1148(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_store32' rule, at the expression:\n"
    '    0x3e\n\n'
    'Expected to match the byte value 0x3e'
    )
    raise ParseError((title + details), _pos, line, col)

class memory_size(Node):
    """
    class memory_size {
        let id: 0x3f
        let zero: 0x0
    }
    """
    _fields = ()

    id = 0x3f
    zero = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'memory_size()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_memory_size, fullparse)


def _try_memory_size(_text, _pos):
    # Begin Seq
    start_pos93 = _pos
    while True:
        # Begin Byte
        # 0x3f
        if (_pos < len(_text)) and (_text[_pos] == 63):
            _result = 63
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1156
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1158
            _status = False
        # End Byte
        if not (_status):
            break
        zero = _result
        _result = memory_size()
        _result._metadata.position_info = (start_pos93, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1156(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_size' rule, at the expression:\n"
    '    0x3f\n\n'
    'Expected to match the byte value 0x3f'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1158(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_size' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class memory_grow(Node):
    """
    class memory_grow {
        let id: 0x40
        let zero: 0x0
    }
    """
    _fields = ()

    id = 0x40
    zero = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'memory_grow()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_memory_grow, fullparse)


def _try_memory_grow(_text, _pos):
    # Begin Seq
    start_pos94 = _pos
    while True:
        # Begin Byte
        # 0x40
        if (_pos < len(_text)) and (_text[_pos] == 64):
            _result = 64
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1162
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1164
            _status = False
        # End Byte
        if not (_status):
            break
        zero = _result
        _result = memory_grow()
        _result._metadata.position_info = (start_pos94, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1162(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_grow' rule, at the expression:\n"
    '    0x40\n\n'
    'Expected to match the byte value 0x40'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1164(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_grow' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_const(Node):
    """
    class i32_const {
        let id: 0x41
        number: i32
    }
    """
    _fields = ('number',)

    id = 0x41

    def __init__(self, number):
        Node.__init__(self)
        self.number = number

    def __repr__(self):
        return f'i32_const(number={self.number!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_const, fullparse)


def _try_i32_const(_text, _pos):
    # Begin Seq
    start_pos95 = _pos
    while True:
        # Begin Byte
        # 0x41
        if (_pos < len(_text)) and (_text[_pos] == 65):
            _result = 65
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1168
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32, _pos))
        # End Ref
        if not (_status):
            break
        number = _result
        _result = i32_const(number)
        _result._metadata.position_info = (start_pos95, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1168(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_const' rule, at the expression:\n"
    '    0x41\n\n'
    'Expected to match the byte value 0x41'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_const(Node):
    """
    class i64_const {
        let id: 0x42
        number: i64
    }
    """
    _fields = ('number',)

    id = 0x42

    def __init__(self, number):
        Node.__init__(self)
        self.number = number

    def __repr__(self):
        return f'i64_const(number={self.number!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_const, fullparse)


def _try_i64_const(_text, _pos):
    # Begin Seq
    start_pos96 = _pos
    while True:
        # Begin Byte
        # 0x42
        if (_pos < len(_text)) and (_text[_pos] == 66):
            _result = 66
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1174
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i64, _pos))
        # End Ref
        if not (_status):
            break
        number = _result
        _result = i64_const(number)
        _result._metadata.position_info = (start_pos96, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1174(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_const' rule, at the expression:\n"
    '    0x42\n\n'
    'Expected to match the byte value 0x42'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_const(Node):
    """
    class f32_const {
        let id: 0x43
        number: f32
    }
    """
    _fields = ('number',)

    id = 0x43

    def __init__(self, number):
        Node.__init__(self)
        self.number = number

    def __repr__(self):
        return f'f32_const(number={self.number!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_const, fullparse)


def _try_f32_const(_text, _pos):
    # Begin Seq
    start_pos97 = _pos
    while True:
        # Begin Byte
        # 0x43
        if (_pos < len(_text)) and (_text[_pos] == 67):
            _result = 67
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1180
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f32, _pos))
        # End Ref
        if not (_status):
            break
        number = _result
        _result = f32_const(number)
        _result._metadata.position_info = (start_pos97, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1180(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_const' rule, at the expression:\n"
    '    0x43\n\n'
    'Expected to match the byte value 0x43'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_const(Node):
    """
    class f64_const {
        let id: 0x44
        number: f64
    }
    """
    _fields = ('number',)

    id = 0x44

    def __init__(self, number):
        Node.__init__(self)
        self.number = number

    def __repr__(self):
        return f'f64_const(number={self.number!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_const, fullparse)


def _try_f64_const(_text, _pos):
    # Begin Seq
    start_pos98 = _pos
    while True:
        # Begin Byte
        # 0x44
        if (_pos < len(_text)) and (_text[_pos] == 68):
            _result = 68
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1186
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_f64, _pos))
        # End Ref
        if not (_status):
            break
        number = _result
        _result = f64_const(number)
        _result._metadata.position_info = (start_pos98, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1186(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_const' rule, at the expression:\n"
    '    0x44\n\n'
    'Expected to match the byte value 0x44'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_eqz(Node):
    """
    class i32_eqz {
        let id: 0x45
    }
    """
    _fields = ()

    id = 0x45

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_eqz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_eqz, fullparse)


def _try_i32_eqz(_text, _pos):
    # Begin Seq
    start_pos99 = _pos
    while True:
        # Begin Byte
        # 0x45
        if (_pos < len(_text)) and (_text[_pos] == 69):
            _result = 69
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1192
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_eqz()
        _result._metadata.position_info = (start_pos99, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1192(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_eqz' rule, at the expression:\n"
    '    0x45\n\n'
    'Expected to match the byte value 0x45'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_eq(Node):
    """
    class i32_eq {
        let id: 0x46
    }
    """
    _fields = ()

    id = 0x46

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_eq()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_eq, fullparse)


def _try_i32_eq(_text, _pos):
    # Begin Seq
    start_pos100 = _pos
    while True:
        # Begin Byte
        # 0x46
        if (_pos < len(_text)) and (_text[_pos] == 70):
            _result = 70
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1196
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_eq()
        _result._metadata.position_info = (start_pos100, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1196(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_eq' rule, at the expression:\n"
    '    0x46\n\n'
    'Expected to match the byte value 0x46'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_ne(Node):
    """
    class i32_ne {
        let id: 0x47
    }
    """
    _fields = ()

    id = 0x47

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_ne()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_ne, fullparse)


def _try_i32_ne(_text, _pos):
    # Begin Seq
    start_pos101 = _pos
    while True:
        # Begin Byte
        # 0x47
        if (_pos < len(_text)) and (_text[_pos] == 71):
            _result = 71
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1200
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_ne()
        _result._metadata.position_info = (start_pos101, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1200(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_ne' rule, at the expression:\n"
    '    0x47\n\n'
    'Expected to match the byte value 0x47'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_lt_s(Node):
    """
    class i32_lt_s {
        let id: 0x48
    }
    """
    _fields = ()

    id = 0x48

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_lt_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_lt_s, fullparse)


def _try_i32_lt_s(_text, _pos):
    # Begin Seq
    start_pos102 = _pos
    while True:
        # Begin Byte
        # 0x48
        if (_pos < len(_text)) and (_text[_pos] == 72):
            _result = 72
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1204
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_lt_s()
        _result._metadata.position_info = (start_pos102, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1204(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_lt_s' rule, at the expression:\n"
    '    0x48\n\n'
    'Expected to match the byte value 0x48'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_lt_u(Node):
    """
    class i32_lt_u {
        let id: 0x49
    }
    """
    _fields = ()

    id = 0x49

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_lt_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_lt_u, fullparse)


def _try_i32_lt_u(_text, _pos):
    # Begin Seq
    start_pos103 = _pos
    while True:
        # Begin Byte
        # 0x49
        if (_pos < len(_text)) and (_text[_pos] == 73):
            _result = 73
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1208
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_lt_u()
        _result._metadata.position_info = (start_pos103, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1208(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_lt_u' rule, at the expression:\n"
    '    0x49\n\n'
    'Expected to match the byte value 0x49'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_gt_s(Node):
    """
    class i32_gt_s {
        let id: 0x4a
    }
    """
    _fields = ()

    id = 0x4a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_gt_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_gt_s, fullparse)


def _try_i32_gt_s(_text, _pos):
    # Begin Seq
    start_pos104 = _pos
    while True:
        # Begin Byte
        # 0x4a
        if (_pos < len(_text)) and (_text[_pos] == 74):
            _result = 74
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1212
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_gt_s()
        _result._metadata.position_info = (start_pos104, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1212(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_gt_s' rule, at the expression:\n"
    '    0x4a\n\n'
    'Expected to match the byte value 0x4a'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_gt_u(Node):
    """
    class i32_gt_u {
        let id: 0x4b
    }
    """
    _fields = ()

    id = 0x4b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_gt_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_gt_u, fullparse)


def _try_i32_gt_u(_text, _pos):
    # Begin Seq
    start_pos105 = _pos
    while True:
        # Begin Byte
        # 0x4b
        if (_pos < len(_text)) and (_text[_pos] == 75):
            _result = 75
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1216
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_gt_u()
        _result._metadata.position_info = (start_pos105, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1216(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_gt_u' rule, at the expression:\n"
    '    0x4b\n\n'
    'Expected to match the byte value 0x4b'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_le_s(Node):
    """
    class i32_le_s {
        let id: 0x4c
    }
    """
    _fields = ()

    id = 0x4c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_le_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_le_s, fullparse)


def _try_i32_le_s(_text, _pos):
    # Begin Seq
    start_pos106 = _pos
    while True:
        # Begin Byte
        # 0x4c
        if (_pos < len(_text)) and (_text[_pos] == 76):
            _result = 76
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1220
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_le_s()
        _result._metadata.position_info = (start_pos106, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1220(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_le_s' rule, at the expression:\n"
    '    0x4c\n\n'
    'Expected to match the byte value 0x4c'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_le_u(Node):
    """
    class i32_le_u {
        let id: 0x4d
    }
    """
    _fields = ()

    id = 0x4d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_le_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_le_u, fullparse)


def _try_i32_le_u(_text, _pos):
    # Begin Seq
    start_pos107 = _pos
    while True:
        # Begin Byte
        # 0x4d
        if (_pos < len(_text)) and (_text[_pos] == 77):
            _result = 77
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1224
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_le_u()
        _result._metadata.position_info = (start_pos107, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1224(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_le_u' rule, at the expression:\n"
    '    0x4d\n\n'
    'Expected to match the byte value 0x4d'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_ge_s(Node):
    """
    class i32_ge_s {
        let id: 0x4e
    }
    """
    _fields = ()

    id = 0x4e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_ge_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_ge_s, fullparse)


def _try_i32_ge_s(_text, _pos):
    # Begin Seq
    start_pos108 = _pos
    while True:
        # Begin Byte
        # 0x4e
        if (_pos < len(_text)) and (_text[_pos] == 78):
            _result = 78
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1228
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_ge_s()
        _result._metadata.position_info = (start_pos108, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1228(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_ge_s' rule, at the expression:\n"
    '    0x4e\n\n'
    'Expected to match the byte value 0x4e'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_ge_u(Node):
    """
    class i32_ge_u {
        let id: 0x4f
    }
    """
    _fields = ()

    id = 0x4f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_ge_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_ge_u, fullparse)


def _try_i32_ge_u(_text, _pos):
    # Begin Seq
    start_pos109 = _pos
    while True:
        # Begin Byte
        # 0x4f
        if (_pos < len(_text)) and (_text[_pos] == 79):
            _result = 79
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1232
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_ge_u()
        _result._metadata.position_info = (start_pos109, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1232(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_ge_u' rule, at the expression:\n"
    '    0x4f\n\n'
    'Expected to match the byte value 0x4f'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_eqz(Node):
    """
    class i64_eqz {
        let id: 0x50
    }
    """
    _fields = ()

    id = 0x50

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_eqz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_eqz, fullparse)


def _try_i64_eqz(_text, _pos):
    # Begin Seq
    start_pos110 = _pos
    while True:
        # Begin Byte
        # 0x50
        if (_pos < len(_text)) and (_text[_pos] == 80):
            _result = 80
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1236
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_eqz()
        _result._metadata.position_info = (start_pos110, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1236(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_eqz' rule, at the expression:\n"
    '    0x50\n\n'
    'Expected to match the byte value 0x50'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_eq(Node):
    """
    class i64_eq {
        let id: 0x51
    }
    """
    _fields = ()

    id = 0x51

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_eq()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_eq, fullparse)


def _try_i64_eq(_text, _pos):
    # Begin Seq
    start_pos111 = _pos
    while True:
        # Begin Byte
        # 0x51
        if (_pos < len(_text)) and (_text[_pos] == 81):
            _result = 81
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1240
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_eq()
        _result._metadata.position_info = (start_pos111, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1240(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_eq' rule, at the expression:\n"
    '    0x51\n\n'
    'Expected to match the byte value 0x51'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_ne(Node):
    """
    class i64_ne {
        let id: 0x52
    }
    """
    _fields = ()

    id = 0x52

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_ne()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_ne, fullparse)


def _try_i64_ne(_text, _pos):
    # Begin Seq
    start_pos112 = _pos
    while True:
        # Begin Byte
        # 0x52
        if (_pos < len(_text)) and (_text[_pos] == 82):
            _result = 82
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1244
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_ne()
        _result._metadata.position_info = (start_pos112, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1244(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_ne' rule, at the expression:\n"
    '    0x52\n\n'
    'Expected to match the byte value 0x52'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_lt_s(Node):
    """
    class i64_lt_s {
        let id: 0x53
    }
    """
    _fields = ()

    id = 0x53

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_lt_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_lt_s, fullparse)


def _try_i64_lt_s(_text, _pos):
    # Begin Seq
    start_pos113 = _pos
    while True:
        # Begin Byte
        # 0x53
        if (_pos < len(_text)) and (_text[_pos] == 83):
            _result = 83
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1248
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_lt_s()
        _result._metadata.position_info = (start_pos113, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1248(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_lt_s' rule, at the expression:\n"
    '    0x53\n\n'
    'Expected to match the byte value 0x53'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_lt_u(Node):
    """
    class i64_lt_u {
        let id: 0x54
    }
    """
    _fields = ()

    id = 0x54

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_lt_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_lt_u, fullparse)


def _try_i64_lt_u(_text, _pos):
    # Begin Seq
    start_pos114 = _pos
    while True:
        # Begin Byte
        # 0x54
        if (_pos < len(_text)) and (_text[_pos] == 84):
            _result = 84
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1252
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_lt_u()
        _result._metadata.position_info = (start_pos114, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1252(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_lt_u' rule, at the expression:\n"
    '    0x54\n\n'
    'Expected to match the byte value 0x54'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_gt_s(Node):
    """
    class i64_gt_s {
        let id: 0x55
    }
    """
    _fields = ()

    id = 0x55

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_gt_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_gt_s, fullparse)


def _try_i64_gt_s(_text, _pos):
    # Begin Seq
    start_pos115 = _pos
    while True:
        # Begin Byte
        # 0x55
        if (_pos < len(_text)) and (_text[_pos] == 85):
            _result = 85
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1256
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_gt_s()
        _result._metadata.position_info = (start_pos115, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1256(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_gt_s' rule, at the expression:\n"
    '    0x55\n\n'
    'Expected to match the byte value 0x55'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_gt_u(Node):
    """
    class i64_gt_u {
        let id: 0x56
    }
    """
    _fields = ()

    id = 0x56

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_gt_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_gt_u, fullparse)


def _try_i64_gt_u(_text, _pos):
    # Begin Seq
    start_pos116 = _pos
    while True:
        # Begin Byte
        # 0x56
        if (_pos < len(_text)) and (_text[_pos] == 86):
            _result = 86
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1260
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_gt_u()
        _result._metadata.position_info = (start_pos116, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1260(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_gt_u' rule, at the expression:\n"
    '    0x56\n\n'
    'Expected to match the byte value 0x56'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_le_s(Node):
    """
    class i64_le_s {
        let id: 0x57
    }
    """
    _fields = ()

    id = 0x57

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_le_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_le_s, fullparse)


def _try_i64_le_s(_text, _pos):
    # Begin Seq
    start_pos117 = _pos
    while True:
        # Begin Byte
        # 0x57
        if (_pos < len(_text)) and (_text[_pos] == 87):
            _result = 87
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1264
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_le_s()
        _result._metadata.position_info = (start_pos117, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1264(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_le_s' rule, at the expression:\n"
    '    0x57\n\n'
    'Expected to match the byte value 0x57'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_le_u(Node):
    """
    class i64_le_u {
        let id: 0x58
    }
    """
    _fields = ()

    id = 0x58

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_le_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_le_u, fullparse)


def _try_i64_le_u(_text, _pos):
    # Begin Seq
    start_pos118 = _pos
    while True:
        # Begin Byte
        # 0x58
        if (_pos < len(_text)) and (_text[_pos] == 88):
            _result = 88
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1268
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_le_u()
        _result._metadata.position_info = (start_pos118, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1268(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_le_u' rule, at the expression:\n"
    '    0x58\n\n'
    'Expected to match the byte value 0x58'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_ge_s(Node):
    """
    class i64_ge_s {
        let id: 0x59
    }
    """
    _fields = ()

    id = 0x59

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_ge_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_ge_s, fullparse)


def _try_i64_ge_s(_text, _pos):
    # Begin Seq
    start_pos119 = _pos
    while True:
        # Begin Byte
        # 0x59
        if (_pos < len(_text)) and (_text[_pos] == 89):
            _result = 89
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1272
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_ge_s()
        _result._metadata.position_info = (start_pos119, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1272(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_ge_s' rule, at the expression:\n"
    '    0x59\n\n'
    'Expected to match the byte value 0x59'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_ge_u(Node):
    """
    class i64_ge_u {
        let id: 0x5a
    }
    """
    _fields = ()

    id = 0x5a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_ge_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_ge_u, fullparse)


def _try_i64_ge_u(_text, _pos):
    # Begin Seq
    start_pos120 = _pos
    while True:
        # Begin Byte
        # 0x5a
        if (_pos < len(_text)) and (_text[_pos] == 90):
            _result = 90
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1276
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_ge_u()
        _result._metadata.position_info = (start_pos120, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1276(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_ge_u' rule, at the expression:\n"
    '    0x5a\n\n'
    'Expected to match the byte value 0x5a'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_eq(Node):
    """
    class f32_eq {
        let id: 0x5b
    }
    """
    _fields = ()

    id = 0x5b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_eq()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_eq, fullparse)


def _try_f32_eq(_text, _pos):
    # Begin Seq
    start_pos121 = _pos
    while True:
        # Begin Byte
        # 0x5b
        if (_pos < len(_text)) and (_text[_pos] == 91):
            _result = 91
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1280
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_eq()
        _result._metadata.position_info = (start_pos121, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1280(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_eq' rule, at the expression:\n"
    '    0x5b\n\n'
    'Expected to match the byte value 0x5b'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_ne(Node):
    """
    class f32_ne {
        let id: 0x5c
    }
    """
    _fields = ()

    id = 0x5c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_ne()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_ne, fullparse)


def _try_f32_ne(_text, _pos):
    # Begin Seq
    start_pos122 = _pos
    while True:
        # Begin Byte
        # 0x5c
        if (_pos < len(_text)) and (_text[_pos] == 92):
            _result = 92
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1284
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_ne()
        _result._metadata.position_info = (start_pos122, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1284(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_ne' rule, at the expression:\n"
    '    0x5c\n\n'
    'Expected to match the byte value 0x5c'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_lt(Node):
    """
    class f32_lt {
        let id: 0x5d
    }
    """
    _fields = ()

    id = 0x5d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_lt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_lt, fullparse)


def _try_f32_lt(_text, _pos):
    # Begin Seq
    start_pos123 = _pos
    while True:
        # Begin Byte
        # 0x5d
        if (_pos < len(_text)) and (_text[_pos] == 93):
            _result = 93
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1288
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_lt()
        _result._metadata.position_info = (start_pos123, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1288(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_lt' rule, at the expression:\n"
    '    0x5d\n\n'
    'Expected to match the byte value 0x5d'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_gt(Node):
    """
    class f32_gt {
        let id: 0x5e
    }
    """
    _fields = ()

    id = 0x5e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_gt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_gt, fullparse)


def _try_f32_gt(_text, _pos):
    # Begin Seq
    start_pos124 = _pos
    while True:
        # Begin Byte
        # 0x5e
        if (_pos < len(_text)) and (_text[_pos] == 94):
            _result = 94
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1292
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_gt()
        _result._metadata.position_info = (start_pos124, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1292(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_gt' rule, at the expression:\n"
    '    0x5e\n\n'
    'Expected to match the byte value 0x5e'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_le(Node):
    """
    class f32_le {
        let id: 0x5f
    }
    """
    _fields = ()

    id = 0x5f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_le()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_le, fullparse)


def _try_f32_le(_text, _pos):
    # Begin Seq
    start_pos125 = _pos
    while True:
        # Begin Byte
        # 0x5f
        if (_pos < len(_text)) and (_text[_pos] == 95):
            _result = 95
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1296
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_le()
        _result._metadata.position_info = (start_pos125, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1296(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_le' rule, at the expression:\n"
    '    0x5f\n\n'
    'Expected to match the byte value 0x5f'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_ge(Node):
    """
    class f32_ge {
        let id: 0x60
    }
    """
    _fields = ()

    id = 0x60

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_ge()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_ge, fullparse)


def _try_f32_ge(_text, _pos):
    # Begin Seq
    start_pos126 = _pos
    while True:
        # Begin Byte
        # 0x60
        if (_pos < len(_text)) and (_text[_pos] == 96):
            _result = 96
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1300
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_ge()
        _result._metadata.position_info = (start_pos126, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1300(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_ge' rule, at the expression:\n"
    '    0x60\n\n'
    'Expected to match the byte value 0x60'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_eq(Node):
    """
    class f64_eq {
        let id: 0x61
    }
    """
    _fields = ()

    id = 0x61

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_eq()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_eq, fullparse)


def _try_f64_eq(_text, _pos):
    # Begin Seq
    start_pos127 = _pos
    while True:
        # Begin Byte
        # 0x61
        if (_pos < len(_text)) and (_text[_pos] == 97):
            _result = 97
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1304
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_eq()
        _result._metadata.position_info = (start_pos127, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1304(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_eq' rule, at the expression:\n"
    '    0x61\n\n'
    'Expected to match the byte value 0x61'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_ne(Node):
    """
    class f64_ne {
        let id: 0x62
    }
    """
    _fields = ()

    id = 0x62

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_ne()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_ne, fullparse)


def _try_f64_ne(_text, _pos):
    # Begin Seq
    start_pos128 = _pos
    while True:
        # Begin Byte
        # 0x62
        if (_pos < len(_text)) and (_text[_pos] == 98):
            _result = 98
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1308
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_ne()
        _result._metadata.position_info = (start_pos128, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1308(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_ne' rule, at the expression:\n"
    '    0x62\n\n'
    'Expected to match the byte value 0x62'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_lt(Node):
    """
    class f64_lt {
        let id: 0x63
    }
    """
    _fields = ()

    id = 0x63

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_lt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_lt, fullparse)


def _try_f64_lt(_text, _pos):
    # Begin Seq
    start_pos129 = _pos
    while True:
        # Begin Byte
        # 0x63
        if (_pos < len(_text)) and (_text[_pos] == 99):
            _result = 99
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1312
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_lt()
        _result._metadata.position_info = (start_pos129, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1312(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_lt' rule, at the expression:\n"
    '    0x63\n\n'
    'Expected to match the byte value 0x63'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_gt(Node):
    """
    class f64_gt {
        let id: 0x64
    }
    """
    _fields = ()

    id = 0x64

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_gt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_gt, fullparse)


def _try_f64_gt(_text, _pos):
    # Begin Seq
    start_pos130 = _pos
    while True:
        # Begin Byte
        # 0x64
        if (_pos < len(_text)) and (_text[_pos] == 100):
            _result = 100
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1316
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_gt()
        _result._metadata.position_info = (start_pos130, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1316(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_gt' rule, at the expression:\n"
    '    0x64\n\n'
    'Expected to match the byte value 0x64'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_le(Node):
    """
    class f64_le {
        let id: 0x65
    }
    """
    _fields = ()

    id = 0x65

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_le()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_le, fullparse)


def _try_f64_le(_text, _pos):
    # Begin Seq
    start_pos131 = _pos
    while True:
        # Begin Byte
        # 0x65
        if (_pos < len(_text)) and (_text[_pos] == 101):
            _result = 101
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1320
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_le()
        _result._metadata.position_info = (start_pos131, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1320(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_le' rule, at the expression:\n"
    '    0x65\n\n'
    'Expected to match the byte value 0x65'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_ge(Node):
    """
    class f64_ge {
        let id: 0x66
    }
    """
    _fields = ()

    id = 0x66

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_ge()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_ge, fullparse)


def _try_f64_ge(_text, _pos):
    # Begin Seq
    start_pos132 = _pos
    while True:
        # Begin Byte
        # 0x66
        if (_pos < len(_text)) and (_text[_pos] == 102):
            _result = 102
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1324
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_ge()
        _result._metadata.position_info = (start_pos132, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1324(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_ge' rule, at the expression:\n"
    '    0x66\n\n'
    'Expected to match the byte value 0x66'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_clz(Node):
    """
    class i32_clz {
        let id: 0x67
    }
    """
    _fields = ()

    id = 0x67

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_clz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_clz, fullparse)


def _try_i32_clz(_text, _pos):
    # Begin Seq
    start_pos133 = _pos
    while True:
        # Begin Byte
        # 0x67
        if (_pos < len(_text)) and (_text[_pos] == 103):
            _result = 103
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1328
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_clz()
        _result._metadata.position_info = (start_pos133, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1328(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_clz' rule, at the expression:\n"
    '    0x67\n\n'
    'Expected to match the byte value 0x67'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_ctz(Node):
    """
    class i32_ctz {
        let id: 0x68
    }
    """
    _fields = ()

    id = 0x68

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_ctz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_ctz, fullparse)


def _try_i32_ctz(_text, _pos):
    # Begin Seq
    start_pos134 = _pos
    while True:
        # Begin Byte
        # 0x68
        if (_pos < len(_text)) and (_text[_pos] == 104):
            _result = 104
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1332
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_ctz()
        _result._metadata.position_info = (start_pos134, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1332(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_ctz' rule, at the expression:\n"
    '    0x68\n\n'
    'Expected to match the byte value 0x68'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_popcnt(Node):
    """
    class i32_popcnt {
        let id: 0x69
    }
    """
    _fields = ()

    id = 0x69

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_popcnt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_popcnt, fullparse)


def _try_i32_popcnt(_text, _pos):
    # Begin Seq
    start_pos135 = _pos
    while True:
        # Begin Byte
        # 0x69
        if (_pos < len(_text)) and (_text[_pos] == 105):
            _result = 105
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1336
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_popcnt()
        _result._metadata.position_info = (start_pos135, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1336(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_popcnt' rule, at the expression:\n"
    '    0x69\n\n'
    'Expected to match the byte value 0x69'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_add(Node):
    """
    class i32_add {
        let id: 0x6a
    }
    """
    _fields = ()

    id = 0x6a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_add()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_add, fullparse)


def _try_i32_add(_text, _pos):
    # Begin Seq
    start_pos136 = _pos
    while True:
        # Begin Byte
        # 0x6a
        if (_pos < len(_text)) and (_text[_pos] == 106):
            _result = 106
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1340
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_add()
        _result._metadata.position_info = (start_pos136, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1340(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_add' rule, at the expression:\n"
    '    0x6a\n\n'
    'Expected to match the byte value 0x6a'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_sub(Node):
    """
    class i32_sub {
        let id: 0x6b
    }
    """
    _fields = ()

    id = 0x6b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_sub()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_sub, fullparse)


def _try_i32_sub(_text, _pos):
    # Begin Seq
    start_pos137 = _pos
    while True:
        # Begin Byte
        # 0x6b
        if (_pos < len(_text)) and (_text[_pos] == 107):
            _result = 107
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1344
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_sub()
        _result._metadata.position_info = (start_pos137, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1344(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_sub' rule, at the expression:\n"
    '    0x6b\n\n'
    'Expected to match the byte value 0x6b'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_mul(Node):
    """
    class i32_mul {
        let id: 0x6c
    }
    """
    _fields = ()

    id = 0x6c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_mul()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_mul, fullparse)


def _try_i32_mul(_text, _pos):
    # Begin Seq
    start_pos138 = _pos
    while True:
        # Begin Byte
        # 0x6c
        if (_pos < len(_text)) and (_text[_pos] == 108):
            _result = 108
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1348
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_mul()
        _result._metadata.position_info = (start_pos138, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1348(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_mul' rule, at the expression:\n"
    '    0x6c\n\n'
    'Expected to match the byte value 0x6c'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_div_s(Node):
    """
    class i32_div_s {
        let id: 0x6d
    }
    """
    _fields = ()

    id = 0x6d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_div_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_div_s, fullparse)


def _try_i32_div_s(_text, _pos):
    # Begin Seq
    start_pos139 = _pos
    while True:
        # Begin Byte
        # 0x6d
        if (_pos < len(_text)) and (_text[_pos] == 109):
            _result = 109
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1352
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_div_s()
        _result._metadata.position_info = (start_pos139, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1352(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_div_s' rule, at the expression:\n"
    '    0x6d\n\n'
    'Expected to match the byte value 0x6d'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_div_u(Node):
    """
    class i32_div_u {
        let id: 0x6e
    }
    """
    _fields = ()

    id = 0x6e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_div_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_div_u, fullparse)


def _try_i32_div_u(_text, _pos):
    # Begin Seq
    start_pos140 = _pos
    while True:
        # Begin Byte
        # 0x6e
        if (_pos < len(_text)) and (_text[_pos] == 110):
            _result = 110
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1356
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_div_u()
        _result._metadata.position_info = (start_pos140, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1356(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_div_u' rule, at the expression:\n"
    '    0x6e\n\n'
    'Expected to match the byte value 0x6e'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_rem_s(Node):
    """
    class i32_rem_s {
        let id: 0x6f
    }
    """
    _fields = ()

    id = 0x6f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_rem_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_rem_s, fullparse)


def _try_i32_rem_s(_text, _pos):
    # Begin Seq
    start_pos141 = _pos
    while True:
        # Begin Byte
        # 0x6f
        if (_pos < len(_text)) and (_text[_pos] == 111):
            _result = 111
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1360
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_rem_s()
        _result._metadata.position_info = (start_pos141, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1360(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_rem_s' rule, at the expression:\n"
    '    0x6f\n\n'
    'Expected to match the byte value 0x6f'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_rem_u(Node):
    """
    class i32_rem_u {
        let id: 0x70
    }
    """
    _fields = ()

    id = 0x70

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_rem_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_rem_u, fullparse)


def _try_i32_rem_u(_text, _pos):
    # Begin Seq
    start_pos142 = _pos
    while True:
        # Begin Byte
        # 0x70
        if (_pos < len(_text)) and (_text[_pos] == 112):
            _result = 112
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1364
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_rem_u()
        _result._metadata.position_info = (start_pos142, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1364(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_rem_u' rule, at the expression:\n"
    '    0x70\n\n'
    'Expected to match the byte value 0x70'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_and(Node):
    """
    class i32_and {
        let id: 0x71
    }
    """
    _fields = ()

    id = 0x71

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_and()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_and, fullparse)


def _try_i32_and(_text, _pos):
    # Begin Seq
    start_pos143 = _pos
    while True:
        # Begin Byte
        # 0x71
        if (_pos < len(_text)) and (_text[_pos] == 113):
            _result = 113
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1368
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_and()
        _result._metadata.position_info = (start_pos143, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1368(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_and' rule, at the expression:\n"
    '    0x71\n\n'
    'Expected to match the byte value 0x71'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_or(Node):
    """
    class i32_or {
        let id: 0x72
    }
    """
    _fields = ()

    id = 0x72

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_or()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_or, fullparse)


def _try_i32_or(_text, _pos):
    # Begin Seq
    start_pos144 = _pos
    while True:
        # Begin Byte
        # 0x72
        if (_pos < len(_text)) and (_text[_pos] == 114):
            _result = 114
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1372
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_or()
        _result._metadata.position_info = (start_pos144, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1372(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_or' rule, at the expression:\n"
    '    0x72\n\n'
    'Expected to match the byte value 0x72'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_xor(Node):
    """
    class i32_xor {
        let id: 0x73
    }
    """
    _fields = ()

    id = 0x73

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_xor()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_xor, fullparse)


def _try_i32_xor(_text, _pos):
    # Begin Seq
    start_pos145 = _pos
    while True:
        # Begin Byte
        # 0x73
        if (_pos < len(_text)) and (_text[_pos] == 115):
            _result = 115
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1376
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_xor()
        _result._metadata.position_info = (start_pos145, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1376(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_xor' rule, at the expression:\n"
    '    0x73\n\n'
    'Expected to match the byte value 0x73'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_shl(Node):
    """
    class i32_shl {
        let id: 0x74
    }
    """
    _fields = ()

    id = 0x74

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_shl()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_shl, fullparse)


def _try_i32_shl(_text, _pos):
    # Begin Seq
    start_pos146 = _pos
    while True:
        # Begin Byte
        # 0x74
        if (_pos < len(_text)) and (_text[_pos] == 116):
            _result = 116
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1380
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_shl()
        _result._metadata.position_info = (start_pos146, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1380(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_shl' rule, at the expression:\n"
    '    0x74\n\n'
    'Expected to match the byte value 0x74'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_shr_s(Node):
    """
    class i32_shr_s {
        let id: 0x75
    }
    """
    _fields = ()

    id = 0x75

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_shr_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_shr_s, fullparse)


def _try_i32_shr_s(_text, _pos):
    # Begin Seq
    start_pos147 = _pos
    while True:
        # Begin Byte
        # 0x75
        if (_pos < len(_text)) and (_text[_pos] == 117):
            _result = 117
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1384
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_shr_s()
        _result._metadata.position_info = (start_pos147, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1384(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_shr_s' rule, at the expression:\n"
    '    0x75\n\n'
    'Expected to match the byte value 0x75'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_shr_u(Node):
    """
    class i32_shr_u {
        let id: 0x76
    }
    """
    _fields = ()

    id = 0x76

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_shr_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_shr_u, fullparse)


def _try_i32_shr_u(_text, _pos):
    # Begin Seq
    start_pos148 = _pos
    while True:
        # Begin Byte
        # 0x76
        if (_pos < len(_text)) and (_text[_pos] == 118):
            _result = 118
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1388
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_shr_u()
        _result._metadata.position_info = (start_pos148, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1388(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_shr_u' rule, at the expression:\n"
    '    0x76\n\n'
    'Expected to match the byte value 0x76'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_rotl(Node):
    """
    class i32_rotl {
        let id: 0x77
    }
    """
    _fields = ()

    id = 0x77

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_rotl()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_rotl, fullparse)


def _try_i32_rotl(_text, _pos):
    # Begin Seq
    start_pos149 = _pos
    while True:
        # Begin Byte
        # 0x77
        if (_pos < len(_text)) and (_text[_pos] == 119):
            _result = 119
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1392
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_rotl()
        _result._metadata.position_info = (start_pos149, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1392(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_rotl' rule, at the expression:\n"
    '    0x77\n\n'
    'Expected to match the byte value 0x77'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_rotr(Node):
    """
    class i32_rotr {
        let id: 0x78
    }
    """
    _fields = ()

    id = 0x78

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_rotr()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_rotr, fullparse)


def _try_i32_rotr(_text, _pos):
    # Begin Seq
    start_pos150 = _pos
    while True:
        # Begin Byte
        # 0x78
        if (_pos < len(_text)) and (_text[_pos] == 120):
            _result = 120
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1396
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_rotr()
        _result._metadata.position_info = (start_pos150, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1396(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_rotr' rule, at the expression:\n"
    '    0x78\n\n'
    'Expected to match the byte value 0x78'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_clz(Node):
    """
    class i64_clz {
        let id: 0x79
    }
    """
    _fields = ()

    id = 0x79

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_clz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_clz, fullparse)


def _try_i64_clz(_text, _pos):
    # Begin Seq
    start_pos151 = _pos
    while True:
        # Begin Byte
        # 0x79
        if (_pos < len(_text)) and (_text[_pos] == 121):
            _result = 121
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1400
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_clz()
        _result._metadata.position_info = (start_pos151, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1400(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_clz' rule, at the expression:\n"
    '    0x79\n\n'
    'Expected to match the byte value 0x79'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_ctz(Node):
    """
    class i64_ctz {
        let id: 0x7a
    }
    """
    _fields = ()

    id = 0x7a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_ctz()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_ctz, fullparse)


def _try_i64_ctz(_text, _pos):
    # Begin Seq
    start_pos152 = _pos
    while True:
        # Begin Byte
        # 0x7a
        if (_pos < len(_text)) and (_text[_pos] == 122):
            _result = 122
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1404
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_ctz()
        _result._metadata.position_info = (start_pos152, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1404(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_ctz' rule, at the expression:\n"
    '    0x7a\n\n'
    'Expected to match the byte value 0x7a'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_popcnt(Node):
    """
    class i64_popcnt {
        let id: 0x7b
    }
    """
    _fields = ()

    id = 0x7b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_popcnt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_popcnt, fullparse)


def _try_i64_popcnt(_text, _pos):
    # Begin Seq
    start_pos153 = _pos
    while True:
        # Begin Byte
        # 0x7b
        if (_pos < len(_text)) and (_text[_pos] == 123):
            _result = 123
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1408
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_popcnt()
        _result._metadata.position_info = (start_pos153, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1408(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_popcnt' rule, at the expression:\n"
    '    0x7b\n\n'
    'Expected to match the byte value 0x7b'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_add(Node):
    """
    class i64_add {
        let id: 0x7c
    }
    """
    _fields = ()

    id = 0x7c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_add()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_add, fullparse)


def _try_i64_add(_text, _pos):
    # Begin Seq
    start_pos154 = _pos
    while True:
        # Begin Byte
        # 0x7c
        if (_pos < len(_text)) and (_text[_pos] == 124):
            _result = 124
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1412
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_add()
        _result._metadata.position_info = (start_pos154, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1412(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_add' rule, at the expression:\n"
    '    0x7c\n\n'
    'Expected to match the byte value 0x7c'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_sub(Node):
    """
    class i64_sub {
        let id: 0x7d
    }
    """
    _fields = ()

    id = 0x7d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_sub()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_sub, fullparse)


def _try_i64_sub(_text, _pos):
    # Begin Seq
    start_pos155 = _pos
    while True:
        # Begin Byte
        # 0x7d
        if (_pos < len(_text)) and (_text[_pos] == 125):
            _result = 125
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1416
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_sub()
        _result._metadata.position_info = (start_pos155, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1416(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_sub' rule, at the expression:\n"
    '    0x7d\n\n'
    'Expected to match the byte value 0x7d'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_mul(Node):
    """
    class i64_mul {
        let id: 0x7e
    }
    """
    _fields = ()

    id = 0x7e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_mul()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_mul, fullparse)


def _try_i64_mul(_text, _pos):
    # Begin Seq
    start_pos156 = _pos
    while True:
        # Begin Byte
        # 0x7e
        if (_pos < len(_text)) and (_text[_pos] == 126):
            _result = 126
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1420
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_mul()
        _result._metadata.position_info = (start_pos156, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1420(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_mul' rule, at the expression:\n"
    '    0x7e\n\n'
    'Expected to match the byte value 0x7e'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_div_s(Node):
    """
    class i64_div_s {
        let id: 0x7f
    }
    """
    _fields = ()

    id = 0x7f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_div_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_div_s, fullparse)


def _try_i64_div_s(_text, _pos):
    # Begin Seq
    start_pos157 = _pos
    while True:
        # Begin Byte
        # 0x7f
        if (_pos < len(_text)) and (_text[_pos] == 127):
            _result = 127
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1424
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_div_s()
        _result._metadata.position_info = (start_pos157, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1424(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_div_s' rule, at the expression:\n"
    '    0x7f\n\n'
    'Expected to match the byte value 0x7f'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_div_u(Node):
    """
    class i64_div_u {
        let id: 0x80
    }
    """
    _fields = ()

    id = 0x80

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_div_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_div_u, fullparse)


def _try_i64_div_u(_text, _pos):
    # Begin Seq
    start_pos158 = _pos
    while True:
        # Begin Byte
        # 0x80
        if (_pos < len(_text)) and (_text[_pos] == 128):
            _result = 128
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1428
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_div_u()
        _result._metadata.position_info = (start_pos158, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1428(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_div_u' rule, at the expression:\n"
    '    0x80\n\n'
    'Expected to match the byte value 0x80'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_rem_s(Node):
    """
    class i64_rem_s {
        let id: 0x81
    }
    """
    _fields = ()

    id = 0x81

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_rem_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_rem_s, fullparse)


def _try_i64_rem_s(_text, _pos):
    # Begin Seq
    start_pos159 = _pos
    while True:
        # Begin Byte
        # 0x81
        if (_pos < len(_text)) and (_text[_pos] == 129):
            _result = 129
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1432
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_rem_s()
        _result._metadata.position_info = (start_pos159, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1432(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_rem_s' rule, at the expression:\n"
    '    0x81\n\n'
    'Expected to match the byte value 0x81'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_rem_u(Node):
    """
    class i64_rem_u {
        let id: 0x82
    }
    """
    _fields = ()

    id = 0x82

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_rem_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_rem_u, fullparse)


def _try_i64_rem_u(_text, _pos):
    # Begin Seq
    start_pos160 = _pos
    while True:
        # Begin Byte
        # 0x82
        if (_pos < len(_text)) and (_text[_pos] == 130):
            _result = 130
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1436
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_rem_u()
        _result._metadata.position_info = (start_pos160, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1436(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_rem_u' rule, at the expression:\n"
    '    0x82\n\n'
    'Expected to match the byte value 0x82'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_and(Node):
    """
    class i64_and {
        let id: 0x83
    }
    """
    _fields = ()

    id = 0x83

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_and()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_and, fullparse)


def _try_i64_and(_text, _pos):
    # Begin Seq
    start_pos161 = _pos
    while True:
        # Begin Byte
        # 0x83
        if (_pos < len(_text)) and (_text[_pos] == 131):
            _result = 131
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1440
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_and()
        _result._metadata.position_info = (start_pos161, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1440(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_and' rule, at the expression:\n"
    '    0x83\n\n'
    'Expected to match the byte value 0x83'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_or(Node):
    """
    class i64_or {
        let id: 0x84
    }
    """
    _fields = ()

    id = 0x84

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_or()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_or, fullparse)


def _try_i64_or(_text, _pos):
    # Begin Seq
    start_pos162 = _pos
    while True:
        # Begin Byte
        # 0x84
        if (_pos < len(_text)) and (_text[_pos] == 132):
            _result = 132
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1444
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_or()
        _result._metadata.position_info = (start_pos162, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1444(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_or' rule, at the expression:\n"
    '    0x84\n\n'
    'Expected to match the byte value 0x84'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_xor(Node):
    """
    class i64_xor {
        let id: 0x85
    }
    """
    _fields = ()

    id = 0x85

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_xor()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_xor, fullparse)


def _try_i64_xor(_text, _pos):
    # Begin Seq
    start_pos163 = _pos
    while True:
        # Begin Byte
        # 0x85
        if (_pos < len(_text)) and (_text[_pos] == 133):
            _result = 133
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1448
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_xor()
        _result._metadata.position_info = (start_pos163, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1448(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_xor' rule, at the expression:\n"
    '    0x85\n\n'
    'Expected to match the byte value 0x85'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_shl(Node):
    """
    class i64_shl {
        let id: 0x86
    }
    """
    _fields = ()

    id = 0x86

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_shl()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_shl, fullparse)


def _try_i64_shl(_text, _pos):
    # Begin Seq
    start_pos164 = _pos
    while True:
        # Begin Byte
        # 0x86
        if (_pos < len(_text)) and (_text[_pos] == 134):
            _result = 134
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1452
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_shl()
        _result._metadata.position_info = (start_pos164, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1452(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_shl' rule, at the expression:\n"
    '    0x86\n\n'
    'Expected to match the byte value 0x86'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_shr_s(Node):
    """
    class i64_shr_s {
        let id: 0x87
    }
    """
    _fields = ()

    id = 0x87

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_shr_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_shr_s, fullparse)


def _try_i64_shr_s(_text, _pos):
    # Begin Seq
    start_pos165 = _pos
    while True:
        # Begin Byte
        # 0x87
        if (_pos < len(_text)) and (_text[_pos] == 135):
            _result = 135
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1456
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_shr_s()
        _result._metadata.position_info = (start_pos165, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1456(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_shr_s' rule, at the expression:\n"
    '    0x87\n\n'
    'Expected to match the byte value 0x87'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_shr_u(Node):
    """
    class i64_shr_u {
        let id: 0x88
    }
    """
    _fields = ()

    id = 0x88

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_shr_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_shr_u, fullparse)


def _try_i64_shr_u(_text, _pos):
    # Begin Seq
    start_pos166 = _pos
    while True:
        # Begin Byte
        # 0x88
        if (_pos < len(_text)) and (_text[_pos] == 136):
            _result = 136
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1460
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_shr_u()
        _result._metadata.position_info = (start_pos166, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1460(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_shr_u' rule, at the expression:\n"
    '    0x88\n\n'
    'Expected to match the byte value 0x88'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_rotl(Node):
    """
    class i64_rotl {
        let id: 0x89
    }
    """
    _fields = ()

    id = 0x89

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_rotl()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_rotl, fullparse)


def _try_i64_rotl(_text, _pos):
    # Begin Seq
    start_pos167 = _pos
    while True:
        # Begin Byte
        # 0x89
        if (_pos < len(_text)) and (_text[_pos] == 137):
            _result = 137
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1464
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_rotl()
        _result._metadata.position_info = (start_pos167, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1464(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_rotl' rule, at the expression:\n"
    '    0x89\n\n'
    'Expected to match the byte value 0x89'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_rotr(Node):
    """
    class i64_rotr {
        let id: 0x8a
    }
    """
    _fields = ()

    id = 0x8a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_rotr()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_rotr, fullparse)


def _try_i64_rotr(_text, _pos):
    # Begin Seq
    start_pos168 = _pos
    while True:
        # Begin Byte
        # 0x8a
        if (_pos < len(_text)) and (_text[_pos] == 138):
            _result = 138
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1468
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_rotr()
        _result._metadata.position_info = (start_pos168, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1468(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_rotr' rule, at the expression:\n"
    '    0x8a\n\n'
    'Expected to match the byte value 0x8a'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_abs(Node):
    """
    class f32_abs {
        let id: 0x8b
    }
    """
    _fields = ()

    id = 0x8b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_abs()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_abs, fullparse)


def _try_f32_abs(_text, _pos):
    # Begin Seq
    start_pos169 = _pos
    while True:
        # Begin Byte
        # 0x8b
        if (_pos < len(_text)) and (_text[_pos] == 139):
            _result = 139
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1472
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_abs()
        _result._metadata.position_info = (start_pos169, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1472(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_abs' rule, at the expression:\n"
    '    0x8b\n\n'
    'Expected to match the byte value 0x8b'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_neg(Node):
    """
    class f32_neg {
        let id: 0x8c
    }
    """
    _fields = ()

    id = 0x8c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_neg()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_neg, fullparse)


def _try_f32_neg(_text, _pos):
    # Begin Seq
    start_pos170 = _pos
    while True:
        # Begin Byte
        # 0x8c
        if (_pos < len(_text)) and (_text[_pos] == 140):
            _result = 140
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1476
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_neg()
        _result._metadata.position_info = (start_pos170, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1476(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_neg' rule, at the expression:\n"
    '    0x8c\n\n'
    'Expected to match the byte value 0x8c'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_ceil(Node):
    """
    class f32_ceil {
        let id: 0x8d
    }
    """
    _fields = ()

    id = 0x8d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_ceil()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_ceil, fullparse)


def _try_f32_ceil(_text, _pos):
    # Begin Seq
    start_pos171 = _pos
    while True:
        # Begin Byte
        # 0x8d
        if (_pos < len(_text)) and (_text[_pos] == 141):
            _result = 141
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1480
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_ceil()
        _result._metadata.position_info = (start_pos171, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1480(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_ceil' rule, at the expression:\n"
    '    0x8d\n\n'
    'Expected to match the byte value 0x8d'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_floor(Node):
    """
    class f32_floor {
        let id: 0x8e
    }
    """
    _fields = ()

    id = 0x8e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_floor()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_floor, fullparse)


def _try_f32_floor(_text, _pos):
    # Begin Seq
    start_pos172 = _pos
    while True:
        # Begin Byte
        # 0x8e
        if (_pos < len(_text)) and (_text[_pos] == 142):
            _result = 142
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1484
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_floor()
        _result._metadata.position_info = (start_pos172, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1484(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_floor' rule, at the expression:\n"
    '    0x8e\n\n'
    'Expected to match the byte value 0x8e'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_trunc(Node):
    """
    class f32_trunc {
        let id: 0x8f
    }
    """
    _fields = ()

    id = 0x8f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_trunc()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_trunc, fullparse)


def _try_f32_trunc(_text, _pos):
    # Begin Seq
    start_pos173 = _pos
    while True:
        # Begin Byte
        # 0x8f
        if (_pos < len(_text)) and (_text[_pos] == 143):
            _result = 143
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1488
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_trunc()
        _result._metadata.position_info = (start_pos173, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1488(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_trunc' rule, at the expression:\n"
    '    0x8f\n\n'
    'Expected to match the byte value 0x8f'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_nearest(Node):
    """
    class f32_nearest {
        let id: 0x90
    }
    """
    _fields = ()

    id = 0x90

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_nearest()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_nearest, fullparse)


def _try_f32_nearest(_text, _pos):
    # Begin Seq
    start_pos174 = _pos
    while True:
        # Begin Byte
        # 0x90
        if (_pos < len(_text)) and (_text[_pos] == 144):
            _result = 144
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1492
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_nearest()
        _result._metadata.position_info = (start_pos174, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1492(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_nearest' rule, at the expression:\n"
    '    0x90\n\n'
    'Expected to match the byte value 0x90'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_sqrt(Node):
    """
    class f32_sqrt {
        let id: 0x91
    }
    """
    _fields = ()

    id = 0x91

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_sqrt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_sqrt, fullparse)


def _try_f32_sqrt(_text, _pos):
    # Begin Seq
    start_pos175 = _pos
    while True:
        # Begin Byte
        # 0x91
        if (_pos < len(_text)) and (_text[_pos] == 145):
            _result = 145
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1496
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_sqrt()
        _result._metadata.position_info = (start_pos175, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1496(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_sqrt' rule, at the expression:\n"
    '    0x91\n\n'
    'Expected to match the byte value 0x91'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_add(Node):
    """
    class f32_add {
        let id: 0x92
    }
    """
    _fields = ()

    id = 0x92

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_add()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_add, fullparse)


def _try_f32_add(_text, _pos):
    # Begin Seq
    start_pos176 = _pos
    while True:
        # Begin Byte
        # 0x92
        if (_pos < len(_text)) and (_text[_pos] == 146):
            _result = 146
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1500
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_add()
        _result._metadata.position_info = (start_pos176, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1500(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_add' rule, at the expression:\n"
    '    0x92\n\n'
    'Expected to match the byte value 0x92'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_sub(Node):
    """
    class f32_sub {
        let id: 0x93
    }
    """
    _fields = ()

    id = 0x93

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_sub()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_sub, fullparse)


def _try_f32_sub(_text, _pos):
    # Begin Seq
    start_pos177 = _pos
    while True:
        # Begin Byte
        # 0x93
        if (_pos < len(_text)) and (_text[_pos] == 147):
            _result = 147
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1504
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_sub()
        _result._metadata.position_info = (start_pos177, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1504(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_sub' rule, at the expression:\n"
    '    0x93\n\n'
    'Expected to match the byte value 0x93'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_mul(Node):
    """
    class f32_mul {
        let id: 0x94
    }
    """
    _fields = ()

    id = 0x94

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_mul()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_mul, fullparse)


def _try_f32_mul(_text, _pos):
    # Begin Seq
    start_pos178 = _pos
    while True:
        # Begin Byte
        # 0x94
        if (_pos < len(_text)) and (_text[_pos] == 148):
            _result = 148
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1508
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_mul()
        _result._metadata.position_info = (start_pos178, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1508(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_mul' rule, at the expression:\n"
    '    0x94\n\n'
    'Expected to match the byte value 0x94'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_div(Node):
    """
    class f32_div {
        let id: 0x95
    }
    """
    _fields = ()

    id = 0x95

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_div()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_div, fullparse)


def _try_f32_div(_text, _pos):
    # Begin Seq
    start_pos179 = _pos
    while True:
        # Begin Byte
        # 0x95
        if (_pos < len(_text)) and (_text[_pos] == 149):
            _result = 149
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1512
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_div()
        _result._metadata.position_info = (start_pos179, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1512(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_div' rule, at the expression:\n"
    '    0x95\n\n'
    'Expected to match the byte value 0x95'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_min(Node):
    """
    class f32_min {
        let id: 0x96
    }
    """
    _fields = ()

    id = 0x96

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_min()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_min, fullparse)


def _try_f32_min(_text, _pos):
    # Begin Seq
    start_pos180 = _pos
    while True:
        # Begin Byte
        # 0x96
        if (_pos < len(_text)) and (_text[_pos] == 150):
            _result = 150
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1516
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_min()
        _result._metadata.position_info = (start_pos180, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1516(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_min' rule, at the expression:\n"
    '    0x96\n\n'
    'Expected to match the byte value 0x96'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_max(Node):
    """
    class f32_max {
        let id: 0x97
    }
    """
    _fields = ()

    id = 0x97

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_max()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_max, fullparse)


def _try_f32_max(_text, _pos):
    # Begin Seq
    start_pos181 = _pos
    while True:
        # Begin Byte
        # 0x97
        if (_pos < len(_text)) and (_text[_pos] == 151):
            _result = 151
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1520
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_max()
        _result._metadata.position_info = (start_pos181, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1520(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_max' rule, at the expression:\n"
    '    0x97\n\n'
    'Expected to match the byte value 0x97'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_copysign(Node):
    """
    class f32_copysign {
        let id: 0x98
    }
    """
    _fields = ()

    id = 0x98

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_copysign()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_copysign, fullparse)


def _try_f32_copysign(_text, _pos):
    # Begin Seq
    start_pos182 = _pos
    while True:
        # Begin Byte
        # 0x98
        if (_pos < len(_text)) and (_text[_pos] == 152):
            _result = 152
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1524
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_copysign()
        _result._metadata.position_info = (start_pos182, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1524(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_copysign' rule, at the expression:\n"
    '    0x98\n\n'
    'Expected to match the byte value 0x98'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_abs(Node):
    """
    class f64_abs {
        let id: 0x99
    }
    """
    _fields = ()

    id = 0x99

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_abs()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_abs, fullparse)


def _try_f64_abs(_text, _pos):
    # Begin Seq
    start_pos183 = _pos
    while True:
        # Begin Byte
        # 0x99
        if (_pos < len(_text)) and (_text[_pos] == 153):
            _result = 153
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1528
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_abs()
        _result._metadata.position_info = (start_pos183, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1528(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_abs' rule, at the expression:\n"
    '    0x99\n\n'
    'Expected to match the byte value 0x99'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_neg(Node):
    """
    class f64_neg {
        let id: 0x9a
    }
    """
    _fields = ()

    id = 0x9a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_neg()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_neg, fullparse)


def _try_f64_neg(_text, _pos):
    # Begin Seq
    start_pos184 = _pos
    while True:
        # Begin Byte
        # 0x9a
        if (_pos < len(_text)) and (_text[_pos] == 154):
            _result = 154
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1532
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_neg()
        _result._metadata.position_info = (start_pos184, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1532(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_neg' rule, at the expression:\n"
    '    0x9a\n\n'
    'Expected to match the byte value 0x9a'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_ceil(Node):
    """
    class f64_ceil {
        let id: 0x9b
    }
    """
    _fields = ()

    id = 0x9b

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_ceil()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_ceil, fullparse)


def _try_f64_ceil(_text, _pos):
    # Begin Seq
    start_pos185 = _pos
    while True:
        # Begin Byte
        # 0x9b
        if (_pos < len(_text)) and (_text[_pos] == 155):
            _result = 155
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1536
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_ceil()
        _result._metadata.position_info = (start_pos185, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1536(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_ceil' rule, at the expression:\n"
    '    0x9b\n\n'
    'Expected to match the byte value 0x9b'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_floor(Node):
    """
    class f64_floor {
        let id: 0x9c
    }
    """
    _fields = ()

    id = 0x9c

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_floor()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_floor, fullparse)


def _try_f64_floor(_text, _pos):
    # Begin Seq
    start_pos186 = _pos
    while True:
        # Begin Byte
        # 0x9c
        if (_pos < len(_text)) and (_text[_pos] == 156):
            _result = 156
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1540
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_floor()
        _result._metadata.position_info = (start_pos186, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1540(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_floor' rule, at the expression:\n"
    '    0x9c\n\n'
    'Expected to match the byte value 0x9c'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_trunc(Node):
    """
    class f64_trunc {
        let id: 0x9d
    }
    """
    _fields = ()

    id = 0x9d

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_trunc()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_trunc, fullparse)


def _try_f64_trunc(_text, _pos):
    # Begin Seq
    start_pos187 = _pos
    while True:
        # Begin Byte
        # 0x9d
        if (_pos < len(_text)) and (_text[_pos] == 157):
            _result = 157
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1544
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_trunc()
        _result._metadata.position_info = (start_pos187, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1544(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_trunc' rule, at the expression:\n"
    '    0x9d\n\n'
    'Expected to match the byte value 0x9d'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_nearest(Node):
    """
    class f64_nearest {
        let id: 0x9e
    }
    """
    _fields = ()

    id = 0x9e

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_nearest()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_nearest, fullparse)


def _try_f64_nearest(_text, _pos):
    # Begin Seq
    start_pos188 = _pos
    while True:
        # Begin Byte
        # 0x9e
        if (_pos < len(_text)) and (_text[_pos] == 158):
            _result = 158
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1548
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_nearest()
        _result._metadata.position_info = (start_pos188, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1548(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_nearest' rule, at the expression:\n"
    '    0x9e\n\n'
    'Expected to match the byte value 0x9e'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_sqrt(Node):
    """
    class f64_sqrt {
        let id: 0x9f
    }
    """
    _fields = ()

    id = 0x9f

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_sqrt()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_sqrt, fullparse)


def _try_f64_sqrt(_text, _pos):
    # Begin Seq
    start_pos189 = _pos
    while True:
        # Begin Byte
        # 0x9f
        if (_pos < len(_text)) and (_text[_pos] == 159):
            _result = 159
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1552
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_sqrt()
        _result._metadata.position_info = (start_pos189, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1552(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_sqrt' rule, at the expression:\n"
    '    0x9f\n\n'
    'Expected to match the byte value 0x9f'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_add(Node):
    """
    class f64_add {
        let id: 0xa0
    }
    """
    _fields = ()

    id = 0xa0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_add()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_add, fullparse)


def _try_f64_add(_text, _pos):
    # Begin Seq
    start_pos190 = _pos
    while True:
        # Begin Byte
        # 0xa0
        if (_pos < len(_text)) and (_text[_pos] == 160):
            _result = 160
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1556
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_add()
        _result._metadata.position_info = (start_pos190, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1556(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_add' rule, at the expression:\n"
    '    0xa0\n\n'
    'Expected to match the byte value 0xa0'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_sub(Node):
    """
    class f64_sub {
        let id: 0xa1
    }
    """
    _fields = ()

    id = 0xa1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_sub()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_sub, fullparse)


def _try_f64_sub(_text, _pos):
    # Begin Seq
    start_pos191 = _pos
    while True:
        # Begin Byte
        # 0xa1
        if (_pos < len(_text)) and (_text[_pos] == 161):
            _result = 161
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1560
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_sub()
        _result._metadata.position_info = (start_pos191, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1560(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_sub' rule, at the expression:\n"
    '    0xa1\n\n'
    'Expected to match the byte value 0xa1'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_mul(Node):
    """
    class f64_mul {
        let id: 0xa2
    }
    """
    _fields = ()

    id = 0xa2

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_mul()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_mul, fullparse)


def _try_f64_mul(_text, _pos):
    # Begin Seq
    start_pos192 = _pos
    while True:
        # Begin Byte
        # 0xa2
        if (_pos < len(_text)) and (_text[_pos] == 162):
            _result = 162
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1564
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_mul()
        _result._metadata.position_info = (start_pos192, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1564(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_mul' rule, at the expression:\n"
    '    0xa2\n\n'
    'Expected to match the byte value 0xa2'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_div(Node):
    """
    class f64_div {
        let id: 0xa3
    }
    """
    _fields = ()

    id = 0xa3

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_div()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_div, fullparse)


def _try_f64_div(_text, _pos):
    # Begin Seq
    start_pos193 = _pos
    while True:
        # Begin Byte
        # 0xa3
        if (_pos < len(_text)) and (_text[_pos] == 163):
            _result = 163
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1568
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_div()
        _result._metadata.position_info = (start_pos193, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1568(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_div' rule, at the expression:\n"
    '    0xa3\n\n'
    'Expected to match the byte value 0xa3'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_min(Node):
    """
    class f64_min {
        let id: 0xa4
    }
    """
    _fields = ()

    id = 0xa4

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_min()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_min, fullparse)


def _try_f64_min(_text, _pos):
    # Begin Seq
    start_pos194 = _pos
    while True:
        # Begin Byte
        # 0xa4
        if (_pos < len(_text)) and (_text[_pos] == 164):
            _result = 164
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1572
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_min()
        _result._metadata.position_info = (start_pos194, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1572(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_min' rule, at the expression:\n"
    '    0xa4\n\n'
    'Expected to match the byte value 0xa4'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_max(Node):
    """
    class f64_max {
        let id: 0xa5
    }
    """
    _fields = ()

    id = 0xa5

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_max()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_max, fullparse)


def _try_f64_max(_text, _pos):
    # Begin Seq
    start_pos195 = _pos
    while True:
        # Begin Byte
        # 0xa5
        if (_pos < len(_text)) and (_text[_pos] == 165):
            _result = 165
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1576
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_max()
        _result._metadata.position_info = (start_pos195, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1576(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_max' rule, at the expression:\n"
    '    0xa5\n\n'
    'Expected to match the byte value 0xa5'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_copysign(Node):
    """
    class f64_copysign {
        let id: 0xa6
    }
    """
    _fields = ()

    id = 0xa6

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_copysign()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_copysign, fullparse)


def _try_f64_copysign(_text, _pos):
    # Begin Seq
    start_pos196 = _pos
    while True:
        # Begin Byte
        # 0xa6
        if (_pos < len(_text)) and (_text[_pos] == 166):
            _result = 166
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1580
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_copysign()
        _result._metadata.position_info = (start_pos196, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1580(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_copysign' rule, at the expression:\n"
    '    0xa6\n\n'
    'Expected to match the byte value 0xa6'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_wrap_i64(Node):
    """
    class i32_wrap_i64 {
        let id: 0xa7
    }
    """
    _fields = ()

    id = 0xa7

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_wrap_i64()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_wrap_i64, fullparse)


def _try_i32_wrap_i64(_text, _pos):
    # Begin Seq
    start_pos197 = _pos
    while True:
        # Begin Byte
        # 0xa7
        if (_pos < len(_text)) and (_text[_pos] == 167):
            _result = 167
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1584
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_wrap_i64()
        _result._metadata.position_info = (start_pos197, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1584(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_wrap_i64' rule, at the expression:\n"
    '    0xa7\n\n'
    'Expected to match the byte value 0xa7'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_f32_s(Node):
    """
    class i32_trunc_f32_s {
        let id: 0xa8
    }
    """
    _fields = ()

    id = 0xa8

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_f32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_f32_s, fullparse)


def _try_i32_trunc_f32_s(_text, _pos):
    # Begin Seq
    start_pos198 = _pos
    while True:
        # Begin Byte
        # 0xa8
        if (_pos < len(_text)) and (_text[_pos] == 168):
            _result = 168
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1588
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_trunc_f32_s()
        _result._metadata.position_info = (start_pos198, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1588(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_f32_s' rule, at the expression:\n"
    '    0xa8\n\n'
    'Expected to match the byte value 0xa8'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_f32_u(Node):
    """
    class i32_trunc_f32_u {
        let id: 0xa9
    }
    """
    _fields = ()

    id = 0xa9

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_f32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_f32_u, fullparse)


def _try_i32_trunc_f32_u(_text, _pos):
    # Begin Seq
    start_pos199 = _pos
    while True:
        # Begin Byte
        # 0xa9
        if (_pos < len(_text)) and (_text[_pos] == 169):
            _result = 169
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1592
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_trunc_f32_u()
        _result._metadata.position_info = (start_pos199, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1592(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_f32_u' rule, at the expression:\n"
    '    0xa9\n\n'
    'Expected to match the byte value 0xa9'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_f64_s(Node):
    """
    class i32_trunc_f64_s {
        let id: 0xaa
    }
    """
    _fields = ()

    id = 0xaa

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_f64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_f64_s, fullparse)


def _try_i32_trunc_f64_s(_text, _pos):
    # Begin Seq
    start_pos200 = _pos
    while True:
        # Begin Byte
        # 0xaa
        if (_pos < len(_text)) and (_text[_pos] == 170):
            _result = 170
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1596
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_trunc_f64_s()
        _result._metadata.position_info = (start_pos200, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1596(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_f64_s' rule, at the expression:\n"
    '    0xaa\n\n'
    'Expected to match the byte value 0xaa'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_f64_u(Node):
    """
    class i32_trunc_f64_u {
        let id: 0xab
    }
    """
    _fields = ()

    id = 0xab

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_f64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_f64_u, fullparse)


def _try_i32_trunc_f64_u(_text, _pos):
    # Begin Seq
    start_pos201 = _pos
    while True:
        # Begin Byte
        # 0xab
        if (_pos < len(_text)) and (_text[_pos] == 171):
            _result = 171
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1600
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_trunc_f64_u()
        _result._metadata.position_info = (start_pos201, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1600(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_f64_u' rule, at the expression:\n"
    '    0xab\n\n'
    'Expected to match the byte value 0xab'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_extend_i32_s(Node):
    """
    class i64_extend_i32_s {
        let id: 0xac
    }
    """
    _fields = ()

    id = 0xac

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_extend_i32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_extend_i32_s, fullparse)


def _try_i64_extend_i32_s(_text, _pos):
    # Begin Seq
    start_pos202 = _pos
    while True:
        # Begin Byte
        # 0xac
        if (_pos < len(_text)) and (_text[_pos] == 172):
            _result = 172
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1604
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_extend_i32_s()
        _result._metadata.position_info = (start_pos202, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1604(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_extend_i32_s' rule, at the expression:\n"
    '    0xac\n\n'
    'Expected to match the byte value 0xac'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_extend_i32_u(Node):
    """
    class i64_extend_i32_u {
        let id: 0xad
    }
    """
    _fields = ()

    id = 0xad

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_extend_i32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_extend_i32_u, fullparse)


def _try_i64_extend_i32_u(_text, _pos):
    # Begin Seq
    start_pos203 = _pos
    while True:
        # Begin Byte
        # 0xad
        if (_pos < len(_text)) and (_text[_pos] == 173):
            _result = 173
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1608
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_extend_i32_u()
        _result._metadata.position_info = (start_pos203, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1608(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_extend_i32_u' rule, at the expression:\n"
    '    0xad\n\n'
    'Expected to match the byte value 0xad'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_f32_s(Node):
    """
    class i64_trunc_f32_s {
        let id: 0xae
    }
    """
    _fields = ()

    id = 0xae

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_f32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_f32_s, fullparse)


def _try_i64_trunc_f32_s(_text, _pos):
    # Begin Seq
    start_pos204 = _pos
    while True:
        # Begin Byte
        # 0xae
        if (_pos < len(_text)) and (_text[_pos] == 174):
            _result = 174
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1612
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_trunc_f32_s()
        _result._metadata.position_info = (start_pos204, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1612(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_f32_s' rule, at the expression:\n"
    '    0xae\n\n'
    'Expected to match the byte value 0xae'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_f32_u(Node):
    """
    class i64_trunc_f32_u {
        let id: 0xaf
    }
    """
    _fields = ()

    id = 0xaf

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_f32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_f32_u, fullparse)


def _try_i64_trunc_f32_u(_text, _pos):
    # Begin Seq
    start_pos205 = _pos
    while True:
        # Begin Byte
        # 0xaf
        if (_pos < len(_text)) and (_text[_pos] == 175):
            _result = 175
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1616
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_trunc_f32_u()
        _result._metadata.position_info = (start_pos205, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1616(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_f32_u' rule, at the expression:\n"
    '    0xaf\n\n'
    'Expected to match the byte value 0xaf'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_f64_s(Node):
    """
    class i64_trunc_f64_s {
        let id: 0xb0
    }
    """
    _fields = ()

    id = 0xb0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_f64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_f64_s, fullparse)


def _try_i64_trunc_f64_s(_text, _pos):
    # Begin Seq
    start_pos206 = _pos
    while True:
        # Begin Byte
        # 0xb0
        if (_pos < len(_text)) and (_text[_pos] == 176):
            _result = 176
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1620
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_trunc_f64_s()
        _result._metadata.position_info = (start_pos206, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1620(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_f64_s' rule, at the expression:\n"
    '    0xb0\n\n'
    'Expected to match the byte value 0xb0'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_f64_u(Node):
    """
    class i64_trunc_f64_u {
        let id: 0xb1
    }
    """
    _fields = ()

    id = 0xb1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_f64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_f64_u, fullparse)


def _try_i64_trunc_f64_u(_text, _pos):
    # Begin Seq
    start_pos207 = _pos
    while True:
        # Begin Byte
        # 0xb1
        if (_pos < len(_text)) and (_text[_pos] == 177):
            _result = 177
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1624
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_trunc_f64_u()
        _result._metadata.position_info = (start_pos207, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1624(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_f64_u' rule, at the expression:\n"
    '    0xb1\n\n'
    'Expected to match the byte value 0xb1'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_convert_i32_s(Node):
    """
    class f32_convert_i32_s {
        let id: 0xb2
    }
    """
    _fields = ()

    id = 0xb2

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_convert_i32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_convert_i32_s, fullparse)


def _try_f32_convert_i32_s(_text, _pos):
    # Begin Seq
    start_pos208 = _pos
    while True:
        # Begin Byte
        # 0xb2
        if (_pos < len(_text)) and (_text[_pos] == 178):
            _result = 178
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1628
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_convert_i32_s()
        _result._metadata.position_info = (start_pos208, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1628(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_convert_i32_s' rule, at the expression:\n"
    '    0xb2\n\n'
    'Expected to match the byte value 0xb2'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_convert_i32_u(Node):
    """
    class f32_convert_i32_u {
        let id: 0xb3
    }
    """
    _fields = ()

    id = 0xb3

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_convert_i32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_convert_i32_u, fullparse)


def _try_f32_convert_i32_u(_text, _pos):
    # Begin Seq
    start_pos209 = _pos
    while True:
        # Begin Byte
        # 0xb3
        if (_pos < len(_text)) and (_text[_pos] == 179):
            _result = 179
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1632
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_convert_i32_u()
        _result._metadata.position_info = (start_pos209, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1632(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_convert_i32_u' rule, at the expression:\n"
    '    0xb3\n\n'
    'Expected to match the byte value 0xb3'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_convert_i64_s(Node):
    """
    class f32_convert_i64_s {
        let id: 0xb4
    }
    """
    _fields = ()

    id = 0xb4

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_convert_i64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_convert_i64_s, fullparse)


def _try_f32_convert_i64_s(_text, _pos):
    # Begin Seq
    start_pos210 = _pos
    while True:
        # Begin Byte
        # 0xb4
        if (_pos < len(_text)) and (_text[_pos] == 180):
            _result = 180
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1636
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_convert_i64_s()
        _result._metadata.position_info = (start_pos210, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1636(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_convert_i64_s' rule, at the expression:\n"
    '    0xb4\n\n'
    'Expected to match the byte value 0xb4'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_convert_i64_u(Node):
    """
    class f32_convert_i64_u {
        let id: 0xb5
    }
    """
    _fields = ()

    id = 0xb5

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_convert_i64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_convert_i64_u, fullparse)


def _try_f32_convert_i64_u(_text, _pos):
    # Begin Seq
    start_pos211 = _pos
    while True:
        # Begin Byte
        # 0xb5
        if (_pos < len(_text)) and (_text[_pos] == 181):
            _result = 181
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1640
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_convert_i64_u()
        _result._metadata.position_info = (start_pos211, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1640(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_convert_i64_u' rule, at the expression:\n"
    '    0xb5\n\n'
    'Expected to match the byte value 0xb5'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_demote_f64(Node):
    """
    class f32_demote_f64 {
        let id: 0xb6
    }
    """
    _fields = ()

    id = 0xb6

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_demote_f64()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_demote_f64, fullparse)


def _try_f32_demote_f64(_text, _pos):
    # Begin Seq
    start_pos212 = _pos
    while True:
        # Begin Byte
        # 0xb6
        if (_pos < len(_text)) and (_text[_pos] == 182):
            _result = 182
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1644
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_demote_f64()
        _result._metadata.position_info = (start_pos212, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1644(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_demote_f64' rule, at the expression:\n"
    '    0xb6\n\n'
    'Expected to match the byte value 0xb6'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_convert_i32_s(Node):
    """
    class f64_convert_i32_s {
        let id: 0xb7
    }
    """
    _fields = ()

    id = 0xb7

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_convert_i32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_convert_i32_s, fullparse)


def _try_f64_convert_i32_s(_text, _pos):
    # Begin Seq
    start_pos213 = _pos
    while True:
        # Begin Byte
        # 0xb7
        if (_pos < len(_text)) and (_text[_pos] == 183):
            _result = 183
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1648
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_convert_i32_s()
        _result._metadata.position_info = (start_pos213, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1648(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_convert_i32_s' rule, at the expression:\n"
    '    0xb7\n\n'
    'Expected to match the byte value 0xb7'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_convert_i32_u(Node):
    """
    class f64_convert_i32_u {
        let id: 0xb8
    }
    """
    _fields = ()

    id = 0xb8

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_convert_i32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_convert_i32_u, fullparse)


def _try_f64_convert_i32_u(_text, _pos):
    # Begin Seq
    start_pos214 = _pos
    while True:
        # Begin Byte
        # 0xb8
        if (_pos < len(_text)) and (_text[_pos] == 184):
            _result = 184
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1652
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_convert_i32_u()
        _result._metadata.position_info = (start_pos214, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1652(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_convert_i32_u' rule, at the expression:\n"
    '    0xb8\n\n'
    'Expected to match the byte value 0xb8'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_convert_i64_s(Node):
    """
    class f64_convert_i64_s {
        let id: 0xb9
    }
    """
    _fields = ()

    id = 0xb9

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_convert_i64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_convert_i64_s, fullparse)


def _try_f64_convert_i64_s(_text, _pos):
    # Begin Seq
    start_pos215 = _pos
    while True:
        # Begin Byte
        # 0xb9
        if (_pos < len(_text)) and (_text[_pos] == 185):
            _result = 185
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1656
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_convert_i64_s()
        _result._metadata.position_info = (start_pos215, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1656(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_convert_i64_s' rule, at the expression:\n"
    '    0xb9\n\n'
    'Expected to match the byte value 0xb9'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_convert_i64_u(Node):
    """
    class f64_convert_i64_u {
        let id: 0xba
    }
    """
    _fields = ()

    id = 0xba

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_convert_i64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_convert_i64_u, fullparse)


def _try_f64_convert_i64_u(_text, _pos):
    # Begin Seq
    start_pos216 = _pos
    while True:
        # Begin Byte
        # 0xba
        if (_pos < len(_text)) and (_text[_pos] == 186):
            _result = 186
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1660
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_convert_i64_u()
        _result._metadata.position_info = (start_pos216, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1660(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_convert_i64_u' rule, at the expression:\n"
    '    0xba\n\n'
    'Expected to match the byte value 0xba'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_promote_f32(Node):
    """
    class f64_promote_f32 {
        let id: 0xbb
    }
    """
    _fields = ()

    id = 0xbb

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_promote_f32()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_promote_f32, fullparse)


def _try_f64_promote_f32(_text, _pos):
    # Begin Seq
    start_pos217 = _pos
    while True:
        # Begin Byte
        # 0xbb
        if (_pos < len(_text)) and (_text[_pos] == 187):
            _result = 187
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1664
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_promote_f32()
        _result._metadata.position_info = (start_pos217, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1664(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_promote_f32' rule, at the expression:\n"
    '    0xbb\n\n'
    'Expected to match the byte value 0xbb'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_reinterpret_f32(Node):
    """
    class i32_reinterpret_f32 {
        let id: 0xbc
    }
    """
    _fields = ()

    id = 0xbc

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_reinterpret_f32()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_reinterpret_f32, fullparse)


def _try_i32_reinterpret_f32(_text, _pos):
    # Begin Seq
    start_pos218 = _pos
    while True:
        # Begin Byte
        # 0xbc
        if (_pos < len(_text)) and (_text[_pos] == 188):
            _result = 188
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1668
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_reinterpret_f32()
        _result._metadata.position_info = (start_pos218, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1668(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_reinterpret_f32' rule, at the expression:\n"
    '    0xbc\n\n'
    'Expected to match the byte value 0xbc'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_reinterpret_f64(Node):
    """
    class i64_reinterpret_f64 {
        let id: 0xbd
    }
    """
    _fields = ()

    id = 0xbd

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_reinterpret_f64()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_reinterpret_f64, fullparse)


def _try_i64_reinterpret_f64(_text, _pos):
    # Begin Seq
    start_pos219 = _pos
    while True:
        # Begin Byte
        # 0xbd
        if (_pos < len(_text)) and (_text[_pos] == 189):
            _result = 189
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1672
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_reinterpret_f64()
        _result._metadata.position_info = (start_pos219, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1672(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_reinterpret_f64' rule, at the expression:\n"
    '    0xbd\n\n'
    'Expected to match the byte value 0xbd'
    )
    raise ParseError((title + details), _pos, line, col)

class f32_reinterpret_i32(Node):
    """
    class f32_reinterpret_i32 {
        let id: 0xbe
    }
    """
    _fields = ()

    id = 0xbe

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f32_reinterpret_i32()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f32_reinterpret_i32, fullparse)


def _try_f32_reinterpret_i32(_text, _pos):
    # Begin Seq
    start_pos220 = _pos
    while True:
        # Begin Byte
        # 0xbe
        if (_pos < len(_text)) and (_text[_pos] == 190):
            _result = 190
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1676
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f32_reinterpret_i32()
        _result._metadata.position_info = (start_pos220, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1676(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32_reinterpret_i32' rule, at the expression:\n"
    '    0xbe\n\n'
    'Expected to match the byte value 0xbe'
    )
    raise ParseError((title + details), _pos, line, col)

class f64_reinterpret_i64(Node):
    """
    class f64_reinterpret_i64 {
        let id: 0xbf
    }
    """
    _fields = ()

    id = 0xbf

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'f64_reinterpret_i64()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_f64_reinterpret_i64, fullparse)


def _try_f64_reinterpret_i64(_text, _pos):
    # Begin Seq
    start_pos221 = _pos
    while True:
        # Begin Byte
        # 0xbf
        if (_pos < len(_text)) and (_text[_pos] == 191):
            _result = 191
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1680
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = f64_reinterpret_i64()
        _result._metadata.position_info = (start_pos221, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1680(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64_reinterpret_i64' rule, at the expression:\n"
    '    0xbf\n\n'
    'Expected to match the byte value 0xbf'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_extend8_s(Node):
    """
    class i32_extend8_s {
        let id: 0xc0
    }
    """
    _fields = ()

    id = 0xc0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_extend8_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_extend8_s, fullparse)


def _try_i32_extend8_s(_text, _pos):
    # Begin Seq
    start_pos222 = _pos
    while True:
        # Begin Byte
        # 0xc0
        if (_pos < len(_text)) and (_text[_pos] == 192):
            _result = 192
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1684
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_extend8_s()
        _result._metadata.position_info = (start_pos222, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1684(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_extend8_s' rule, at the expression:\n"
    '    0xc0\n\n'
    'Expected to match the byte value 0xc0'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_extend16_s(Node):
    """
    class i32_extend16_s {
        let id: 0xc1
    }
    """
    _fields = ()

    id = 0xc1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_extend16_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_extend16_s, fullparse)


def _try_i32_extend16_s(_text, _pos):
    # Begin Seq
    start_pos223 = _pos
    while True:
        # Begin Byte
        # 0xc1
        if (_pos < len(_text)) and (_text[_pos] == 193):
            _result = 193
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1688
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i32_extend16_s()
        _result._metadata.position_info = (start_pos223, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1688(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_extend16_s' rule, at the expression:\n"
    '    0xc1\n\n'
    'Expected to match the byte value 0xc1'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_extend8_s(Node):
    """
    class i64_extend8_s {
        let id: 0xc2
    }
    """
    _fields = ()

    id = 0xc2

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_extend8_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_extend8_s, fullparse)


def _try_i64_extend8_s(_text, _pos):
    # Begin Seq
    start_pos224 = _pos
    while True:
        # Begin Byte
        # 0xc2
        if (_pos < len(_text)) and (_text[_pos] == 194):
            _result = 194
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1692
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_extend8_s()
        _result._metadata.position_info = (start_pos224, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1692(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_extend8_s' rule, at the expression:\n"
    '    0xc2\n\n'
    'Expected to match the byte value 0xc2'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_extend16_s(Node):
    """
    class i64_extend16_s {
        let id: 0xc3
    }
    """
    _fields = ()

    id = 0xc3

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_extend16_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_extend16_s, fullparse)


def _try_i64_extend16_s(_text, _pos):
    # Begin Seq
    start_pos225 = _pos
    while True:
        # Begin Byte
        # 0xc3
        if (_pos < len(_text)) and (_text[_pos] == 195):
            _result = 195
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1696
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_extend16_s()
        _result._metadata.position_info = (start_pos225, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1696(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_extend16_s' rule, at the expression:\n"
    '    0xc3\n\n'
    'Expected to match the byte value 0xc3'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_extend32_s(Node):
    """
    class i64_extend32_s {
        let id: 0xc4
    }
    """
    _fields = ()

    id = 0xc4

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_extend32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_extend32_s, fullparse)


def _try_i64_extend32_s(_text, _pos):
    # Begin Seq
    start_pos226 = _pos
    while True:
        # Begin Byte
        # 0xc4
        if (_pos < len(_text)) and (_text[_pos] == 196):
            _result = 196
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1700
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = i64_extend32_s()
        _result._metadata.position_info = (start_pos226, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1700(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_extend32_s' rule, at the expression:\n"
    '    0xc4\n\n'
    'Expected to match the byte value 0xc4'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_sat_f32_s(Node):
    """
    class i32_trunc_sat_f32_s {
        let id: 0xfc
        let code: 0x0
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_sat_f32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_sat_f32_s, fullparse)


def _try_i32_trunc_sat_f32_s(_text, _pos):
    # Begin Seq
    start_pos227 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1704
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1706
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i32_trunc_sat_f32_s()
        _result._metadata.position_info = (start_pos227, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1704(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f32_s' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1706(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f32_s' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_sat_f32_u(Node):
    """
    class i32_trunc_sat_f32_u {
        let id: 0xfc
        let code: 0x1
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_sat_f32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_sat_f32_u, fullparse)


def _try_i32_trunc_sat_f32_u(_text, _pos):
    # Begin Seq
    start_pos228 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1710
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1712
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i32_trunc_sat_f32_u()
        _result._metadata.position_info = (start_pos228, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1710(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f32_u' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1712(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f32_u' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_sat_f64_s(Node):
    """
    class i32_trunc_sat_f64_s {
        let id: 0xfc
        let code: 0x2
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x2

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_sat_f64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_sat_f64_s, fullparse)


def _try_i32_trunc_sat_f64_s(_text, _pos):
    # Begin Seq
    start_pos229 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1716
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1718
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i32_trunc_sat_f64_s()
        _result._metadata.position_info = (start_pos229, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1716(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f64_s' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1718(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f64_s' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class i32_trunc_sat_f64_u(Node):
    """
    class i32_trunc_sat_f64_u {
        let id: 0xfc
        let code: 0x3
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x3

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i32_trunc_sat_f64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i32_trunc_sat_f64_u, fullparse)


def _try_i32_trunc_sat_f64_u(_text, _pos):
    # Begin Seq
    start_pos230 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1722
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1724
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i32_trunc_sat_f64_u()
        _result._metadata.position_info = (start_pos230, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1722(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f64_u' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1724(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i32_trunc_sat_f64_u' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_sat_f32_s(Node):
    """
    class i64_trunc_sat_f32_s {
        let id: 0xfc
        let code: 0x4
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x4

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_sat_f32_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_sat_f32_s, fullparse)


def _try_i64_trunc_sat_f32_s(_text, _pos):
    # Begin Seq
    start_pos231 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1728
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1730
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i64_trunc_sat_f32_s()
        _result._metadata.position_info = (start_pos231, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1728(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f32_s' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1730(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f32_s' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_sat_f32_u(Node):
    """
    class i64_trunc_sat_f32_u {
        let id: 0xfc
        let code: 0x5
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x5

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_sat_f32_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_sat_f32_u, fullparse)


def _try_i64_trunc_sat_f32_u(_text, _pos):
    # Begin Seq
    start_pos232 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1734
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x5
        if (_pos < len(_text)) and (_text[_pos] == 5):
            _result = 5
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1736
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i64_trunc_sat_f32_u()
        _result._metadata.position_info = (start_pos232, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1734(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f32_u' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1736(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f32_u' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_sat_f64_s(Node):
    """
    class i64_trunc_sat_f64_s {
        let id: 0xfc
        let code: 0x6
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x6

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_sat_f64_s()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_sat_f64_s, fullparse)


def _try_i64_trunc_sat_f64_s(_text, _pos):
    # Begin Seq
    start_pos233 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1740
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x6
        if (_pos < len(_text)) and (_text[_pos] == 6):
            _result = 6
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1742
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i64_trunc_sat_f64_s()
        _result._metadata.position_info = (start_pos233, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1740(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f64_s' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1742(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f64_s' rule, at the expression:\n"
    '    0x6\n\n'
    'Expected to match the byte value 0x6'
    )
    raise ParseError((title + details), _pos, line, col)

class i64_trunc_sat_f64_u(Node):
    """
    class i64_trunc_sat_f64_u {
        let id: 0xfc
        let code: 0x7
    }
    """
    _fields = ()

    id = 0xfc
    code = 0x7

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'i64_trunc_sat_f64_u()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_i64_trunc_sat_f64_u, fullparse)


def _try_i64_trunc_sat_f64_u(_text, _pos):
    # Begin Seq
    start_pos234 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1746
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x7
        if (_pos < len(_text)) and (_text[_pos] == 7):
            _result = 7
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1748
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        _result = i64_trunc_sat_f64_u()
        _result._metadata.position_info = (start_pos234, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1746(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f64_u' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1748(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'i64_trunc_sat_f64_u' rule, at the expression:\n"
    '    0x7\n\n'
    'Expected to match the byte value 0x7'
    )
    raise ParseError((title + details), _pos, line, col)

class memory_init(Node):
    """
    class memory_init {
        let id: 0xfc
        let code: 0x8
        data_index: DataIndex
        let zero: 0x0
    }
    """
    _fields = ('data_index',)

    id = 0xfc
    code = 0x8
    zero = 0x0

    def __init__(self, data_index):
        Node.__init__(self)
        self.data_index = data_index

    def __repr__(self):
        return f'memory_init(data_index={self.data_index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_memory_init, fullparse)


def _try_memory_init(_text, _pos):
    # Begin Seq
    start_pos235 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1752
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x8
        if (_pos < len(_text)) and (_text[_pos] == 8):
            _result = 8
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1754
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataIndex, _pos))
        # End Ref
        if not (_status):
            break
        data_index = _result
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1758
            _status = False
        # End Byte
        if not (_status):
            break
        zero = _result
        _result = memory_init(data_index)
        _result._metadata.position_info = (start_pos235, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1752(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_init' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1754(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_init' rule, at the expression:\n"
    '    0x8\n\n'
    'Expected to match the byte value 0x8'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1758(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_init' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class data_drop(Node):
    """
    class data_drop {
        let id: 0xfc
        let code: 0x9
        data_index: DataIndex
    }
    """
    _fields = ('data_index',)

    id = 0xfc
    code = 0x9

    def __init__(self, data_index):
        Node.__init__(self)
        self.data_index = data_index

    def __repr__(self):
        return f'data_drop(data_index={self.data_index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_data_drop, fullparse)


def _try_data_drop(_text, _pos):
    # Begin Seq
    start_pos236 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1762
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x9
        if (_pos < len(_text)) and (_text[_pos] == 9):
            _result = 9
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1764
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataIndex, _pos))
        # End Ref
        if not (_status):
            break
        data_index = _result
        _result = data_drop(data_index)
        _result._metadata.position_info = (start_pos236, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1762(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'data_drop' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1764(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'data_drop' rule, at the expression:\n"
    '    0x9\n\n'
    'Expected to match the byte value 0x9'
    )
    raise ParseError((title + details), _pos, line, col)

class memory_copy(Node):
    """
    class memory_copy {
        let id: 0xfc
        let code: 0xa
        let zeros: b'\\x00\\x00'
    }
    """
    _fields = ()

    id = 0xfc
    code = 0xa
    zeros = b'\x00\x00'

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'memory_copy()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_memory_copy, fullparse)


def _try_memory_copy(_text, _pos):
    # Begin Seq
    start_pos237 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1770
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xa
        if (_pos < len(_text)) and (_text[_pos] == 10):
            _result = 10
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1772
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Str
        value3 = b'\x00\x00'
        end3 = (_pos + 2)
        if (_text[slice(_pos, end3, None)] == value3):
            _result = value3
            _pos = end3
            _status = True
        else:
            _result = _raise_error1774
            _status = False
        # End Str
        if not (_status):
            break
        zeros = _result
        _result = memory_copy()
        _result._metadata.position_info = (start_pos237, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1770(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_copy' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1772(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_copy' rule, at the expression:\n"
    '    0xa\n\n'
    'Expected to match the byte value 0xa'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1774(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_copy' rule, at the expression:\n"
    "    b'\\x00\\x00'\n\n"
    "Expected to match the string b'\\x00\\x00'"
    )
    raise ParseError((title + details), _pos, line, col)

class memory_fill(Node):
    """
    class memory_fill {
        let id: 0xfc
        let code: 0xb
        let zero: 0x0
    }
    """
    _fields = ()

    id = 0xfc
    code = 0xb
    zero = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'memory_fill()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_memory_fill, fullparse)


def _try_memory_fill(_text, _pos):
    # Begin Seq
    start_pos238 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1778
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xb
        if (_pos < len(_text)) and (_text[_pos] == 11):
            _result = 11
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1780
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1782
            _status = False
        # End Byte
        if not (_status):
            break
        zero = _result
        _result = memory_fill()
        _result._metadata.position_info = (start_pos238, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1778(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_fill' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1780(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_fill' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1782(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'memory_fill' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class table_init(Node):
    """
    class table_init {
        let id: 0xfc
        let code: 0xc
        element: ElementIndex
        table: TableIndex
    }
    """
    _fields = ('element', 'table')

    id = 0xfc
    code = 0xc

    def __init__(self, element, table):
        Node.__init__(self)
        self.element = element
        self.table = table

    def __repr__(self):
        return f'table_init(element={self.element!r}, table={self.table!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_init, fullparse)


def _try_table_init(_text, _pos):
    # Begin Seq
    start_pos239 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1786
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xc
        if (_pos < len(_text)) and (_text[_pos] == 12):
            _result = 12
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1788
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ElementIndex, _pos))
        # End Ref
        if not (_status):
            break
        element = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table = _result
        _result = table_init(element, table)
        _result._metadata.position_info = (start_pos239, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1786(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_init' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1788(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_init' rule, at the expression:\n"
    '    0xc\n\n'
    'Expected to match the byte value 0xc'
    )
    raise ParseError((title + details), _pos, line, col)

class elem_drop(Node):
    """
    class elem_drop {
        let id: 0xfc
        let code: 0xd
        element: ElementIndex
    }
    """
    _fields = ('element',)

    id = 0xfc
    code = 0xd

    def __init__(self, element):
        Node.__init__(self)
        self.element = element

    def __repr__(self):
        return f'elem_drop(element={self.element!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_elem_drop, fullparse)


def _try_elem_drop(_text, _pos):
    # Begin Seq
    start_pos240 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1796
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xd
        if (_pos < len(_text)) and (_text[_pos] == 13):
            _result = 13
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1798
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ElementIndex, _pos))
        # End Ref
        if not (_status):
            break
        element = _result
        _result = elem_drop(element)
        _result._metadata.position_info = (start_pos240, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1796(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'elem_drop' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1798(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'elem_drop' rule, at the expression:\n"
    '    0xd\n\n'
    'Expected to match the byte value 0xd'
    )
    raise ParseError((title + details), _pos, line, col)

class table_copy(Node):
    """
    class table_copy {
        let id: 0xfc
        let code: 0xe
        destination: TableIndex
        source: TableIndex
    }
    """
    _fields = ('destination', 'source')

    id = 0xfc
    code = 0xe

    def __init__(self, destination, source):
        Node.__init__(self)
        self.destination = destination
        self.source = source

    def __repr__(self):
        return f'table_copy(destination={self.destination!r}, source={self.source!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_copy, fullparse)


def _try_table_copy(_text, _pos):
    # Begin Seq
    start_pos241 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1804
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xe
        if (_pos < len(_text)) and (_text[_pos] == 14):
            _result = 14
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1806
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        destination = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        source = _result
        _result = table_copy(destination, source)
        _result._metadata.position_info = (start_pos241, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1804(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_copy' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1806(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_copy' rule, at the expression:\n"
    '    0xe\n\n'
    'Expected to match the byte value 0xe'
    )
    raise ParseError((title + details), _pos, line, col)

class table_grow(Node):
    """
    class table_grow {
        let id: 0xfc
        let code: 0xf
        table: TableIndex
    }
    """
    _fields = ('table',)

    id = 0xfc
    code = 0xf

    def __init__(self, table):
        Node.__init__(self)
        self.table = table

    def __repr__(self):
        return f'table_grow(table={self.table!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_grow, fullparse)


def _try_table_grow(_text, _pos):
    # Begin Seq
    start_pos242 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1814
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0xf
        if (_pos < len(_text)) and (_text[_pos] == 15):
            _result = 15
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1816
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table = _result
        _result = table_grow(table)
        _result._metadata.position_info = (start_pos242, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1814(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_grow' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1816(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_grow' rule, at the expression:\n"
    '    0xf\n\n'
    'Expected to match the byte value 0xf'
    )
    raise ParseError((title + details), _pos, line, col)

class table_size(Node):
    """
    class table_size {
        let id: 0xfc
        let code: 0x10
        table: TableIndex
    }
    """
    _fields = ('table',)

    id = 0xfc
    code = 0x10

    def __init__(self, table):
        Node.__init__(self)
        self.table = table

    def __repr__(self):
        return f'table_size(table={self.table!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_size, fullparse)


def _try_table_size(_text, _pos):
    # Begin Seq
    start_pos243 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1822
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x10
        if (_pos < len(_text)) and (_text[_pos] == 16):
            _result = 16
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1824
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table = _result
        _result = table_size(table)
        _result._metadata.position_info = (start_pos243, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1822(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_size' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1824(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_size' rule, at the expression:\n"
    '    0x10\n\n'
    'Expected to match the byte value 0x10'
    )
    raise ParseError((title + details), _pos, line, col)

class table_fill(Node):
    """
    class table_fill {
        let id: 0xfc
        let code: 0x11
        table: TableIndex
    }
    """
    _fields = ('table',)

    id = 0xfc
    code = 0x11

    def __init__(self, table):
        Node.__init__(self)
        self.table = table

    def __repr__(self):
        return f'table_fill(table={self.table!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_table_fill, fullparse)


def _try_table_fill(_text, _pos):
    # Begin Seq
    start_pos244 = _pos
    while True:
        # Begin Byte
        # 0xfc
        if (_pos < len(_text)) and (_text[_pos] == 252):
            _result = 252
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1830
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Byte
        # 0x11
        if (_pos < len(_text)) and (_text[_pos] == 17):
            _result = 17
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error1832
            _status = False
        # End Byte
        if not (_status):
            break
        code = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableIndex, _pos))
        # End Ref
        if not (_status):
            break
        table = _result
        _result = table_fill(table)
        _result._metadata.position_info = (start_pos244, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error1830(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_fill' rule, at the expression:\n"
    '    0xfc\n\n'
    'Expected to match the byte value 0xfc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error1832(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'table_fill' rule, at the expression:\n"
    '    0x11\n\n'
    'Expected to match the byte value 0x11'
    )
    raise ParseError((title + details), _pos, line, col)

