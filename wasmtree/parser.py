# Generated by ../generate_parser.py
"""
# Grammar definition:
```
import struct
```

class Module {
    let magic: b'\\x00\\x61\\x73\\x6D'
    let version: b'\\x01\\x00\\x00\\x00'

    custom1: CustomSection*

    type_section: TypeSection?
    custom2: CustomSection*

    import_section: ImportSection?
    custom3: CustomSection*

    function_section: FunctionSection?
    custom4: CustomSection*

    table_section: TableSection?
    custom5: CustomSection*

    memory_section: MemorySection?
    custom6: CustomSection*

    global_section: GlobalSection?
    custom7: CustomSection*

    export_section: ExportSection?
    custom8: CustomSection*

    start_section: StartSection?
    custom9: CustomSection*

    element_section: ElementSection?
    custom10: CustomSection*

    data_count_section: DataCountSection?
    custom11: CustomSection*

    code_section: CodeSection?
    custom12: CustomSection*

    data_section: DataSection?
    custom13: CustomSection*
}


# Sections.
class CustomSection {
    let id: 0x00
    let size: u32
    let loc: LocatedName
    let remaining = `size - (loc.end - loc.start)`

    name: `loc.name`
    body: ByteString(remaining)
}

class TypeSection {
    let id: 0x01
    let size: u32
    function_types: vec(FuncType)
}

class ImportSection {
    let id: 0x02
    let size: u32
    imports: vec(Import)
}

class FunctionSection {
    let id: 0x03
    let size: u32
    type_indexes: vec(u32)
}

class TableSection {
    let id: 0x04
    let size: u32
    table_types: vec(TableType)
}

class MemorySection {
    let id: 0x05
    let size: u32
    memory_types: vec(MemoryType)
}

class GlobalSection {
    let id: 0x06
    let size: u32
    globals: vec(Global)
}

class ExportSection {
    let id: 0x07
    let size: u32
    exports: vec(Export)
}

class StartSection {
    let id: 0x08
    let size: u32
    index: u32
}

class ElementSection {
    let id: 0x09
    let size: u32
    segments: vec(ElementSegment)
}

class DataCountSection {
    let id: 0x0C
    let size: u32
    count: Opt(u32 where `lambda _: size > 0`)
}

class CodeSection {
    let id: 0x0A
    let size: u32
    entries: vec(CodeEntry)
}

class DataSection {
    let id: 0x0B
    let size: u32
    segments: vec(DefaultDataSegment | PassiveDataSegment | ActiveDataSegment)
}


# Globals.
class Global {
    type: GlobalType
    initializer: Expression
}


# Imports.
class Import {
    module: Name
    name: Name
    descriptor: ImportFunc | ImportTable | ImportMemory | ImportGlobal
}

class ImportFunc {
    let id: 0x00
    type: u32
}

class ImportTable {
    let id: 0x01
    type: TableType
}

class ImportMemory {
    let id: 0x02
    type: MemoryType
}

class ImportGlobal {
    let id: 0x03
    type: GlobalType
}


# Exports.
class Export {
    name: Name
    descriptor: ExportFunc | ExportTable | ExportMemory | ExportGlobal
}

class ExportFunc {
    let id: 0x00
    index: u32
}

class ExportTable {
    let id: 0x01
    index: u32
}

class ExportMemory {
    let id: 0x02
    index: u32
}

class ExportGlobal {
    let id: 0x03
    index: u32
}


# Element segments.
ElementSegment = (
    DefaultSegment
    | PassiveFuncRefSegment
    | ActiveFuncRefSegment
    | DeclarativeFuncRefSegment
    | DefaultExpressionSegment
    | PassiveExpressionSegment
    | ActiveExpressionSegment
    | DeclarativeExpressionSegment
)

class DefaultSegment {
    let id: 0x00
    offset: Expression
    function_indexes: vec(u32)
}

class PassiveFuncRefSegment {
    let id: 0x01
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class ActiveFuncRefSegment {
    let id: 0x02
    table_index: u32
    offset: Expression
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class DeclarativeFuncRefSegment {
    let id: 0x03
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class DefaultExpressionSegment {
    let id: 0x04
    offset: Expression
    initializers: vec(Expression)
}

class PassiveExpressionSegment {
    let id: 0x05
    type: ReferenceType
    initializers: vec(Expression)
}

class ActiveExpressionSegment {
    let id: 0x06
    table_index: u32
    offset: Expression
    type: ReferenceType
    initializers: vec(Expression)
}

class DeclarativeExpressionSegment {
    let id: 0x07
    type: ReferenceType
    initializers: vec(Expression)
}


# Data segments.
class DefaultDataSegment {
    let id: 0x00
    offset: Expression
    contents: ByteVector
}

class PassiveDataSegment {
    let id: 0x01
    contents: ByteVector
}

class ActiveDataSegment {
    let id: 0x02
    index: u32
    offset: Expression
    contents: ByteVector
}


# Limits.
Limits = MinLimit | MinMaxLimits

class MinLimit {
    let id: 0x00
    min: u32
}

class MinMaxLimits {
    let id: 0x01
    min: u32
    max: u32
}


# Types.
class FuncType {
    let id: 0x60
    params: vec(ValueType)
    results: vec(ValueType)
}

class GlobalType {
    type: ValueType
    modifier: 0x00 >> `'const'` | 0x01 >> `'var'`
}

class MemoryType {
    limits: Limits
}

NumberType = (
    0x7F >> `'i32'`
    | 0x7E >> `'i64'`
    | 0x7D >> `'f32'`
    | 0x7C >> `'f64'`
)

class TableType {
    type: ReferenceType
    limits: Limits
}

ReferenceType = (
    0x70 >> `'funcref'`
    | 0x6F >> `'externref'`
)

ValueType = NumberType | ReferenceType


# Vectors.
vec(element) =>
    let length = u32 in
    element{length}


# Uninterpreted bytes.
ByteString(size) => bytechar{size} |> `lambda x: b''.join(x)`
ByteVector => vec(bytechar) |> `lambda x: b''.join(x)`
bytechar = b/[\\x00-\\xFF]/


# Names.
Name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`


class LocatedName {
    start: `_pos`
    name: Name
    end: `_pos`
}


# Numbers.
byte = b/[\\x00-\\xFF]/ |> `ord`
u32 = UnsignedInt
i32 = SignedInt
i64 = SignedInt
f32 = b/[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
f64 = b/[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`

SignedInt = LEB128 |> `decode_signed_int`
UnsignedInt = LEB128 |> `decode_unsigned_int`
LEB128 = b/[\\x80-\\xFF]*[\\x00-\\x7F]/

```
continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result
```


# Code.
class CodeEntry {
    let size: u32
    locals: vec(Locals)
    expression: Expression
}

class Locals {
    count: u32
    type: ValueType
}


# Instructions.
Expression => Instruction* << 0x0B

Instruction = (
    Unreachable
    | Nop
    | GetLocal
    | ConstI32
    | AddI32
)

class Unreachable {
    let id: 0x00
}

class Nop {
    let id: 0x01
}

class GetLocal {
    let id: 0x20
    index: u32
}

class ConstI32 {
    let id: 0x41
    number: i32
}

class AddI32 {
    let id: 0x6A
}

"""

from collections import namedtuple as _nt
from re import compile as _compile_re, IGNORECASE as _IGNORECASE

class Node:
    _fields = ()

    def __init__(self):
        self._metadata = _Metadata()

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            if getattr(self, field) != getattr(other, field):
                return False
        return True

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        result = self.__class__(**kw)
        result._metadata.update(self._metadata)
        return result


class _Metadata:
    def __init__(self, **fields):
        object.__setattr__(self, '_fields', fields)

    def __getattr__(self, name):
        return self._fields.get(name)

    def __setattr__(self, name, value):
        self._fields[name] = value

    def __len__(self):
        return len(self._fields)

    def copy(self):
        return _Metadata(**self._fields)

    def update(self, other):
        self._fields.update(other._fields)


class Rule:
    def __init__(self, name, parse, definition):
        self.name = name
        self.parse = parse
        self.definition = definition

    def __repr__(self):
        return (f'Rule(name={self.name!r}, parse={self.parse.__name__},'
            f' definition={self.definition!r})')


import struct


continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result


class SourcerError(Exception):
    """Common superclass for ParseError and PartialParseError."""


class ParseError(SourcerError):
    def __init__(self, message, index, line, column):
        super().__init__(message)
        self.position = _Position(index, line, column)


class PartialParseError(SourcerError):
    def __init__(self, partial_result, last_position, excerpt):
        super().__init__('Incomplete parse. Unexpected input on line'
            f' {last_position.line}, column {last_position.column}:\n{excerpt}')
        self.partial_result = partial_result
        self.last_position = last_position


class Infix(Node):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        Node.__init__(self)
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(Node):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        Node.__init__(self)
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(Node):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        Node.__init__(self)
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Module, fullparse)


_PositionInfo = _nt('_PositionInfo', 'start, end')

_Position = _nt('_Position', 'index, line, column')


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _text, _pos):
        return self.func(_text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


class _ByteLiteral(int):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_byte_literal(byte_value, parse_function):
    result = _ByteLiteral(byte_value)
    result._parse_function = parse_function
    return result


def _run(text, pos, start, fullparse):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return _finalize_parse_info(text, result[1], result[2], fullparse)
    else:
        pos = result[2]
        message = result[1](text, pos)
        raise ParseError(message, pos)


def visit(node):
    visited = set()
    stack = [node]
    while stack:
        node = stack.pop()

        if isinstance(node, (list, tuple)):
            stack.extend(node)

        elif isinstance(node, dict):
            stack.extend(node.values())

        elif isinstance(node, Node):
            node_id = id(node)
            if node_id in visited:
                continue
            visited.add(node_id)

            yield node

            if hasattr(node, '_fields'):
                stack.extend(getattr(node, x) for x in node._fields)


_Traversing = _nt('_Traversing', 'parent, field, child, is_finished')


def traverse(node):
    visited = set()
    stack = [_Traversing(parent=None, field=None, child=node, is_finished=False)]
    while stack:
        traversing = stack.pop()

        if traversing.is_finished:
            yield traversing
            continue

        child = traversing.child
        child_id = id(child)

        if child_id in visited:
            continue

        visited.add(child_id)
        stack.append(traversing._replace(is_finished=True))
        yield traversing

        def extend(items):
            stack.extend(reversed(list(items)))

        if isinstance(child, (list, tuple)):
            extend(
                _Traversing(parent=child, field=i, child=x, is_finished=False)
                for i, x in enumerate(child)
            )

        elif isinstance(child, dict):
            extend(
                _Traversing(parent=child, field=k, child=v, is_finished=False)
                for k, v in child.items()
            )

        elif isinstance(child, Node) and hasattr(child, '_fields'):
            extend(
                _Traversing(
                    parent=child,
                    field=x,
                    child=getattr(child, x),
                    is_finished=False,
                )
                for x in child._fields
            )


def transform(node, *callbacks):
    if not callbacks:
        return node

    if len(callbacks) == 1:
        callback = callbacks[0]
    else:
        def callback(node):
            for f in callbacks:
                node = f(node)
            return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, Node):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if now is not was:
            updates[field] = now
            if isinstance(was, Node) and isinstance(now, Node) and not now._metadata:
                now._metadata.update(was._metadata)

    if updates:
        node = node._replace(**updates)

    return callback(node)


def _finalize_parse_info(text, nodes, pos, fullparse):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)

    for node in visit(nodes):
        pos_info = node._metadata.position_info
        if pos_info:
            start, end = pos_info
            end -= 1
            node._metadata.position_info = _PositionInfo(
                start=_Position(start, line_numbers[start], column_numbers[start]),
                end=_Position(end, line_numbers[end], column_numbers[end]),
            )

    if fullparse and pos < len(text):
        line, col = line_numbers[pos], column_numbers[pos]
        position = _Position(pos, line, col)
        excerpt = _extract_excerpt(text, pos, col)
        raise PartialParseError(nodes, position, excerpt)

    return nodes


def _extract_excerpt(text, pos, col):
    if isinstance(text, bytes):
        return repr(text[max(0, pos - 1) : pos + 2])

    start = pos - (col - 1)
    match = _compile_re('\n').search(text, pos + 1)
    end = len(text) if match is None else match.start()

    if end - start < 96:
        return text[start : end] + _caret_at(col - 1)

    if col < 60:
        # Chop the line off at the end.
        return text[start : start + 90] + ' ...' + _caret_at(col - 1)

    elif end - pos < 40:
        # Chop the line off at the start.
        return '... ' + text[end - 90 : end] + _caret_at(pos - (end - 90) + 4)

    else:
        # Chop the line off at both ends.
        return '... ' + text[pos - 42 : pos + 42] + ' ...' + _caret_at(42 + 4)


def _caret_at(index):
    return '\n' + (' ' * index) + '^'


def _get_line_and_column(text, pos):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)
    return line_numbers[pos], column_numbers[pos]


def _map_index_to_line_and_column(text):
    line_numbers = []
    column_numbers = []

    current_line = 1
    current_column = 0

    for c in text:
        if c == '\n':
            current_line += 1
            current_column = 0
        else:
            current_column += 1
        line_numbers.append(current_line)
        column_numbers.append(current_column)

    return line_numbers, column_numbers

matcher1 = _compile_re(b'[\\x00-\\xFF]', flags=0).match
matcher2 = _compile_re(b'[\\x00-\\xFF]{4}', flags=0).match
matcher3 = _compile_re(b'[\\x00-\\xFF]{8}', flags=0).match
matcher4 = _compile_re(b'[\\x80-\\xFF]*[\\x00-\\x7F]', flags=0).match

class Module(Node):
    """
    class Module {
        let magic: b'\\x00asm'
        let version: b'\\x01\\x00\\x00\\x00'
        custom1: CustomSection*
        type_section: Opt(TypeSection)
        custom2: CustomSection*
        import_section: Opt(ImportSection)
        custom3: CustomSection*
        function_section: Opt(FunctionSection)
        custom4: CustomSection*
        table_section: Opt(TableSection)
        custom5: CustomSection*
        memory_section: Opt(MemorySection)
        custom6: CustomSection*
        global_section: Opt(GlobalSection)
        custom7: CustomSection*
        export_section: Opt(ExportSection)
        custom8: CustomSection*
        start_section: Opt(StartSection)
        custom9: CustomSection*
        element_section: Opt(ElementSection)
        custom10: CustomSection*
        data_count_section: Opt(DataCountSection)
        custom11: CustomSection*
        code_section: Opt(CodeSection)
        custom12: CustomSection*
        data_section: Opt(DataSection)
        custom13: CustomSection*
    }
    """
    _fields = ('custom1', 'type_section', 'custom2', 'import_section', 'custom3', 'function_section', 'custom4', 'table_section', 'custom5', 'memory_section', 'custom6', 'global_section', 'custom7', 'export_section', 'custom8', 'start_section', 'custom9', 'element_section', 'custom10', 'data_count_section', 'custom11', 'code_section', 'custom12', 'data_section', 'custom13')

    magic = b'\x00asm'
    version = b'\x01\x00\x00\x00'

    def __init__(self, custom1, type_section, custom2, import_section, custom3, function_section, custom4, table_section, custom5, memory_section, custom6, global_section, custom7, export_section, custom8, start_section, custom9, element_section, custom10, data_count_section, custom11, code_section, custom12, data_section, custom13):
        Node.__init__(self)
        self.custom1 = custom1
        self.type_section = type_section
        self.custom2 = custom2
        self.import_section = import_section
        self.custom3 = custom3
        self.function_section = function_section
        self.custom4 = custom4
        self.table_section = table_section
        self.custom5 = custom5
        self.memory_section = memory_section
        self.custom6 = custom6
        self.global_section = global_section
        self.custom7 = custom7
        self.export_section = export_section
        self.custom8 = custom8
        self.start_section = start_section
        self.custom9 = custom9
        self.element_section = element_section
        self.custom10 = custom10
        self.data_count_section = data_count_section
        self.custom11 = custom11
        self.code_section = code_section
        self.custom12 = custom12
        self.data_section = data_section
        self.custom13 = custom13

    def __repr__(self):
        return f'Module(custom1={self.custom1!r}, type_section={self.type_section!r}, custom2={self.custom2!r}, import_section={self.import_section!r}, custom3={self.custom3!r}, function_section={self.function_section!r}, custom4={self.custom4!r}, table_section={self.table_section!r}, custom5={self.custom5!r}, memory_section={self.memory_section!r}, custom6={self.custom6!r}, global_section={self.global_section!r}, custom7={self.custom7!r}, export_section={self.export_section!r}, custom8={self.custom8!r}, start_section={self.start_section!r}, custom9={self.custom9!r}, element_section={self.element_section!r}, custom10={self.custom10!r}, data_count_section={self.data_count_section!r}, custom11={self.custom11!r}, code_section={self.code_section!r}, custom12={self.custom12!r}, data_section={self.data_section!r}, custom13={self.custom13!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Module, fullparse)


def _try_Module(_text, _pos):
    # Begin Seq
    start_pos1 = _pos
    while True:
        # Begin Str
        value1 = b'\x00asm'
        end1 = (_pos + 4)
        if (_text[slice(_pos, end1, None)] == value1):
            _result = value1
            _pos = end1
            _status = True
        else:
            _result = _raise_error4
            _status = False
        # End Str
        if not (_status):
            break
        magic = _result
        # Begin Str
        value2 = b'\x01\x00\x00\x00'
        end2 = (_pos + 4)
        if (_text[slice(_pos, end2, None)] == value2):
            _result = value2
            _pos = end2
            _status = True
        else:
            _result = _raise_error6
            _status = False
        # End Str
        if not (_status):
            break
        version = _result
        # Begin List
        # CustomSection*
        staging1 = []
        while True:
            checkpoint1 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint1
                break
            staging1.append(_result)
        _result = staging1
        _status = True
        # End List
        custom1 = _result
        # Begin Opt
        # Opt(TypeSection)
        backtrack1 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TypeSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack1
            _result = None
            _status = True
        # End Opt
        type_section = _result
        # Begin List
        # CustomSection*
        staging2 = []
        while True:
            checkpoint2 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint2
                break
            staging2.append(_result)
        _result = staging2
        _status = True
        # End List
        custom2 = _result
        # Begin Opt
        # Opt(ImportSection)
        backtrack2 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ImportSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack2
            _result = None
            _status = True
        # End Opt
        import_section = _result
        # Begin List
        # CustomSection*
        staging3 = []
        while True:
            checkpoint3 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint3
                break
            staging3.append(_result)
        _result = staging3
        _status = True
        # End List
        custom3 = _result
        # Begin Opt
        # Opt(FunctionSection)
        backtrack3 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_FunctionSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack3
            _result = None
            _status = True
        # End Opt
        function_section = _result
        # Begin List
        # CustomSection*
        staging4 = []
        while True:
            checkpoint4 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint4
                break
            staging4.append(_result)
        _result = staging4
        _status = True
        # End List
        custom4 = _result
        # Begin Opt
        # Opt(TableSection)
        backtrack4 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack4
            _result = None
            _status = True
        # End Opt
        table_section = _result
        # Begin List
        # CustomSection*
        staging5 = []
        while True:
            checkpoint5 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint5
                break
            staging5.append(_result)
        _result = staging5
        _status = True
        # End List
        custom5 = _result
        # Begin Opt
        # Opt(MemorySection)
        backtrack5 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemorySection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack5
            _result = None
            _status = True
        # End Opt
        memory_section = _result
        # Begin List
        # CustomSection*
        staging6 = []
        while True:
            checkpoint6 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint6
                break
            staging6.append(_result)
        _result = staging6
        _status = True
        # End List
        custom6 = _result
        # Begin Opt
        # Opt(GlobalSection)
        backtrack6 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack6
            _result = None
            _status = True
        # End Opt
        global_section = _result
        # Begin List
        # CustomSection*
        staging7 = []
        while True:
            checkpoint7 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint7
                break
            staging7.append(_result)
        _result = staging7
        _status = True
        # End List
        custom7 = _result
        # Begin Opt
        # Opt(ExportSection)
        backtrack7 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ExportSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack7
            _result = None
            _status = True
        # End Opt
        export_section = _result
        # Begin List
        # CustomSection*
        staging8 = []
        while True:
            checkpoint8 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint8
                break
            staging8.append(_result)
        _result = staging8
        _status = True
        # End List
        custom8 = _result
        # Begin Opt
        # Opt(StartSection)
        backtrack8 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_StartSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack8
            _result = None
            _status = True
        # End Opt
        start_section = _result
        # Begin List
        # CustomSection*
        staging9 = []
        while True:
            checkpoint9 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint9
                break
            staging9.append(_result)
        _result = staging9
        _status = True
        # End List
        custom9 = _result
        # Begin Opt
        # Opt(ElementSection)
        backtrack9 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ElementSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack9
            _result = None
            _status = True
        # End Opt
        element_section = _result
        # Begin List
        # CustomSection*
        staging10 = []
        while True:
            checkpoint10 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint10
                break
            staging10.append(_result)
        _result = staging10
        _status = True
        # End List
        custom10 = _result
        # Begin Opt
        # Opt(DataCountSection)
        backtrack10 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataCountSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack10
            _result = None
            _status = True
        # End Opt
        data_count_section = _result
        # Begin List
        # CustomSection*
        staging11 = []
        while True:
            checkpoint11 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint11
                break
            staging11.append(_result)
        _result = staging11
        _status = True
        # End List
        custom11 = _result
        # Begin Opt
        # Opt(CodeSection)
        backtrack11 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_CodeSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack11
            _result = None
            _status = True
        # End Opt
        code_section = _result
        # Begin List
        # CustomSection*
        staging12 = []
        while True:
            checkpoint12 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint12
                break
            staging12.append(_result)
        _result = staging12
        _status = True
        # End List
        custom12 = _result
        # Begin Opt
        # Opt(DataSection)
        backtrack12 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DataSection, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack12
            _result = None
            _status = True
        # End Opt
        data_section = _result
        # Begin List
        # CustomSection*
        staging13 = []
        while True:
            checkpoint13 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_CustomSection, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint13
                break
            staging13.append(_result)
        _result = staging13
        _status = True
        # End List
        custom13 = _result
        _result = Module(custom1, type_section, custom2, import_section, custom3, function_section, custom4, table_section, custom5, memory_section, custom6, global_section, custom7, export_section, custom8, start_section, custom9, element_section, custom10, data_count_section, custom11, code_section, custom12, data_section, custom13)
        _result._metadata.position_info = (start_pos1, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error4(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x00asm'\n\n"
    "Expected to match the string b'\\x00asm'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error6(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Module' rule, at the expression:\n"
    "    b'\\x01\\x00\\x00\\x00'\n\n"
    "Expected to match the string b'\\x01\\x00\\x00\\x00'"
    )
    raise ParseError((title + details), _pos, line, col)

class CustomSection(Node):
    """
    class CustomSection {
        let id: 0x0
        let size: u32
        let loc: LocatedName
        let remaining: `size - (loc.end - loc.start)`
        name: `loc.name`
        body: ByteString(remaining)
    }
    """
    _fields = ('name', 'body')

    id = 0x0

    def __init__(self, name, body):
        Node.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'CustomSection(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CustomSection, fullparse)


def _try_CustomSection(_text, _pos):
    # Begin Seq
    start_pos2 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error85
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_LocatedName, _pos))
        # End Ref
        if not (_status):
            break
        loc = _result
        _result = size - (loc.end - loc.start)
        _status = True
        remaining = _result
        _result = loc.name
        _status = True
        name = _result
        # Begin Call
        # ByteString(remaining)
        func1 = _ParseFunction(_try_ByteString, (remaining,), ())
        (_status, _result, _pos) = (yield (3, func1, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = CustomSection(name, body)
        _result._metadata.position_info = (start_pos2, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error85(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CustomSection' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class TypeSection(Node):
    """
    class TypeSection {
        let id: 0x1
        let size: u32
        function_types: vec(FuncType)
    }
    """
    _fields = ('function_types',)

    id = 0x1

    def __init__(self, function_types):
        Node.__init__(self)
        self.function_types = function_types

    def __repr__(self):
        return f'TypeSection(function_types={self.function_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TypeSection, fullparse)


def _try_TypeSection(_text, _pos):
    # Begin Seq
    start_pos3 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error101
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(FuncType)
        func2 = _ParseFunction(_try_vec, (_try_FuncType,), ())
        (_status, _result, _pos) = (yield (3, func2, _pos))
        # End Call
        if not (_status):
            break
        function_types = _result
        _result = TypeSection(function_types)
        _result._metadata.position_info = (start_pos3, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error101(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TypeSection' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportSection(Node):
    """
    class ImportSection {
        let id: 0x2
        let size: u32
        imports: vec(Import)
    }
    """
    _fields = ('imports',)

    id = 0x2

    def __init__(self, imports):
        Node.__init__(self)
        self.imports = imports

    def __repr__(self):
        return f'ImportSection(imports={self.imports!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportSection, fullparse)


def _try_ImportSection(_text, _pos):
    # Begin Seq
    start_pos4 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error111
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Import)
        func3 = _ParseFunction(_try_vec, (_try_Import,), ())
        (_status, _result, _pos) = (yield (3, func3, _pos))
        # End Call
        if not (_status):
            break
        imports = _result
        _result = ImportSection(imports)
        _result._metadata.position_info = (start_pos4, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error111(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportSection' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class FunctionSection(Node):
    """
    class FunctionSection {
        let id: 0x3
        let size: u32
        type_indexes: vec(u32)
    }
    """
    _fields = ('type_indexes',)

    id = 0x3

    def __init__(self, type_indexes):
        Node.__init__(self)
        self.type_indexes = type_indexes

    def __repr__(self):
        return f'FunctionSection(type_indexes={self.type_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_FunctionSection, fullparse)


def _try_FunctionSection(_text, _pos):
    # Begin Seq
    start_pos5 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error121
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(u32)
        func4 = _ParseFunction(_try_vec, (_try_u32,), ())
        (_status, _result, _pos) = (yield (3, func4, _pos))
        # End Call
        if not (_status):
            break
        type_indexes = _result
        _result = FunctionSection(type_indexes)
        _result._metadata.position_info = (start_pos5, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error121(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FunctionSection' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class TableSection(Node):
    """
    class TableSection {
        let id: 0x4
        let size: u32
        table_types: vec(TableType)
    }
    """
    _fields = ('table_types',)

    id = 0x4

    def __init__(self, table_types):
        Node.__init__(self)
        self.table_types = table_types

    def __repr__(self):
        return f'TableSection(table_types={self.table_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TableSection, fullparse)


def _try_TableSection(_text, _pos):
    # Begin Seq
    start_pos6 = _pos
    while True:
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error131
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(TableType)
        func5 = _ParseFunction(_try_vec, (_try_TableType,), ())
        (_status, _result, _pos) = (yield (3, func5, _pos))
        # End Call
        if not (_status):
            break
        table_types = _result
        _result = TableSection(table_types)
        _result._metadata.position_info = (start_pos6, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error131(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TableSection' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

class MemorySection(Node):
    """
    class MemorySection {
        let id: 0x5
        let size: u32
        memory_types: vec(MemoryType)
    }
    """
    _fields = ('memory_types',)

    id = 0x5

    def __init__(self, memory_types):
        Node.__init__(self)
        self.memory_types = memory_types

    def __repr__(self):
        return f'MemorySection(memory_types={self.memory_types!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MemorySection, fullparse)


def _try_MemorySection(_text, _pos):
    # Begin Seq
    start_pos7 = _pos
    while True:
        # Begin Byte
        # 0x5
        if (_pos < len(_text)) and (_text[_pos] == 5):
            _result = 5
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error141
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(MemoryType)
        func6 = _ParseFunction(_try_vec, (_try_MemoryType,), ())
        (_status, _result, _pos) = (yield (3, func6, _pos))
        # End Call
        if not (_status):
            break
        memory_types = _result
        _result = MemorySection(memory_types)
        _result._metadata.position_info = (start_pos7, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error141(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MemorySection' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

class GlobalSection(Node):
    """
    class GlobalSection {
        let id: 0x6
        let size: u32
        globals: vec(Global)
    }
    """
    _fields = ('globals',)

    id = 0x6

    def __init__(self, globals):
        Node.__init__(self)
        self.globals = globals

    def __repr__(self):
        return f'GlobalSection(globals={self.globals!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_GlobalSection, fullparse)


def _try_GlobalSection(_text, _pos):
    # Begin Seq
    start_pos8 = _pos
    while True:
        # Begin Byte
        # 0x6
        if (_pos < len(_text)) and (_text[_pos] == 6):
            _result = 6
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error151
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Global)
        func7 = _ParseFunction(_try_vec, (_try_Global,), ())
        (_status, _result, _pos) = (yield (3, func7, _pos))
        # End Call
        if not (_status):
            break
        globals = _result
        _result = GlobalSection(globals)
        _result._metadata.position_info = (start_pos8, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error151(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalSection' rule, at the expression:\n"
    '    0x6\n\n'
    'Expected to match the byte value 0x6'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportSection(Node):
    """
    class ExportSection {
        let id: 0x7
        let size: u32
        exports: vec(Export)
    }
    """
    _fields = ('exports',)

    id = 0x7

    def __init__(self, exports):
        Node.__init__(self)
        self.exports = exports

    def __repr__(self):
        return f'ExportSection(exports={self.exports!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportSection, fullparse)


def _try_ExportSection(_text, _pos):
    # Begin Seq
    start_pos9 = _pos
    while True:
        # Begin Byte
        # 0x7
        if (_pos < len(_text)) and (_text[_pos] == 7):
            _result = 7
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error161
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Export)
        func8 = _ParseFunction(_try_vec, (_try_Export,), ())
        (_status, _result, _pos) = (yield (3, func8, _pos))
        # End Call
        if not (_status):
            break
        exports = _result
        _result = ExportSection(exports)
        _result._metadata.position_info = (start_pos9, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error161(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportSection' rule, at the expression:\n"
    '    0x7\n\n'
    'Expected to match the byte value 0x7'
    )
    raise ParseError((title + details), _pos, line, col)

class StartSection(Node):
    """
    class StartSection {
        let id: 0x8
        let size: u32
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x8

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'StartSection(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_StartSection, fullparse)


def _try_StartSection(_text, _pos):
    # Begin Seq
    start_pos10 = _pos
    while True:
        # Begin Byte
        # 0x8
        if (_pos < len(_text)) and (_text[_pos] == 8):
            _result = 8
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error171
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = StartSection(index)
        _result._metadata.position_info = (start_pos10, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error171(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'StartSection' rule, at the expression:\n"
    '    0x8\n\n'
    'Expected to match the byte value 0x8'
    )
    raise ParseError((title + details), _pos, line, col)

class ElementSection(Node):
    """
    class ElementSection {
        let id: 0x9
        let size: u32
        segments: vec(ElementSegment)
    }
    """
    _fields = ('segments',)

    id = 0x9

    def __init__(self, segments):
        Node.__init__(self)
        self.segments = segments

    def __repr__(self):
        return f'ElementSection(segments={self.segments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ElementSection, fullparse)


def _try_ElementSection(_text, _pos):
    # Begin Seq
    start_pos11 = _pos
    while True:
        # Begin Byte
        # 0x9
        if (_pos < len(_text)) and (_text[_pos] == 9):
            _result = 9
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error179
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(ElementSegment)
        func9 = _ParseFunction(_try_vec, (_try_ElementSegment,), ())
        (_status, _result, _pos) = (yield (3, func9, _pos))
        # End Call
        if not (_status):
            break
        segments = _result
        _result = ElementSection(segments)
        _result._metadata.position_info = (start_pos11, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error179(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementSection' rule, at the expression:\n"
    '    0x9\n\n'
    'Expected to match the byte value 0x9'
    )
    raise ParseError((title + details), _pos, line, col)

class DataCountSection(Node):
    """
    class DataCountSection {
        let id: 0xc
        let size: u32
        count: Opt(u32 where `lambda _: size > 0`)
    }
    """
    _fields = ('count',)

    id = 0xc

    def __init__(self, count):
        Node.__init__(self)
        self.count = count

    def __repr__(self):
        return f'DataCountSection(count={self.count!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DataCountSection, fullparse)


def _try_DataCountSection(_text, _pos):
    # Begin Seq
    start_pos12 = _pos
    while True:
        # Begin Byte
        # 0xc
        if (_pos < len(_text)) and (_text[_pos] == 12):
            _result = 12
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error189
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Opt
        # Opt(u32 where `lambda _: size > 0`)
        backtrack13 = _pos
        # Begin Where
        # u32 where `lambda _: size > 0`
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if _status:
            arg1 = _result
            _result = lambda _: size > 0
            _status = True
            if _result(arg1):
                _result = arg1
            else:
                _result = _raise_error194
                _status = False
        # End Where
        if not (_status):
            _pos = backtrack13
            _result = None
            _status = True
        # End Opt
        count = _result
        _result = DataCountSection(count)
        _result._metadata.position_info = (start_pos12, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error189(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataCountSection' rule, at the expression:\n"
    '    0xc\n\n'
    'Expected to match the byte value 0xc'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error194(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataCountSection' rule, at the expression:\n"
    '    u32 where `lambda _: size > 0`\n\n'
    'Expected to satisfy the predicate: `lambda _: size > 0`'
    )
    raise ParseError((title + details), _pos, line, col)

class CodeSection(Node):
    """
    class CodeSection {
        let id: 0xa
        let size: u32
        entries: vec(CodeEntry)
    }
    """
    _fields = ('entries',)

    id = 0xa

    def __init__(self, entries):
        Node.__init__(self)
        self.entries = entries

    def __repr__(self):
        return f'CodeSection(entries={self.entries!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CodeSection, fullparse)


def _try_CodeSection(_text, _pos):
    # Begin Seq
    start_pos13 = _pos
    while True:
        # Begin Byte
        # 0xa
        if (_pos < len(_text)) and (_text[_pos] == 10):
            _result = 10
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error200
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(CodeEntry)
        func10 = _ParseFunction(_try_vec, (_try_CodeEntry,), ())
        (_status, _result, _pos) = (yield (3, func10, _pos))
        # End Call
        if not (_status):
            break
        entries = _result
        _result = CodeSection(entries)
        _result._metadata.position_info = (start_pos13, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error200(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CodeSection' rule, at the expression:\n"
    '    0xa\n\n'
    'Expected to match the byte value 0xa'
    )
    raise ParseError((title + details), _pos, line, col)

class DataSection(Node):
    """
    class DataSection {
        let id: 0xb
        let size: u32
        segments: vec(DefaultDataSegment | PassiveDataSegment | ActiveDataSegment)
    }
    """
    _fields = ('segments',)

    id = 0xb

    def __init__(self, segments):
        Node.__init__(self)
        self.segments = segments

    def __repr__(self):
        return f'DataSection(segments={self.segments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DataSection, fullparse)


def _parse_function_216(_text, _pos):
    # Begin Choice
    farthest_err1 = _raise_error216
    backtrack14 = farthest_pos1 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DefaultDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack14
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack14
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveDataSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = farthest_pos1
        _result = farthest_err1
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_DataSection(_text, _pos):
    # Begin Seq
    start_pos14 = _pos
    while True:
        # Begin Byte
        # 0xb
        if (_pos < len(_text)) and (_text[_pos] == 11):
            _result = 11
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error210
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(DefaultDataSegment | PassiveDataSegment | ActiveDataSegment)
        func11 = _ParseFunction(_try_vec, (_parse_function_216,), ())
        (_status, _result, _pos) = (yield (3, func11, _pos))
        # End Call
        if not (_status):
            break
        segments = _result
        _result = DataSection(segments)
        _result._metadata.position_info = (start_pos14, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error210(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataSection' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error216(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DataSection' rule, at the expression:\n"
    '    DefaultDataSegment | PassiveDataSegment | ActiveDataSegment\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Global(Node):
    """
    class Global {
        type: GlobalType
        initializer: Expression
    }
    """
    _fields = ('type', 'initializer')

    def __init__(self, type, initializer):
        Node.__init__(self)
        self.type = type
        self.initializer = initializer

    def __repr__(self):
        return f'Global(type={self.type!r}, initializer={self.initializer!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Global, fullparse)


def _try_Global(_text, _pos):
    # Begin Seq
    start_pos15 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        initializer = _result
        _result = Global(type, initializer)
        _result._metadata.position_info = (start_pos15, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Import(Node):
    """
    class Import {
        module: Name
        name: Name
        descriptor: ImportFunc | ImportTable | ImportMemory | ImportGlobal
    }
    """
    _fields = ('module', 'name', 'descriptor')

    def __init__(self, module, name, descriptor):
        Node.__init__(self)
        self.module = module
        self.name = name
        self.descriptor = descriptor

    def __repr__(self):
        return f'Import(module={self.module!r}, name={self.name!r}, descriptor={self.descriptor!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Import, fullparse)


def _try_Import(_text, _pos):
    # Begin Seq
    start_pos16 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        module = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Choice
        farthest_err2 = _raise_error233
        backtrack15 = farthest_pos2 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportFunc, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportTable, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 3:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportMemory, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = backtrack15
            # Option 4:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ImportGlobal, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos2 < _pos):
                farthest_pos2 = _pos
                farthest_err2 = _result
            _pos = farthest_pos2
            _result = farthest_err2
            break
        # End Choice
        if not (_status):
            break
        descriptor = _result
        _result = Import(module, name, descriptor)
        _result._metadata.position_info = (start_pos16, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error233(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Import' rule, at the expression:\n"
    '    ImportFunc | ImportTable | ImportMemory | ImportGlobal\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportFunc(Node):
    """
    class ImportFunc {
        let id: 0x0
        type: u32
    }
    """
    _fields = ('type',)

    id = 0x0

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportFunc(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportFunc, fullparse)


def _try_ImportFunc(_text, _pos):
    # Begin Seq
    start_pos17 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error241
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportFunc(type)
        _result._metadata.position_info = (start_pos17, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error241(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportFunc' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportTable(Node):
    """
    class ImportTable {
        let id: 0x1
        type: TableType
    }
    """
    _fields = ('type',)

    id = 0x1

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportTable(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportTable, fullparse)


def _try_ImportTable(_text, _pos):
    # Begin Seq
    start_pos18 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error247
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_TableType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportTable(type)
        _result._metadata.position_info = (start_pos18, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error247(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportTable' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportMemory(Node):
    """
    class ImportMemory {
        let id: 0x2
        type: MemoryType
    }
    """
    _fields = ('type',)

    id = 0x2

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportMemory(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportMemory, fullparse)


def _try_ImportMemory(_text, _pos):
    # Begin Seq
    start_pos19 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error253
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MemoryType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportMemory(type)
        _result._metadata.position_info = (start_pos19, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error253(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportMemory' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class ImportGlobal(Node):
    """
    class ImportGlobal {
        let id: 0x3
        type: GlobalType
    }
    """
    _fields = ('type',)

    id = 0x3

    def __init__(self, type):
        Node.__init__(self)
        self.type = type

    def __repr__(self):
        return f'ImportGlobal(type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ImportGlobal, fullparse)


def _try_ImportGlobal(_text, _pos):
    # Begin Seq
    start_pos20 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error259
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GlobalType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = ImportGlobal(type)
        _result._metadata.position_info = (start_pos20, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error259(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ImportGlobal' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

class Export(Node):
    """
    class Export {
        name: Name
        descriptor: ExportFunc | ExportTable | ExportMemory | ExportGlobal
    }
    """
    _fields = ('name', 'descriptor')

    def __init__(self, name, descriptor):
        Node.__init__(self)
        self.name = name
        self.descriptor = descriptor

    def __repr__(self):
        return f'Export(name={self.name!r}, descriptor={self.descriptor!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Export, fullparse)


def _try_Export(_text, _pos):
    # Begin Seq
    start_pos21 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Choice
        farthest_err3 = _raise_error267
        backtrack16 = farthest_pos3 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportFunc, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportTable, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 3:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportMemory, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = backtrack16
            # Option 4:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_ExportGlobal, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos3 < _pos):
                farthest_pos3 = _pos
                farthest_err3 = _result
            _pos = farthest_pos3
            _result = farthest_err3
            break
        # End Choice
        if not (_status):
            break
        descriptor = _result
        _result = Export(name, descriptor)
        _result._metadata.position_info = (start_pos21, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error267(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Export' rule, at the expression:\n"
    '    ExportFunc | ExportTable | ExportMemory | ExportGlobal\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportFunc(Node):
    """
    class ExportFunc {
        let id: 0x0
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x0

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportFunc(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportFunc, fullparse)


def _try_ExportFunc(_text, _pos):
    # Begin Seq
    start_pos22 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error275
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportFunc(index)
        _result._metadata.position_info = (start_pos22, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error275(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportFunc' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportTable(Node):
    """
    class ExportTable {
        let id: 0x1
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x1

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportTable(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportTable, fullparse)


def _try_ExportTable(_text, _pos):
    # Begin Seq
    start_pos23 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error281
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportTable(index)
        _result._metadata.position_info = (start_pos23, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error281(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportTable' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportMemory(Node):
    """
    class ExportMemory {
        let id: 0x2
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x2

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportMemory(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportMemory, fullparse)


def _try_ExportMemory(_text, _pos):
    # Begin Seq
    start_pos24 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error287
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportMemory(index)
        _result._metadata.position_info = (start_pos24, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error287(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportMemory' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

class ExportGlobal(Node):
    """
    class ExportGlobal {
        let id: 0x3
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x3

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ExportGlobal(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ExportGlobal, fullparse)


def _try_ExportGlobal(_text, _pos):
    # Begin Seq
    start_pos25 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error293
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = ExportGlobal(index)
        _result._metadata.position_info = (start_pos25, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error293(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ExportGlobal' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ElementSegment(_text, _pos):
    # Rule 'ElementSegment'
    # Begin Choice
    farthest_err4 = _raise_error297
    backtrack17 = farthest_pos4 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DefaultSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DeclarativeFuncRefSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DefaultExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_PassiveExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 7:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ActiveExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack17
        # Option 8:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_DeclarativeExpressionSegment, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = farthest_pos4
        _result = farthest_err4
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ElementSegment(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ElementSegment, fullparse)

ElementSegment = Rule('ElementSegment', _parse_ElementSegment, """
    ElementSegment = DefaultSegment | PassiveFuncRefSegment | ActiveFuncRefSegment | DeclarativeFuncRefSegment | DefaultExpressionSegment | PassiveExpressionSegment | ActiveExpressionSegment | DeclarativeExpressionSegment
""")
def _raise_error297(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementSegment' rule, at the expression:\n"
    '    DefaultSegment | PassiveFuncRefSegment | ActiveFuncRefSegment | DeclarativeFuncRefSegment | DefaultExpressionSegment | PassiveExpressionSegment | ActiveExpressionSegment | DeclarativeExpressionSegment\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class DefaultSegment(Node):
    """
    class DefaultSegment {
        let id: 0x0
        offset: Expression
        function_indexes: vec(u32)
    }
    """
    _fields = ('offset', 'function_indexes')

    id = 0x0

    def __init__(self, offset, function_indexes):
        Node.__init__(self)
        self.offset = offset
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'DefaultSegment(offset={self.offset!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DefaultSegment, fullparse)


def _try_DefaultSegment(_text, _pos):
    # Begin Seq
    start_pos26 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error309
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Call
        # vec(u32)
        func12 = _ParseFunction(_try_vec, (_try_u32,), ())
        (_status, _result, _pos) = (yield (3, func12, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = DefaultSegment(offset, function_indexes)
        _result._metadata.position_info = (start_pos26, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error309(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DefaultSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveFuncRefSegment(Node):
    """
    class PassiveFuncRefSegment {
        let id: 0x1
        type: 0x0 >> `'funcref'`
        function_indexes: vec(u32)
    }
    """
    _fields = ('type', 'function_indexes')

    id = 0x1

    def __init__(self, type, function_indexes):
        Node.__init__(self)
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'PassiveFuncRefSegment(type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveFuncRefSegment, fullparse)


def _try_PassiveFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos27 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error319
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error322
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(u32)
        func13 = _ParseFunction(_try_vec, (_try_u32,), ())
        (_status, _result, _pos) = (yield (3, func13, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = PassiveFuncRefSegment(type, function_indexes)
        _result._metadata.position_info = (start_pos27, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error319(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveFuncRefSegment' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error322(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveFuncRefSegment(Node):
    """
    class ActiveFuncRefSegment {
        let id: 0x2
        table_index: u32
        offset: Expression
        type: 0x0 >> `'funcref'`
        function_indexes: vec(u32)
    }
    """
    _fields = ('table_index', 'offset', 'type', 'function_indexes')

    id = 0x2

    def __init__(self, table_index, offset, type, function_indexes):
        Node.__init__(self)
        self.table_index = table_index
        self.offset = offset
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'ActiveFuncRefSegment(table_index={self.table_index!r}, offset={self.offset!r}, type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveFuncRefSegment, fullparse)


def _try_ActiveFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos28 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error331
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        table_index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error338
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(u32)
        func14 = _ParseFunction(_try_vec, (_try_u32,), ())
        (_status, _result, _pos) = (yield (3, func14, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = ActiveFuncRefSegment(table_index, offset, type, function_indexes)
        _result._metadata.position_info = (start_pos28, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error331(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveFuncRefSegment' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error338(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class DeclarativeFuncRefSegment(Node):
    """
    class DeclarativeFuncRefSegment {
        let id: 0x3
        type: 0x0 >> `'funcref'`
        function_indexes: vec(u32)
    }
    """
    _fields = ('type', 'function_indexes')

    id = 0x3

    def __init__(self, type, function_indexes):
        Node.__init__(self)
        self.type = type
        self.function_indexes = function_indexes

    def __repr__(self):
        return f'DeclarativeFuncRefSegment(type={self.type!r}, function_indexes={self.function_indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DeclarativeFuncRefSegment, fullparse)


def _try_DeclarativeFuncRefSegment(_text, _pos):
    # Begin Seq
    start_pos29 = _pos
    while True:
        # Begin Byte
        # 0x3
        if (_pos < len(_text)) and (_text[_pos] == 3):
            _result = 3
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error347
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Discard
        # 0x0 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x0
            if (_pos < len(_text)) and (_text[_pos] == 0):
                _result = 0
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error350
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(u32)
        func15 = _ParseFunction(_try_vec, (_try_u32,), ())
        (_status, _result, _pos) = (yield (3, func15, _pos))
        # End Call
        if not (_status):
            break
        function_indexes = _result
        _result = DeclarativeFuncRefSegment(type, function_indexes)
        _result._metadata.position_info = (start_pos29, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error347(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeFuncRefSegment' rule, at the expression:\n"
    '    0x3\n\n'
    'Expected to match the byte value 0x3'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error350(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeFuncRefSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class DefaultExpressionSegment(Node):
    """
    class DefaultExpressionSegment {
        let id: 0x4
        offset: Expression
        initializers: vec(Expression)
    }
    """
    _fields = ('offset', 'initializers')

    id = 0x4

    def __init__(self, offset, initializers):
        Node.__init__(self)
        self.offset = offset
        self.initializers = initializers

    def __repr__(self):
        return f'DefaultExpressionSegment(offset={self.offset!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DefaultExpressionSegment, fullparse)


def _try_DefaultExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos30 = _pos
    while True:
        # Begin Byte
        # 0x4
        if (_pos < len(_text)) and (_text[_pos] == 4):
            _result = 4
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error359
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Call
        # vec(Expression)
        func16 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func16, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = DefaultExpressionSegment(offset, initializers)
        _result._metadata.position_info = (start_pos30, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error359(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DefaultExpressionSegment' rule, at the expression:\n"
    '    0x4\n\n'
    'Expected to match the byte value 0x4'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveExpressionSegment(Node):
    """
    class PassiveExpressionSegment {
        let id: 0x5
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('type', 'initializers')

    id = 0x5

    def __init__(self, type, initializers):
        Node.__init__(self)
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'PassiveExpressionSegment(type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveExpressionSegment, fullparse)


def _try_PassiveExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos31 = _pos
    while True:
        # Begin Byte
        # 0x5
        if (_pos < len(_text)) and (_text[_pos] == 5):
            _result = 5
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error369
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func17 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func17, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = PassiveExpressionSegment(type, initializers)
        _result._metadata.position_info = (start_pos31, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error369(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveExpressionSegment' rule, at the expression:\n"
    '    0x5\n\n'
    'Expected to match the byte value 0x5'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveExpressionSegment(Node):
    """
    class ActiveExpressionSegment {
        let id: 0x6
        table_index: u32
        offset: Expression
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('table_index', 'offset', 'type', 'initializers')

    id = 0x6

    def __init__(self, table_index, offset, type, initializers):
        Node.__init__(self)
        self.table_index = table_index
        self.offset = offset
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'ActiveExpressionSegment(table_index={self.table_index!r}, offset={self.offset!r}, type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveExpressionSegment, fullparse)


def _try_ActiveExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos32 = _pos
    while True:
        # Begin Byte
        # 0x6
        if (_pos < len(_text)) and (_text[_pos] == 6):
            _result = 6
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error379
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        table_index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func18 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func18, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = ActiveExpressionSegment(table_index, offset, type, initializers)
        _result._metadata.position_info = (start_pos32, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error379(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveExpressionSegment' rule, at the expression:\n"
    '    0x6\n\n'
    'Expected to match the byte value 0x6'
    )
    raise ParseError((title + details), _pos, line, col)

class DeclarativeExpressionSegment(Node):
    """
    class DeclarativeExpressionSegment {
        let id: 0x7
        type: ReferenceType
        initializers: vec(Expression)
    }
    """
    _fields = ('type', 'initializers')

    id = 0x7

    def __init__(self, type, initializers):
        Node.__init__(self)
        self.type = type
        self.initializers = initializers

    def __repr__(self):
        return f'DeclarativeExpressionSegment(type={self.type!r}, initializers={self.initializers!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DeclarativeExpressionSegment, fullparse)


def _try_DeclarativeExpressionSegment(_text, _pos):
    # Begin Seq
    start_pos33 = _pos
    while True:
        # Begin Byte
        # 0x7
        if (_pos < len(_text)) and (_text[_pos] == 7):
            _result = 7
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error393
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Call
        # vec(Expression)
        func19 = _ParseFunction(_try_vec, (_try_Expression,), ())
        (_status, _result, _pos) = (yield (3, func19, _pos))
        # End Call
        if not (_status):
            break
        initializers = _result
        _result = DeclarativeExpressionSegment(type, initializers)
        _result._metadata.position_info = (start_pos33, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error393(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DeclarativeExpressionSegment' rule, at the expression:\n"
    '    0x7\n\n'
    'Expected to match the byte value 0x7'
    )
    raise ParseError((title + details), _pos, line, col)

class DefaultDataSegment(Node):
    """
    class DefaultDataSegment {
        let id: 0x0
        offset: Expression
        contents: ByteVector
    }
    """
    _fields = ('offset', 'contents')

    id = 0x0

    def __init__(self, offset, contents):
        Node.__init__(self)
        self.offset = offset
        self.contents = contents

    def __repr__(self):
        return f'DefaultDataSegment(offset={self.offset!r}, contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_DefaultDataSegment, fullparse)


def _try_DefaultDataSegment(_text, _pos):
    # Begin Seq
    start_pos34 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error403
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = DefaultDataSegment(offset, contents)
        _result._metadata.position_info = (start_pos34, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error403(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'DefaultDataSegment' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class PassiveDataSegment(Node):
    """
    class PassiveDataSegment {
        let id: 0x1
        contents: ByteVector
    }
    """
    _fields = ('contents',)

    id = 0x1

    def __init__(self, contents):
        Node.__init__(self)
        self.contents = contents

    def __repr__(self):
        return f'PassiveDataSegment(contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_PassiveDataSegment, fullparse)


def _try_PassiveDataSegment(_text, _pos):
    # Begin Seq
    start_pos35 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error411
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = PassiveDataSegment(contents)
        _result._metadata.position_info = (start_pos35, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error411(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'PassiveDataSegment' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class ActiveDataSegment(Node):
    """
    class ActiveDataSegment {
        let id: 0x2
        index: u32
        offset: Expression
        contents: ByteVector
    }
    """
    _fields = ('index', 'offset', 'contents')

    id = 0x2

    def __init__(self, index, offset, contents):
        Node.__init__(self)
        self.index = index
        self.offset = offset
        self.contents = contents

    def __repr__(self):
        return f'ActiveDataSegment(index={self.index!r}, offset={self.offset!r}, contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ActiveDataSegment, fullparse)


def _try_ActiveDataSegment(_text, _pos):
    # Begin Seq
    start_pos36 = _pos
    while True:
        # Begin Byte
        # 0x2
        if (_pos < len(_text)) and (_text[_pos] == 2):
            _result = 2
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error417
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        offset = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ByteVector, _pos))
        # End Ref
        if not (_status):
            break
        contents = _result
        _result = ActiveDataSegment(index, offset, contents)
        _result._metadata.position_info = (start_pos36, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error417(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ActiveDataSegment' rule, at the expression:\n"
    '    0x2\n\n'
    'Expected to match the byte value 0x2'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Limits(_text, _pos):
    # Rule 'Limits'
    # Begin Choice
    farthest_err5 = _raise_error425
    backtrack18 = farthest_pos5 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MinLimit, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack18
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_MinMaxLimits, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = farthest_pos5
        _result = farthest_err5
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Limits(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Limits, fullparse)

Limits = Rule('Limits', _parse_Limits, """
    Limits = MinLimit | MinMaxLimits
""")
def _raise_error425(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Limits' rule, at the expression:\n"
    '    MinLimit | MinMaxLimits\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class MinLimit(Node):
    """
    class MinLimit {
        let id: 0x0
        min: u32
    }
    """
    _fields = ('min',)

    id = 0x0

    def __init__(self, min):
        Node.__init__(self)
        self.min = min

    def __repr__(self):
        return f'MinLimit(min={self.min!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MinLimit, fullparse)


def _try_MinLimit(_text, _pos):
    # Begin Seq
    start_pos37 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error431
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        min = _result
        _result = MinLimit(min)
        _result._metadata.position_info = (start_pos37, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error431(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MinLimit' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class MinMaxLimits(Node):
    """
    class MinMaxLimits {
        let id: 0x1
        min: u32
        max: u32
    }
    """
    _fields = ('min', 'max')

    id = 0x1

    def __init__(self, min, max):
        Node.__init__(self)
        self.min = min
        self.max = max

    def __repr__(self):
        return f'MinMaxLimits(min={self.min!r}, max={self.max!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MinMaxLimits, fullparse)


def _try_MinMaxLimits(_text, _pos):
    # Begin Seq
    start_pos38 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error437
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        min = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        max = _result
        _result = MinMaxLimits(min, max)
        _result._metadata.position_info = (start_pos38, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error437(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MinMaxLimits' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class FuncType(Node):
    """
    class FuncType {
        let id: 0x60
        params: vec(ValueType)
        results: vec(ValueType)
    }
    """
    _fields = ('params', 'results')

    id = 0x60

    def __init__(self, params, results):
        Node.__init__(self)
        self.params = params
        self.results = results

    def __repr__(self):
        return f'FuncType(params={self.params!r}, results={self.results!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_FuncType, fullparse)


def _try_FuncType(_text, _pos):
    # Begin Seq
    start_pos39 = _pos
    while True:
        # Begin Byte
        # 0x60
        if (_pos < len(_text)) and (_text[_pos] == 96):
            _result = 96
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error445
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Call
        # vec(ValueType)
        func20 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func20, _pos))
        # End Call
        if not (_status):
            break
        params = _result
        # Begin Call
        # vec(ValueType)
        func21 = _ParseFunction(_try_vec, (_try_ValueType,), ())
        (_status, _result, _pos) = (yield (3, func21, _pos))
        # End Call
        if not (_status):
            break
        results = _result
        _result = FuncType(params, results)
        _result._metadata.position_info = (start_pos39, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error445(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FuncType' rule, at the expression:\n"
    '    0x60\n\n'
    'Expected to match the byte value 0x60'
    )
    raise ParseError((title + details), _pos, line, col)

class GlobalType(Node):
    """
    class GlobalType {
        type: ValueType
        modifier: 0x0 >> `'const'` | 0x1 >> `'var'`
    }
    """
    _fields = ('type', 'modifier')

    def __init__(self, type, modifier):
        Node.__init__(self)
        self.type = type
        self.modifier = modifier

    def __repr__(self):
        return f'GlobalType(type={self.type!r}, modifier={self.modifier!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_GlobalType, fullparse)


def _try_GlobalType(_text, _pos):
    # Begin Seq
    start_pos40 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ValueType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Choice
        farthest_err6 = _raise_error459
        backtrack19 = farthest_pos6 = _pos
        while True:
            # Option 1:
            # Begin Discard
            # 0x0 >> `'const'`
            while True:
                # Begin Byte
                # 0x0
                if (_pos < len(_text)) and (_text[_pos] == 0):
                    _result = 0
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error461
                    _status = False
                # End Byte
                if not (_status):
                    break
                _result = 'const'
                _status = True
                break
            # End Discard
            if _status:
                break
            if (farthest_pos6 < _pos):
                farthest_pos6 = _pos
                farthest_err6 = _result
            _pos = backtrack19
            # Option 2:
            # Begin Discard
            # 0x1 >> `'var'`
            while True:
                # Begin Byte
                # 0x1
                if (_pos < len(_text)) and (_text[_pos] == 1):
                    _result = 1
                    _pos = (_pos + 1)
                    _status = True
                else:
                    _result = _raise_error464
                    _status = False
                # End Byte
                if not (_status):
                    break
                _result = 'var'
                _status = True
                break
            # End Discard
            if _status:
                break
            if (farthest_pos6 < _pos):
                farthest_pos6 = _pos
                farthest_err6 = _result
            _pos = farthest_pos6
            _result = farthest_err6
            break
        # End Choice
        if not (_status):
            break
        modifier = _result
        _result = GlobalType(type, modifier)
        _result._metadata.position_info = (start_pos40, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error459(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    "    0x0 >> `'const'` | 0x1 >> `'var'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error461(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error464(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GlobalType' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class MemoryType(Node):
    """
    class MemoryType {
        limits: Limits
    }
    """
    _fields = ('limits',)

    def __init__(self, limits):
        Node.__init__(self)
        self.limits = limits

    def __repr__(self):
        return f'MemoryType(limits={self.limits!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_MemoryType, fullparse)


def _try_MemoryType(_text, _pos):
    # Begin Seq
    start_pos41 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Limits, _pos))
        # End Ref
        if not (_status):
            break
        limits = _result
        _result = MemoryType(limits)
        _result._metadata.position_info = (start_pos41, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_NumberType(_text, _pos):
    # Rule 'NumberType'
    # Begin Choice
    farthest_err7 = _raise_error471
    backtrack20 = farthest_pos7 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x7f >> `'i32'`
        while True:
            # Begin Byte
            # 0x7f
            if (_pos < len(_text)) and (_text[_pos] == 127):
                _result = 127
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error473
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack20
        # Option 2:
        # Begin Discard
        # 0x7e >> `'i64'`
        while True:
            # Begin Byte
            # 0x7e
            if (_pos < len(_text)) and (_text[_pos] == 126):
                _result = 126
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error476
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'i64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack20
        # Option 3:
        # Begin Discard
        # 0x7d >> `'f32'`
        while True:
            # Begin Byte
            # 0x7d
            if (_pos < len(_text)) and (_text[_pos] == 125):
                _result = 125
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error479
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f32'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack20
        # Option 4:
        # Begin Discard
        # 0x7c >> `'f64'`
        while True:
            # Begin Byte
            # 0x7c
            if (_pos < len(_text)) and (_text[_pos] == 124):
                _result = 124
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error482
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'f64'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = farthest_pos7
        _result = farthest_err7
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_NumberType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_NumberType, fullparse)

NumberType = Rule('NumberType', _parse_NumberType, """
    NumberType = 0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`
""")
def _raise_error471(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    "    0x7f >> `'i32'` | 0x7e >> `'i64'` | 0x7d >> `'f32'` | 0x7c >> `'f64'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error473(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7f\n\n'
    'Expected to match the byte value 0x7f'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error476(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7e\n\n'
    'Expected to match the byte value 0x7e'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error479(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7d\n\n'
    'Expected to match the byte value 0x7d'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error482(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberType' rule, at the expression:\n"
    '    0x7c\n\n'
    'Expected to match the byte value 0x7c'
    )
    raise ParseError((title + details), _pos, line, col)

class TableType(Node):
    """
    class TableType {
        type: ReferenceType
        limits: Limits
    }
    """
    _fields = ('type', 'limits')

    def __init__(self, type, limits):
        Node.__init__(self)
        self.type = type
        self.limits = limits

    def __repr__(self):
        return f'TableType(type={self.type!r}, limits={self.limits!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_TableType, fullparse)


def _try_TableType(_text, _pos):
    # Begin Seq
    start_pos42 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Limits, _pos))
        # End Ref
        if not (_status):
            break
        limits = _result
        _result = TableType(type, limits)
        _result._metadata.position_info = (start_pos42, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_ReferenceType(_text, _pos):
    # Rule 'ReferenceType'
    # Begin Choice
    farthest_err8 = _raise_error491
    backtrack21 = farthest_pos8 = _pos
    while True:
        # Option 1:
        # Begin Discard
        # 0x70 >> `'funcref'`
        while True:
            # Begin Byte
            # 0x70
            if (_pos < len(_text)) and (_text[_pos] == 112):
                _result = 112
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error493
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'funcref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = backtrack21
        # Option 2:
        # Begin Discard
        # 0x6f >> `'externref'`
        while True:
            # Begin Byte
            # 0x6f
            if (_pos < len(_text)) and (_text[_pos] == 111):
                _result = 111
                _pos = (_pos + 1)
                _status = True
            else:
                _result = _raise_error496
                _status = False
            # End Byte
            if not (_status):
                break
            _result = 'externref'
            _status = True
            break
        # End Discard
        if _status:
            break
        if (farthest_pos8 < _pos):
            farthest_pos8 = _pos
            farthest_err8 = _result
        _pos = farthest_pos8
        _result = farthest_err8
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ReferenceType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ReferenceType, fullparse)

ReferenceType = Rule('ReferenceType', _parse_ReferenceType, """
    ReferenceType = 0x70 >> `'funcref'` | 0x6f >> `'externref'`
""")
def _raise_error491(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    "    0x70 >> `'funcref'` | 0x6f >> `'externref'`\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error493(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x70\n\n'
    'Expected to match the byte value 0x70'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error496(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ReferenceType' rule, at the expression:\n"
    '    0x6f\n\n'
    'Expected to match the byte value 0x6f'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ValueType(_text, _pos):
    # Rule 'ValueType'
    # Begin Choice
    farthest_err9 = _raise_error499
    backtrack22 = farthest_pos9 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_NumberType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos9 < _pos):
            farthest_pos9 = _pos
            farthest_err9 = _result
        _pos = backtrack22
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ReferenceType, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos9 < _pos):
            farthest_pos9 = _pos
            farthest_err9 = _result
        _pos = farthest_pos9
        _result = farthest_err9
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_ValueType(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ValueType, fullparse)

ValueType = Rule('ValueType', _parse_ValueType, """
    ValueType = NumberType | ReferenceType
""")
def _raise_error499(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueType' rule, at the expression:\n"
    '    NumberType | ReferenceType\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_vec(_text, _pos, element):
    # Rule 'vec'
    # Begin Let
    # let length = u32 in
    # element{length}
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_u32, _pos))
    # End Ref
    if _status:
        length = _result
        # Begin List
        # element{length}
        staging14 = []
        while True:
            checkpoint14 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, element, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint14
                break
            staging14.append(_result)
            if (len(staging14) == length):
                break
        if (len(staging14) >= length):
            _result = staging14
            _status = True
        # End List
    # End Let
    yield (_status, _result, _pos)

def _parse_vec(text, pos=0, fullparse=True):
    return _run(text, pos, _try_vec, fullparse)

vec = Rule('vec', _parse_vec, """
    vec(element) = let length = u32 in
    element{length}
""")
def _try_ByteString(_text, _pos, size):
    # Rule 'ByteString'
    # Begin Apply
    # bytechar{size} |> `lambda x: b''.join(x)`
    # Begin List
    # bytechar{size}
    staging15 = []
    while True:
        checkpoint15 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_bytechar, _pos))
        # End Ref
        if not (_status):
            _pos = checkpoint15
            break
        staging15.append(_result)
        if (len(staging15) == size):
            break
    if (len(staging15) >= size):
        _result = staging15
        _status = True
    # End List
    if _status:
        arg2 = _result
        _result = lambda x: b''.join(x)
        _status = True
        _result = _result(arg2)
    # End Apply
    yield (_status, _result, _pos)

def _parse_ByteString(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ByteString, fullparse)

ByteString = Rule('ByteString', _parse_ByteString, """
    ByteString(size) = bytechar{size} |> `lambda x: b''.join(x)`
""")
def _try_ByteVector(_text, _pos):
    # Rule 'ByteVector'
    # Begin Apply
    # vec(bytechar) |> `lambda x: b''.join(x)`
    # Begin Call
    # vec(bytechar)
    func22 = _ParseFunction(_try_vec, (_try_bytechar,), ())
    (_status, _result, _pos) = (yield (3, func22, _pos))
    # End Call
    if _status:
        arg3 = _result
        _result = lambda x: b''.join(x)
        _status = True
        _result = _result(arg3)
    # End Apply
    yield (_status, _result, _pos)

def _parse_ByteVector(text, pos=0, fullparse=True):
    return _run(text, pos, _try_ByteVector, fullparse)

ByteVector = Rule('ByteVector', _parse_ByteVector, """
    ByteVector = vec(bytechar) |> `lambda x: b''.join(x)`
""")
def _try_bytechar(_text, _pos):
    # Rule 'bytechar'
    # Begin Regex
    # /[\\x00-\\xFF]/
    match1 = matcher1(_text, _pos)
    if match1:
        _result = match1.group(0)
        _pos = match1.end()
        _status = True
    else:
        _result = _raise_error519
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_bytechar(text, pos=0, fullparse=True):
    return _run(text, pos, _try_bytechar, fullparse)

bytechar = Rule('bytechar', _parse_bytechar, """
    bytechar = /[\\x00-\\xFF]/
""")
def _raise_error519(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'bytechar' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Name(_text, _pos):
    # Rule 'Name'
    # Begin Apply
    # vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
    # Begin Call
    # vec(bytechar)
    func23 = _ParseFunction(_try_vec, (_try_bytechar,), ())
    (_status, _result, _pos) = (yield (3, func23, _pos))
    # End Call
    if _status:
        arg4 = _result
        _result = lambda x: b''.join(x).decode('utf8')
        _status = True
        _result = _result(arg4)
    # End Apply
    yield (_status, _result, _pos)

def _parse_Name(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Name, fullparse)

Name = Rule('Name', _parse_Name, """
    Name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`
""")
class LocatedName(Node):
    """
    class LocatedName {
        start: `_pos`
        name: Name
        end: `_pos`
    }
    """
    _fields = ('start', 'name', 'end')

    def __init__(self, start, name, end):
        Node.__init__(self)
        self.start = start
        self.name = name
        self.end = end

    def __repr__(self):
        return f'LocatedName(start={self.start!r}, name={self.name!r}, end={self.end!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_LocatedName, fullparse)


def _try_LocatedName(_text, _pos):
    # Begin Seq
    start_pos43 = _pos
    while True:
        _result = _pos
        _status = True
        start = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        _result = _pos
        _status = True
        end = _result
        _result = LocatedName(start, name, end)
        _result._metadata.position_info = (start_pos43, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_byte(_text, _pos):
    # Rule 'byte'
    # Begin Apply
    # /[\\x00-\\xFF]/ |> `ord`
    # Begin Regex
    # /[\\x00-\\xFF]/
    match2 = matcher1(_text, _pos)
    if match2:
        _result = match2.group(0)
        _pos = match2.end()
        _status = True
    else:
        _result = _raise_error536
        _status = False
    # End Regex
    if _status:
        arg5 = _result
        _result = ord
        _status = True
        _result = _result(arg5)
    # End Apply
    yield (_status, _result, _pos)

def _parse_byte(text, pos=0, fullparse=True):
    return _run(text, pos, _try_byte, fullparse)

byte = Rule('byte', _parse_byte, """
    byte = /[\\x00-\\xFF]/ |> `ord`
""")
def _raise_error536(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'byte' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_u32(_text, _pos):
    # Rule 'u32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_UnsignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_u32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_u32, fullparse)

u32 = Rule('u32', _parse_u32, """
    u32 = UnsignedInt
""")
def _try_i32(_text, _pos):
    # Rule 'i32'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i32, fullparse)

i32 = Rule('i32', _parse_i32, """
    i32 = SignedInt
""")
def _try_i64(_text, _pos):
    # Rule 'i64'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_SignedInt, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_i64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_i64, fullparse)

i64 = Rule('i64', _parse_i64, """
    i64 = SignedInt
""")
def _try_f32(_text, _pos):
    # Rule 'f32'
    # Begin Apply
    # /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{4}/
    match3 = matcher2(_text, _pos)
    if match3:
        _result = match3.group(0)
        _pos = match3.end()
        _status = True
    else:
        _result = _raise_error546
        _status = False
    # End Regex
    if _status:
        arg6 = _result
        _result = lambda x: struct.unpack('<f', x)[0]
        _status = True
        _result = _result(arg6)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f32(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f32, fullparse)

f32 = Rule('f32', _parse_f32, """
    f32 = /[\\x00-\\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
""")
def _raise_error546(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f32' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{4}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{4}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_f64(_text, _pos):
    # Rule 'f64'
    # Begin Apply
    # /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
    # Begin Regex
    # /[\\x00-\\xFF]{8}/
    match4 = matcher3(_text, _pos)
    if match4:
        _result = match4.group(0)
        _pos = match4.end()
        _status = True
    else:
        _result = _raise_error550
        _status = False
    # End Regex
    if _status:
        arg7 = _result
        _result = lambda x: struct.unpack('<d', x)[0]
        _status = True
        _result = _result(arg7)
    # End Apply
    yield (_status, _result, _pos)

def _parse_f64(text, pos=0, fullparse=True):
    return _run(text, pos, _try_f64, fullparse)

f64 = Rule('f64', _parse_f64, """
    f64 = /[\\x00-\\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`
""")
def _raise_error550(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'f64' rule, at the expression:\n"
    '    /[\\\\x00-\\\\xFF]{8}/\n\n'
    "Expected to match the regular expression /b'[\\\\x00-\\\\xFF]{8}'/"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_SignedInt(_text, _pos):
    # Rule 'SignedInt'
    # Begin Apply
    # LEB128 |> `decode_signed_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg8 = _result
        _result = decode_signed_int
        _status = True
        _result = _result(arg8)
    # End Apply
    yield (_status, _result, _pos)

def _parse_SignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_SignedInt, fullparse)

SignedInt = Rule('SignedInt', _parse_SignedInt, """
    SignedInt = LEB128 |> `decode_signed_int`
""")
def _try_UnsignedInt(_text, _pos):
    # Rule 'UnsignedInt'
    # Begin Apply
    # LEB128 |> `decode_unsigned_int`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _try_LEB128, _pos))
    # End Ref
    if _status:
        arg9 = _result
        _result = decode_unsigned_int
        _status = True
        _result = _result(arg9)
    # End Apply
    yield (_status, _result, _pos)

def _parse_UnsignedInt(text, pos=0, fullparse=True):
    return _run(text, pos, _try_UnsignedInt, fullparse)

UnsignedInt = Rule('UnsignedInt', _parse_UnsignedInt, """
    UnsignedInt = LEB128 |> `decode_unsigned_int`
""")
def _try_LEB128(_text, _pos):
    # Rule 'LEB128'
    # Begin Regex
    # /[\\x80-\\xFF]*[\\x00-\\x7F]/
    match5 = matcher4(_text, _pos)
    if match5:
        _result = match5.group(0)
        _pos = match5.end()
        _status = True
    else:
        _result = _raise_error561
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LEB128(text, pos=0, fullparse=True):
    return _run(text, pos, _try_LEB128, fullparse)

LEB128 = Rule('LEB128', _parse_LEB128, """
    LEB128 = /[\\x80-\\xFF]*[\\x00-\\x7F]/
""")
def _raise_error561(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LEB128' rule, at the expression:\n"
    '    /[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]/\n\n'
    "Expected to match the regular expression /b'[\\\\x80-\\\\xFF]*[\\\\x00-\\\\x7F]'/"
    )
    raise ParseError((title + details), _pos, line, col)

class CodeEntry(Node):
    """
    class CodeEntry {
        let size: u32
        locals: vec(Locals)
        expression: Expression
    }
    """
    _fields = ('locals', 'expression')

    def __init__(self, locals, expression):
        Node.__init__(self)
        self.locals = locals
        self.expression = expression

    def __repr__(self):
        return f'CodeEntry(locals={self.locals!r}, expression={self.expression!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_CodeEntry, fullparse)


def _try_CodeEntry(_text, _pos):
    # Begin Seq
    start_pos44 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        size = _result
        # Begin Call
        # vec(Locals)
        func24 = _ParseFunction(_try_vec, (_try_Locals,), ())
        (_status, _result, _pos) = (yield (3, func24, _pos))
        # End Call
        if not (_status):
            break
        locals = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Expression, _pos))
        # End Ref
        if not (_status):
            break
        expression = _result
        _result = CodeEntry(locals, expression)
        _result._metadata.position_info = (start_pos44, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Locals(Node):
    """
    class Locals {
        count: u32
        type: ValueType
    }
    """
    _fields = ('count', 'type')

    def __init__(self, count, type):
        Node.__init__(self)
        self.count = count
        self.type = type

    def __repr__(self):
        return f'Locals(count={self.count!r}, type={self.type!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Locals, fullparse)


def _try_Locals(_text, _pos):
    # Begin Seq
    start_pos45 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        count = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ValueType, _pos))
        # End Ref
        if not (_status):
            break
        type = _result
        _result = Locals(count, type)
        _result._metadata.position_info = (start_pos45, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _try_Expression(_text, _pos):
    # Rule 'Expression'
    # Begin Discard
    # Instruction* << 0xb
    while True:
        # Begin List
        # Instruction*
        staging16 = []
        while True:
            checkpoint16 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _try_Instruction, _pos))
            # End Ref
            if not (_status):
                _pos = checkpoint16
                break
            staging16.append(_result)
        _result = staging16
        _status = True
        # End List
        staging17 = _result
        # Begin Byte
        # 0xb
        if (_pos < len(_text)) and (_text[_pos] == 11):
            _result = 11
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error582
            _status = False
        # End Byte
        if _status:
            _result = staging17
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_Expression(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Expression, fullparse)

Expression = Rule('Expression', _parse_Expression, """
    Expression = Instruction* << 0xb
""")
def _raise_error582(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Expression' rule, at the expression:\n"
    '    0xb\n\n'
    'Expected to match the byte value 0xb'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Instruction(_text, _pos):
    # Rule 'Instruction'
    # Begin Choice
    farthest_err10 = _raise_error584
    backtrack23 = farthest_pos10 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Unreachable, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = backtrack23
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_Nop, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = backtrack23
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_GetLocal, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = backtrack23
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_ConstI32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = backtrack23
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_AddI32, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos10 < _pos):
            farthest_pos10 = _pos
            farthest_err10 = _result
        _pos = farthest_pos10
        _result = farthest_err10
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Instruction(text, pos=0, fullparse=True):
    return _run(text, pos, _try_Instruction, fullparse)

Instruction = Rule('Instruction', _parse_Instruction, """
    Instruction = Unreachable | Nop | GetLocal | ConstI32 | AddI32
""")
def _raise_error584(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Instruction' rule, at the expression:\n"
    '    Unreachable | Nop | GetLocal | ConstI32 | AddI32\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Unreachable(Node):
    """
    class Unreachable {
        let id: 0x0
    }
    """
    _fields = ()

    id = 0x0

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'Unreachable()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Unreachable, fullparse)


def _try_Unreachable(_text, _pos):
    # Begin Seq
    start_pos46 = _pos
    while True:
        # Begin Byte
        # 0x0
        if (_pos < len(_text)) and (_text[_pos] == 0):
            _result = 0
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error593
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = Unreachable()
        _result._metadata.position_info = (start_pos46, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error593(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Unreachable' rule, at the expression:\n"
    '    0x0\n\n'
    'Expected to match the byte value 0x0'
    )
    raise ParseError((title + details), _pos, line, col)

class Nop(Node):
    """
    class Nop {
        let id: 0x1
    }
    """
    _fields = ()

    id = 0x1

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'Nop()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_Nop, fullparse)


def _try_Nop(_text, _pos):
    # Begin Seq
    start_pos47 = _pos
    while True:
        # Begin Byte
        # 0x1
        if (_pos < len(_text)) and (_text[_pos] == 1):
            _result = 1
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error597
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = Nop()
        _result._metadata.position_info = (start_pos47, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error597(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Nop' rule, at the expression:\n"
    '    0x1\n\n'
    'Expected to match the byte value 0x1'
    )
    raise ParseError((title + details), _pos, line, col)

class GetLocal(Node):
    """
    class GetLocal {
        let id: 0x20
        index: u32
    }
    """
    _fields = ('index',)

    id = 0x20

    def __init__(self, index):
        Node.__init__(self)
        self.index = index

    def __repr__(self):
        return f'GetLocal(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_GetLocal, fullparse)


def _try_GetLocal(_text, _pos):
    # Begin Seq
    start_pos48 = _pos
    while True:
        # Begin Byte
        # 0x20
        if (_pos < len(_text)) and (_text[_pos] == 32):
            _result = 32
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error601
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_u32, _pos))
        # End Ref
        if not (_status):
            break
        index = _result
        _result = GetLocal(index)
        _result._metadata.position_info = (start_pos48, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error601(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GetLocal' rule, at the expression:\n"
    '    0x20\n\n'
    'Expected to match the byte value 0x20'
    )
    raise ParseError((title + details), _pos, line, col)

class ConstI32(Node):
    """
    class ConstI32 {
        let id: 0x41
        number: i32
    }
    """
    _fields = ('number',)

    id = 0x41

    def __init__(self, number):
        Node.__init__(self)
        self.number = number

    def __repr__(self):
        return f'ConstI32(number={self.number!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_ConstI32, fullparse)


def _try_ConstI32(_text, _pos):
    # Begin Seq
    start_pos49 = _pos
    while True:
        # Begin Byte
        # 0x41
        if (_pos < len(_text)) and (_text[_pos] == 65):
            _result = 65
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error607
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _try_i32, _pos))
        # End Ref
        if not (_status):
            break
        number = _result
        _result = ConstI32(number)
        _result._metadata.position_info = (start_pos49, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error607(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ConstI32' rule, at the expression:\n"
    '    0x41\n\n'
    'Expected to match the byte value 0x41'
    )
    raise ParseError((title + details), _pos, line, col)

class AddI32(Node):
    """
    class AddI32 {
        let id: 0x6a
    }
    """
    _fields = ()

    id = 0x6a

    def __init__(self):
        Node.__init__(self)

    def __repr__(self):
        return f'AddI32()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(text, pos, _try_AddI32, fullparse)


def _try_AddI32(_text, _pos):
    # Begin Seq
    start_pos50 = _pos
    while True:
        # Begin Byte
        # 0x6a
        if (_pos < len(_text)) and (_text[_pos] == 106):
            _result = 106
            _pos = (_pos + 1)
            _status = True
        else:
            _result = _raise_error613
            _status = False
        # End Byte
        if not (_status):
            break
        id = _result
        _result = AddI32()
        _result._metadata.position_info = (start_pos50, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error613(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'AddI32' rule, at the expression:\n"
    '    0x6a\n\n'
    'Expected to match the byte value 0x6a'
    )
    raise ParseError((title + details), _pos, line, col)

