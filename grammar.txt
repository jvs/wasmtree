```
import struct
```

class Module {
    let magic: b'\x00\x61\x73\x6D'
    let version: b'\x01\x00\x00\x00'

    custom1: CustomSection*

    type_section: TypeSection?
    custom2: CustomSection*

    import_section: ImportSection?
    custom3: CustomSection*

    function_section: FunctionSection?
    custom4: CustomSection*

    table_section: TableSection?
    custom5: CustomSection*

    memory_section: MemorySection?
    custom6: CustomSection*

    global_section: GlobalSection?
    custom7: CustomSection*

    export_section: ExportSection?
    custom8: CustomSection*

    start_section: StartSection?
    custom9: CustomSection*

    element_section: ElementSection?
    custom10: CustomSection*

    data_count_section: DataCountSection?
    custom11: CustomSection*

    code_section: CodeSection?
    custom12: CustomSection*

    data_section: DataSection?
    custom13: CustomSection*
}


# Sections.
class CustomSection {
    let id: 0x00
    let size: u32
    let loc: LocatedName
    let remaining = `size - (loc.end - loc.start)`

    name: `loc.name`
    body: ByteString(remaining)
}

class TypeSection {
    let id: 0x01
    let size: u32
    function_types: vec(FuncType)
}

class ImportSection {
    let id: 0x02
    let size: u32
    imports: vec(Import)
}

class FunctionSection {
    let id: 0x03
    let size: u32
    type_indexes: vec(u32)
}

class TableSection {
    let id: 0x04
    let size: u32
    table_types: vec(TableType)
}

class MemorySection {
    let id: 0x05
    let size: u32
    memory_types: vec(MemoryType)
}

class GlobalSection {
    let id: 0x06
    let size: u32
    globals: vec(Global)
}

class ExportSection {
    let id: 0x07
    let size: u32
    exports: vec(Export)
}

class StartSection {
    let id: 0x08
    let size: u32
    index: u32
}

class ElementSection {
    let id: 0x09
    let size: u32
    segments: vec(ElementSegment)
}

class DataCountSection {
    let id: 0x0C
    let size: u32
    count: Opt(u32 where `lambda _: size > 0`)
}

class CodeSection {
    let id: 0x0A
    let size: u32
    entries: vec(CodeEntry)
}

class DataSection {
    let id: 0x0B
    let size: u32
    segments: vec(DefaultDataSegment | PassiveDataSegment | ActiveDataSegment)
}


# Globals.
class Global {
    type: GlobalType
    initializer: Expression
}


# Imports.
class Import {
    module: Name
    name: Name
    descriptor: ImportFunc | ImportTable | ImportMemory | ImportGlobal
}

class ImportFunc {
    let id: 0x00
    type: u32
}

class ImportTable {
    let id: 0x01
    type: TableType
}

class ImportMemory {
    let id: 0x02
    type: MemoryType
}

class ImportGlobal {
    let id: 0x03
    type: GlobalType
}


# Exports.
class Export {
    name: Name
    descriptor: ExportFunc | ExportTable | ExportMemory | ExportGlobal
}

class ExportFunc {
    let id: 0x00
    index: u32
}

class ExportTable {
    let id: 0x01
    index: u32
}

class ExportMemory {
    let id: 0x02
    index: u32
}

class ExportGlobal {
    let id: 0x03
    index: u32
}


# Element segments.
ElementSegment = (
    DefaultSegment
    | PassiveFuncRefSegment
    | ActiveFuncRefSegment
    | DeclarativeFuncRefSegment
    | DefaultExpressionSegment
    | PassiveExpressionSegment
    | ActiveExpressionSegment
    | DeclarativeExpressionSegment
)

class DefaultSegment {
    let id: 0x00
    offset: Expression
    function_indexes: vec(u32)
}

class PassiveFuncRefSegment {
    let id: 0x01
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class ActiveFuncRefSegment {
    let id: 0x02
    table_index: u32
    offset: Expression
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class DeclarativeFuncRefSegment {
    let id: 0x03
    type: 0x00 >> `'funcref'`
    function_indexes: vec(u32)
}

class DefaultExpressionSegment {
    let id: 0x04
    offset: Expression
    initializers: vec(Expression)
}

class PassiveExpressionSegment {
    let id: 0x05
    type: ReferenceType
    initializers: vec(Expression)
}

class ActiveExpressionSegment {
    let id: 0x06
    table_index: u32
    offset: Expression
    type: ReferenceType
    initializers: vec(Expression)
}

class DeclarativeExpressionSegment {
    let id: 0x07
    type: ReferenceType
    initializers: vec(Expression)
}


# Data segments.
class DefaultDataSegment {
    let id: 0x00
    offset: Expression
    contents: ByteVector
}

class PassiveDataSegment {
    let id: 0x01
    contents: ByteVector
}

class ActiveDataSegment {
    let id: 0x02
    index: u32
    offset: Expression
    contents: ByteVector
}


# Limits.
Limits = MinLimit | MinMaxLimits

class MinLimit {
    let id: 0x00
    min: u32
}

class MinMaxLimits {
    let id: 0x01
    min: u32
    max: u32
}


# Types.
class FuncType {
    let id: 0x60
    params: vec(ValueType)
    results: vec(ValueType)
}

class GlobalType {
    type: ValueType
    modifier: 0x00 >> `'const'` | 0x01 >> `'var'`
}

class MemoryType {
    limits: Limits
}

NumberType = (
    0x7F >> `'i32'`
    | 0x7E >> `'i64'`
    | 0x7D >> `'f32'`
    | 0x7C >> `'f64'`
)

class TableType {
    type: ReferenceType
    limits: Limits
}

ReferenceType = (
    0x70 >> `'funcref'`
    | 0x6F >> `'externref'`
)

ValueType = NumberType | ReferenceType


# Vectors.
vec(element) =>
    let length = u32 in
    element{length}


# Uninterpreted bytes.
ByteString(size) => bytechar{size} |> `lambda x: b''.join(x)`
ByteVector => vec(bytechar) |> `lambda x: b''.join(x)`
bytechar = b/[\x00-\xFF]/


# Names.
Name = vec(bytechar) |> `lambda x: b''.join(x).decode('utf8')`


class LocatedName {
    start: `_pos`
    name: Name
    end: `_pos`
}


# Numbers.
byte = b/[\x00-\xFF]/ |> `ord`
u32 = UnsignedInt
i32 = SignedInt
i64 = SignedInt
f32 = b/[\x00-\xFF]{4}/ |> `lambda x: struct.unpack('<f', x)[0]`
f64 = b/[\x00-\xFF]{8}/ |> `lambda x: struct.unpack('<d', x)[0]`

SignedInt = LEB128 |> `decode_signed_int`
UnsignedInt = LEB128 |> `decode_unsigned_int`
LEB128 = b/[\x80-\xFF]*[\x00-\x7F]/

```
continue_flag = 1 << 7

def decode_signed_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    sign = 1 << 6
    if b & sign:
        result |= (~0 << shift)

    return result

def decode_unsigned_int(bytes):
    mask = 0xFF >> 1
    result = 0
    shift = 0

    for b in bytes:
        result |= (b & mask) << shift
        shift += 7

    return result
```


# Code.
class CodeEntry {
    let size: u32
    locals: vec(Locals)
    expression: Expression
}

class Locals {
    count: u32
    type: ValueType
}


# Instructions.
Expression => Instruction* << 0x0B

Instruction = (
    Unreachable
    | Nop
    | GetLocal
    | ConstI32
    | AddI32
)

class Unreachable {
    let id: 0x00
}

class Nop {
    let id: 0x01
}

class GetLocal {
    let id: 0x20
    index: u32
}

class ConstI32 {
    let id: 0x41
    number: i32
}

class AddI32 {
    let id: 0x6A
}
